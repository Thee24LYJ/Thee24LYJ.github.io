<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>json学习笔记</title>
      <link href="/2023/08/14/json%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/14/json%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://www.runoob.com/json/json-tutorial.html">JSON 教程</a></p></blockquote><h1 id="一、JSON简介"><a href="#一、JSON简介" class="headerlink" title="一、JSON简介"></a>一、JSON简介</h1><ul><li>轻量级的文本数据交换格式</li></ul><h1 id="二、JSON语法"><a href="#二、JSON语法" class="headerlink" title="二、JSON语法"></a>二、JSON语法</h1><blockquote><ul><li>JavaScript对象表示语法子集</li></ul></blockquote><ul><li>数据在<strong>名称/值</strong>对中</li><li>数据由逗号 <strong>,</strong> 分隔</li><li>使用斜杆 <strong>\</strong> 来转义字符</li><li>大括号 <strong>{}</strong> 保存对象<ul><li>无序的<strong>名称/值</strong>对集合，<strong>名称/值</strong>使用逗号 <strong>,</strong> 分隔</li><li>一个对象以左大括号 <strong>{</strong> 开始， 右大括号 <strong>}</strong> 结束，每个名称(“键”)后跟一个冒号 <strong>:</strong></li></ul></li><li>中括号 <strong>[]</strong> 保存数组，数组可以包含多个对象<ul><li>值的有序集合，值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array），它们可以嵌套</li><li>一个数组以左中括号 <strong>[</strong> 开始， 右中括号 <strong>]</strong> 结束，值之间使用逗号 <strong>,</strong> 分隔</li></ul></li></ul><ul><li>JSON名称/值对</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key <span class="punctuation">:</span> value</span><br><span class="line">例如<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;thee&quot;</span></span><br><span class="line">等价于<span class="punctuation">:</span></span><br><span class="line">name = <span class="string">&quot;thee&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三、JSON对象"><a href="#三、JSON对象" class="headerlink" title="三、JSON对象"></a>三、JSON对象</h1><blockquote><p>JSON 对象使用在大括号 <strong>{…}</strong> 中书写。对象可以包含多个 <strong>key/value（键/值）</strong>对</p><p>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）</p><p>key 和 value 间使用冒号 <strong>:</strong> 分割；每个 key/value 对间使用逗号 <strong>,</strong> 分割</p></blockquote><ul><li><p>访问对象值(使用<code>for (x in json_obj)</code>来循环访问对象属性即key(键))</p><ul><li>点号 <strong>.</strong> 访问(点号后接key(键)，无需双引号)</li><li>中括号 <strong>[ ]</strong> 访问(中括号内填key(键)，需添加双引号)</li></ul></li><li><p>删除对象属性key(键)(<code>delete key</code>)，同时也会删除value(值)</p></li></ul><h1 id="四、JSON数组"><a href="#四、JSON数组" class="headerlink" title="四、JSON数组"></a>四、JSON数组</h1><ul><li><p>访问数组：使用索引值(下标从0开始)</p></li><li><p>循环访问数组</p><ul><li><code>for (i in json_obj.sites)</code></li><li>for循环</li></ul></li><li>删除数组元素(<code>delete ...</code>)</li></ul><h1 id="五、字符串和JSON对象的转换"><a href="#五、字符串和JSON对象的转换" class="headerlink" title="五、字符串和JSON对象的转换"></a>五、字符串和JSON对象的转换</h1><h3 id="1-JSON-parse"><a href="#1-JSON-parse" class="headerlink" title="1.JSON.parse()"></a>1.JSON.parse()</h3><blockquote><p>该方法将数据转换为JavaScript对象，即可以解析的JSON数据</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(text, [reviver])</span><br><span class="line">参数:</span><br><span class="line">text: 有效的JSON字符串</span><br><span class="line">reviver: 可选, 转换结果的函数，将为对象的每个成员调用该函数</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>AJAX</code>从服务器请求JSON数据并解析为JavaScript对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        myObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = myObj.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/try/ajax/json_demo.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></blockquote><ul><li>JSON不能存储Date对象，如果确实需要存储则需要将其转换为字符串再将字符串转换为Date对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text);</span><br><span class="line">obj.<span class="property">initDate</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(obj.<span class="property">initDate</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = obj.<span class="property">name</span> + <span class="string">&quot;创建日期: &quot;</span> + obj.<span class="property">initDate</span>;</span><br></pre></td></tr></table></figure><ul><li>我们可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text, <span class="keyword">function</span> (<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&quot;initDate&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = obj.<span class="property">name</span> + <span class="string">&quot;创建日期：&quot;</span> + obj.<span class="property">initDate</span>;</span><br></pre></td></tr></table></figure><ul><li>JSON 不允许包含函数，可以先将函数作为字符串存储，再将字符串转换为函数，但不建议在JSON中使用函数</li></ul><h3 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2.JSON.stringify()"></a>2.JSON.stringify()</h3><blockquote><p>该方法将 JavaScript 对象转换为字符串数据</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value, replacer, space)</span><br><span class="line">参数:</span><br><span class="line"><span class="attr">value</span>: 待转换的<span class="title class_">JavaScript</span>值(<span class="title class_">JSON</span>对象)</span><br><span class="line"><span class="attr">replacer</span>: 可选, 用于转换结果的函数或数组。如果 replacer 为函数，则 <span class="title class_">JSON</span>.<span class="property">stringify</span> 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 <span class="literal">undefined</span>，则排除成员。根对象的键是一个空字符串：<span class="string">&quot;&quot;</span>。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组</span><br><span class="line">    <span class="attr">space</span>: 可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 <span class="number">10</span>，则文本缩进 <span class="number">10</span> 个空格。space 也可以使用非数字，如：\t</span><br></pre></td></tr></table></figure><ul><li>由于JSON不能存储Date对象，因此JSON.stringify() 会将所有日期转换为字符串</li><li>JSON 也不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value；可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免，但不建议在JSON中使用函数</li></ul><p>由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象，不过必须把文本用括号括起来，这样才能避免语法错误；eval() 函数可编译并执行任何 JavaScript 代码，但这隐藏了一个潜在的安全问题</p><h1 id="六、JSONP"><a href="#六、JSONP" class="headerlink" title="六、JSONP"></a>六、JSONP</h1><blockquote><p>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据(同源策略)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《linux命令行大全》阅读笔记</title>
      <link href="/2023/08/14/%E3%80%8Alinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/14/%E3%80%8Alinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是《Linux命令行大全》的阅读笔记，仅供参考，更多详细内容请参见该书。</p></blockquote><h3 id="1-符号链接"><a href="#1-符号链接" class="headerlink" title="1.符号链接"></a>1.符号链接</h3><ul><li><p>软链接(item可以是一个文件或目录)</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s item <span class="built_in">link</span></span><br></pre></td></tr></table></figure></li></ul><p>一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例如，如果我们往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接</p><p>符号链接文件的长度是目标文件字符串所包含的字符数，而不是符号链接所指向的文件长度</p><p>链接所指向的文件长度</p><ul><li><p>硬链接(一个文件至少有一个硬链接)</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> file <span class="built_in">link</span></span><br></pre></td></tr></table></figure></li><li><p>硬链接的局限性</p><ul><li>一个硬链接不能关联它所在文件系统之外的文件，也就是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件(不同的物理磁盘)</li><li>一个硬链接不能关联一个目录</li></ul></li></ul><blockquote><p>一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文件本身的内容仍然存在（即它所占的磁盘空间不会被重新分配），直到所有关联这个文件的链接都删除掉</p><p>假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分，当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分，并且这些名字都关联到相同的数据部分。这时系统会分配一连串的磁盘块给所谓的索引节点，然后索引节点与文件名字部分相关联。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点(<code>ls -li</code>显示文件索引节点信息)</p></blockquote><p>在 GNOME 里面，当拖动文件时，同时按下 Ctrl+Shift 按键会创建一个链接，而不是复制（或移动）文件。在 KDE 中，无论什么时候放下一个文件，会弹出一个小菜单，这个菜单会提供复制，移动，或创建链接文件选项</p><h3 id="2-shell的通配符"><a href="#2-shell的通配符" class="headerlink" title="2.shell的通配符"></a>2.shell的通配符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任意多个字符</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配任意一个字符</td></tr><tr><td style="text-align:center">[characters]</td><td style="text-align:center">匹配任意一个属于字符集中的字符</td></tr><tr><td style="text-align:center">[!characters]</td><td style="text-align:center">匹配任意一个不是字符集中的字符</td></tr><tr><td style="text-align:center">[[:class:]]</td><td style="text-align:center">匹配任意一个属于指定字符类中的字符</td></tr></tbody></table></div><ul><li>最常用字符类</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符类</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">[:alnum:]</td><td style="text-align:center">匹配任意一个字母或数字</td></tr><tr><td style="text-align:center">[:alpha:]</td><td style="text-align:center">匹配任意一个字母</td></tr><tr><td style="text-align:center">[:gidit:]</td><td style="text-align:center">匹配任意一个数字</td></tr><tr><td style="text-align:center">[:lower:]</td><td style="text-align:center">匹配任意一个小写字母</td></tr><tr><td style="text-align:center">[:upper:]</td><td style="text-align:center">匹配任意一个大写字母</td></tr></tbody></table></div><blockquote><p>g*：文件名以<code>g</code>开头的文件</p><p>[abc]*：文件名以<code>a,b或c</code>开头的文件</p><p>*[[:lower:]123]：文件名以小写字母或以<code>1,2或3</code>结尾的文件</p><p>注意表示法<strong>:</strong> 在描述一个命令时，当有三个圆点跟在一个命令的参数后面，这意味着那个参数可以重复</p></blockquote><h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">type</td><td style="text-align:center">显示命令类型</td></tr><tr><td style="text-align:center">which</td><td style="text-align:center">显示<strong>可执行程序</strong>的位置(不包括内建)</td></tr><tr><td style="text-align:center">help</td><td style="text-align:center">显示shell内建命令帮助文档</td></tr><tr><td style="text-align:center">—help</td><td style="text-align:center">显示用法信息</td></tr><tr><td style="text-align:center">man</td><td style="text-align:center">显示程序手册页</td></tr><tr><td style="text-align:center">apropos</td><td style="text-align:center">显示适当的命令</td></tr><tr><td style="text-align:center">whatis</td><td style="text-align:center">显示非常简洁的命令说明</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">显示程序的info页</td></tr><tr><td style="text-align:center">alias</td><td style="text-align:center">创建我们自己的命令</td></tr></tbody></table></div><ul><li><code>alias name=&#39;string&#39;</code>：给命令创建别名    <code>unalias</code>：删除别名</li><li>要查看所有定义在系统环境中的别名，使用不带参数的 <code>alias</code> 命令</li><li><p>命令行小技巧：把多个命令放在同一行上，命令之间用<code>;</code>分开</p></li><li><p>相关命令</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">cat</td><td style="text-align:center">连接文件</td></tr><tr><td style="text-align:center">sort</td><td style="text-align:center">排序文本行</td></tr><tr><td style="text-align:center">uniq</td><td style="text-align:center">报道或省略重复行</td></tr><tr><td style="text-align:center">grep</td><td style="text-align:center">打印匹配行</td></tr><tr><td style="text-align:center">wc</td><td style="text-align:center">打印文件中换行符、字和字节个数</td></tr><tr><td style="text-align:center">head</td><td style="text-align:center">输出文件的第一部分(默认10行)</td></tr><tr><td style="text-align:center">tail</td><td style="text-align:center">输出文件的最后一部分(默认10行)</td></tr><tr><td style="text-align:center">tee</td><td style="text-align:center">从标准输入读取数据并同时写到标准输出和文件</td></tr></tbody></table></div><h3 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4.重定向"></a>4.重定向</h3><ul><li>标准输入(stdin)    标准输入重定向<code>&lt;</code></li><li>标准输出(stdout)    标准输出重定向<code>&gt;/&gt;&gt;</code>：<code>&gt;</code>表示开头重写文件 <code>&gt;&gt;</code>表示追加重定向结果到文件内容之后</li><li>标准错误(stderr)    标准错误重定向</li></ul><blockquote><p>当我们使用<code>&gt;</code>重定向符来重定向输出结果时，目标文件总是从开头被重写。若<code>ls</code>命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：<code>&gt; ls-output,txt</code></p><p>标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。虽然我们已经将这些文件流的前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符 0、1 和 2。shell 使用文件描述符提供了一种表示法来重定向文件。因为标准错误被称为文件描述符 2，因此可以用这种表示法来重定向标准错误，例如：<code>ls -l /bin/usr 2&gt; ls-error.txt</code>，其中文件描述符 “2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件的任务</p><p>重定向标准输出和错误到同一文件：</p><ul><li><p>传统方法(旧版bash)：<code>ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</code></p><p>   首先重定向标准输出到文件 ls-output.txt，然后重定向文件描述符 2（标准错误）到文件描述符 1（标准输出）使用表示法 2&gt;&amp;1，注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后，要不然它不起作用</p></li><li><p>现代方法(新版bash)：<code>ls -l /bin/usr &amp;&gt; ls-output.txt</code></p></li></ul></blockquote><ul><li>管道线</li></ul><blockquote><p>命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。使用管道操作符 “|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command1 | command2</span><br></pre></td></tr></table></figure><p>有时有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器</p><p>uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行</p></blockquote><h3 id="5-echo"><a href="#5-echo" class="headerlink" title="5.echo"></a>5.echo</h3><ul><li>字符展开</li></ul><blockquote><p>每当我们输入一个命令并按下 enter 键，bash 会在执行你的命令之前对输入的字符完成几个步骤的处理。这背后的过程叫做（字符）展开。通过展开，我们输入的字符，在 shell 对它起作用之前，会展开成为别的字符</p><p>波浪线字符 (“<em>∼</em>”) 有特殊的含义。当它用在一个单词的开头时(没有空格)，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录</p></blockquote><ul><li>算术表达式展开</li></ul><blockquote><p>格式：<code>$((expression))</code></p><p>算术表达式只支持整数（全部是数字，不带小数点），在算术表达式中空格并不重要，并且表达式可以嵌套</p></blockquote><ul><li>花括号展开</li></ul><blockquote><p>从一个包含花括号的模式中创建多个文本字符串，花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这种模式不能嵌入空白字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line">$ <span class="built_in">echo</span> Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br><span class="line">$  <span class="built_in">echo</span> a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看有效的变量列表</span></span><br><span class="line">$ <span class="built_in">printenv</span> | less</span><br><span class="line"><span class="comment"># 命令替换</span></span><br><span class="line">$ <span class="built_in">echo</span> $(<span class="built_in">ls</span>)<span class="comment"># 把一个命令的输出作为一个展开模式来使用</span></span><br><span class="line"><span class="comment"># 在旧版 shell 程序中，bash 也支持命令替换。它使用倒引号来代替美元符号和括号</span></span><br><span class="line">$ <span class="built_in">echo</span> `<span class="built_in">ls</span>`</span><br></pre></td></tr></table></figure><p>shell 提供了一种叫做引用的机制，来有选择地禁止不需要的展开</p></blockquote><ul><li>双引号</li></ul><blockquote><p>把文本放在双引号中，shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。有几个例外：<code>$、\</code> (反斜杠）和 `（倒引号），但参数展开、算术展开和命令替换仍然执行</p><p>在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分，它们只作为分隔符使用；但加上双引号，单词分割被禁止，内嵌空格也不会被当做界定符</p></blockquote><ul><li>单引号</li></ul><blockquote><p>如果需要禁止所有的展开，我们要使用单引号</p></blockquote><ul><li>转义字符</li></ul><blockquote><p>阻止单个字符的展开</p><p>echo命令带上<code>-e</code>选项，能够解释转义序列，若不用<code>-e</code>选项则把转义序列放在<code>$&#39;&#39;</code>中也能解释转义序列</p></blockquote><h3 id="6-键盘高级操作技巧"><a href="#6-键盘高级操作技巧" class="headerlink" title="6.键盘高级操作技巧"></a>6.键盘高级操作技巧</h3><ul><li>移动光标</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl-d</td><td style="text-align:center">删除光标位置的字符</td></tr><tr><td style="text-align:center">Ctrl-e</td><td style="text-align:center">移动光标到行尾</td></tr><tr><td style="text-align:center">Ctrl-f</td><td style="text-align:center">光标前移一个字符，和左箭头作用一样</td></tr><tr><td style="text-align:center">Ctrl-b</td><td style="text-align:center">光标后移一个字符，和右箭头作用一样</td></tr><tr><td style="text-align:center">Alt-f</td><td style="text-align:center">光标前移一个字</td></tr><tr><td style="text-align:center">Alt-b</td><td style="text-align:center">光标后移一个字</td></tr><tr><td style="text-align:center">Ctrl-l</td><td style="text-align:center">清空屏幕并移动光标到左上角，与clear作用相同</td></tr></tbody></table></div><ul><li>修改文本</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl-a</td><td style="text-align:center">移动光标到行首</td></tr><tr><td style="text-align:center">Ctrl-t</td><td style="text-align:center">光标位置字符和光标前面字符互换</td></tr><tr><td style="text-align:center">Alt-t</td><td style="text-align:center">光标位置的字和其前面的字互换位置</td></tr><tr><td style="text-align:center">Alt-l</td><td style="text-align:center">把从光标位置到字尾的字符转换为小写字母</td></tr><tr><td style="text-align:center">Alt-u</td><td style="text-align:center">把从光标位置到字尾的字符转换为大写字母</td></tr></tbody></table></div><ul><li>剪切/粘贴文本</li></ul><blockquote><p>Readline 的文档使用术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。剪切下来的本文被存储在一个叫做剪切环 (kill-ring) 的缓冲区中</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl-k</td><td style="text-align:center">剪切从光标位置到行尾的文本</td></tr><tr><td style="text-align:center">Ctrl-u</td><td style="text-align:center">剪切从光标位置到行首的文本</td></tr><tr><td style="text-align:center">Alt-d</td><td style="text-align:center">剪切从光标位置到词尾的文本</td></tr><tr><td style="text-align:center">Alt-Backspace</td><td style="text-align:center">剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词</td></tr><tr><td style="text-align:center">Ctrl-y</td><td style="text-align:center">把剪切环中的文本粘贴到光标位置</td></tr></tbody></table></div><blockquote><p>历史命令展开：<code>!88</code>：bash会把<code>!88</code>展开成为历史列表中88行的内容</p><p><code>!!</code>：重复最后一次执行的命令</p><p><code>!number</code>：重复历史列表中第 number 行的命令</p><p><code>!string</code>：重复最近历史列表中，以这个字符串开头的命令</p><p><code>!?string</code>：重复最近历史列表中，包含这个字符串的命令</p></blockquote><h3 id="7-权限"><a href="#7-权限" class="headerlink" title="7.权限"></a>7.权限</h3><ul><li>拥有者、组成员和其他人</li></ul><blockquote><p><code>-rw-rw-r--</code>：文件所有者(rw-)、文件组所有者(rw-)和其他人(r—)的读、写和执行权限</p><p>掩码：掩码的二进制形式中，出现数字 1 的位置，相应地关掉一个文件模式属性 <code>umask</code>设置默认权限</p></blockquote><p>权限属性：(w属性是针对内容的修改，不过，对于文件来说，w属性指是否可以修改文件中的内容；而对于目录来说，w属性指是否可以修改目录下的文件本身而不是其中的内容)</p><p>其他特殊权限参照<code>《Linux命令行大全》P112</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">文件</th><th style="text-align:center">目录</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">允许打开并读取文件内容</td><td style="text-align:center">允许列出目录内容(前提是目录具有可执行属性)</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">允许写入/截断文件，但不允许对文件进行重命名或删除操作</td><td style="text-align:center">允许在目录下新建、删除或重命名文件(前提是目录具有可执行属性)</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">运行程序(前提是该文件可读)</td><td style="text-align:center">允许进入目录</td></tr></tbody></table></div><ul><li><code>su -</code>：启动超级用户的shell</li><li><code>sudo</code>命令不要求超级用户的密码而是使用当前用户的密码来认证</li></ul><p>su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个用户的 shell 运行环境，需要执行的命令也不需要用单引号引起来</p><ul><li><code>chown</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">thee</td><td style="text-align:center">把文件所有者从当前属主更改为用户thee</td></tr><tr><td style="text-align:center">thee:users</td><td style="text-align:center">把文件所有者改为用户 thee，文件用户组改为用户组 users</td></tr><tr><td style="text-align:center">:admins</td><td style="text-align:center">把文件用户组改为组 admins，文件所有者不变</td></tr><tr><td style="text-align:center">thee:</td><td style="text-align:center">文件所有者改为用户 thee，文件用户组改为用户 thee 登录系统时所属的用户组</td></tr></tbody></table></div><p>练习：如何设置一个共享目录(参见《Linux命令行大全》P117)</p><ul><li><code>passwd</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd [user]</span><br></pre></td></tr></table></figure><h3 id="8-进程"><a href="#8-进程" class="headerlink" title="8.进程"></a>8.进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ps 命令能够展示许多计算机运行状态的信息，但是它只是提供 ps 命令执行时刻的机器状态快照</span></span><br><span class="line">$ ps x<span class="comment"># 展示所有进程</span></span><br><span class="line">$ ps aux <span class="comment"># 展示所有进程的更多信息</span></span><br><span class="line"><span class="comment"># top 程序以进程活动顺序显示连续更新的系统进程列表</span></span><br><span class="line"><span class="comment"># 一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它</span></span><br><span class="line"><span class="comment">#  Ctrl-z，可以停止一个前台进程(不是终止进程)</span></span><br><span class="line"><span class="comment"># jobs 可以列出从终端中启动了的任务的方法</span></span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># fg将进程返回到前台 bg把程序移动到后台</span></span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="comment"># fg 命令之后，跟随着一个百分号和任务序号（叫做 jobspec, 如此处的%1）就可以了。如果我们只有一个后台任务，那么 jobspec(job specification) 是可有可无的</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 Ctrl-c 的情况下，会发送一个叫做 INT（Interrupt, 中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（Terminal Stop, 终端停止）的信号</p><p>可以通过kill命令来给程序发送信号，常见信号参见《Linux命令行大全》P131</p><p><code>kill -l</code>可以得到一个完整的信号列表，<code>killall</code>命令，可以给匹配特定程序或用户名的多个进程发送信号</p></blockquote><ul><li>正常来说，我们对于文件.bashrc 的修改不会生效，直到关闭终端会话，再重新启动一个新的会话，因为.bashrc 文件只是在刚开始启动终端会话时读取，但是可以通过执行<code>source .bashrc</code>来强制激活修改</li></ul><h3 id="9-vi-vim"><a href="#9-vi-vim" class="headerlink" title="9.vi/vim"></a>9.vi/vim</h3><blockquote><ul><li>移动光标：参见《Linux命令行大全》P151</li><li>删除文本：参见《Linux命令行大全》P154</li><li>剪切、复制和粘贴文本：参见《Linux命令行大全》P155</li><li>文件间切换ex命令：<code>:n</code>切换下一个文件 <code>:N</code>返回先前的文件  </li><li>多文件操作：<code>:buffers</code>显示文件列表 <code>:buffer 2</code>切换文件缓冲区 <code>:e new.txt</code>打开(新建)文件并编辑</li><li>插入整个文件内容到其他文件中：<code>:r new.txt</code>(把new.txt文件插入到光标位置之前)</li><li>保存文件：ex命令<code>:w</code>    命令模式下的<code>ZZ</code>(保存并退出文件) ex命令<code>:wq</code>(保存并退出) ex命令<code>:w filename.txt</code>(另存为filename.txt但不会更改当前的文件为filename.txt)</li></ul></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">命令按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">命令模式下，撤销最后一次修改</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">命令模式下，插入文本</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">命令模式下，进入插入模式且光标后移一个字符</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">光标移动到行尾，同时进入插入模式</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在当前行的下方插入一个空白行且进入到插入模式</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在当前行的上方插入一个空白行且进入到插入模式</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在的当前行</td></tr></tbody></table></div><h3 id="10-软件包管理"><a href="#10-软件包管理" class="headerlink" title="10.软件包管理"></a>10.软件包管理</h3><ul><li>查找资源库中的软件包</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">apt-get update; apt-cache search search_string</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">yum search search_string</td></tr></tbody></table></div><ul><li>安装资源库中的软件包</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">apt-get update; apt-get install package_name</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">yum install package_name</td></tr></tbody></table></div><ul><li>通过软件包文件安装软件(非资源库)</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">dpkg —install package_file</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">rpm -i package_file</td></tr></tbody></table></div><ul><li>卸载软件</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">apt-get remove package_name</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">yum erase package_name</td></tr></tbody></table></div><ul><li>更新软件包</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">apt-get update; apt-get upgrade</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">yum update</td></tr></tbody></table></div><ul><li>通过软件包文件升级软件(非资源库)</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">dpkg —install package_file</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">rpm -U package_file</td></tr></tbody></table></div><ul><li>列出所安装的软件包</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">dpkg —list</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">rpm -qa</td></tr></tbody></table></div><ul><li>确定是否安装某个软件包</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">dpkg —status package_name</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">rpm -q package_name</td></tr></tbody></table></div><ul><li>显示安装软件包的信息</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">apt-cache show package_name</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">yum info package_name</td></tr></tbody></table></div><ul><li>查找安装某个文件的软件包</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">风格</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">Debian</td><td style="text-align:center">dpkg —search file_name</td></tr><tr><td style="text-align:center">Red Hat</td><td style="text-align:center">rpm -qf file_name</td></tr></tbody></table></div><h3 id="11-存储媒介"><a href="#11-存储媒介" class="headerlink" title="11.存储媒介"></a>11.存储媒介</h3><blockquote><p>管理存储设备的第一步是把设备连接到文件系统树中。这个叫做 “挂载” 的过程允许设备连接到操作系统中</p><p><code>/etc/fstab</code> 文件中可以查看系统启动时要挂载的设备，其中字段参见《Linux命令行大全》P184</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mount <span class="comment"># 不带参数会显示一系列当前挂载的文件系统(输出格式:设备 on 挂载点 type 文件系统类型（选项）)，带参数则挂载文件系统</span></span><br><span class="line">$ mount -t <span class="built_in">type</span> /dev/sdb2 /mnt/test<span class="comment"># 挂载文件系统 -t选项指定文件系统类型</span></span><br><span class="line">$ umount /dev/sdb2<span class="comment"># 卸载硬件设备</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>fdisk</code>命令操作分区，参见《Linux命令行大全》P191</li><li>使用<code>mkfs</code>命令创建一个新的文件系统，参见《Linux命令行大全》P193</li><li><code>fsck</code>命令除检查文件系统完整性之外，还能修复受损的文件系统，其成功度依赖于损坏的数量</li></ul><h3 id="12-文件查找"><a href="#12-文件查找" class="headerlink" title="12.文件查找"></a>12.文件查找</h3><blockquote><p>locate 程序只能依据文件名来查找文件，而 find 程序能基于各种各样的属性搜索一个给定目录（以及它的子目录）来查找文件</p><p>locate和find命令较为详细说明请参见《Linux命令行大全》P220</p></blockquote><ul><li>locate：通过名字查找文件</li><li>find：在一个目录层次结构中搜索文件</li></ul><h3 id="13-归档和备份"><a href="#13-归档和备份" class="headerlink" title="13.归档和备份"></a>13.归档和备份</h3><blockquote><p>gzip 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。相对应的gunzip 程序被用来把压缩文件复原为没有被压缩的版本</p><p>zip/unzip 压缩/解压缩文件包</p><p>同步文件和目录(rsync)：<code>rsync options source destination</code>，更多请参见《Linux命令行大全》P244</p></blockquote><h3 id="14-正则表达式"><a href="#14-正则表达式" class="headerlink" title="14.正则表达式"></a>14.正则表达式</h3><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep [options] regex [file...]</span><br></pre></td></tr></table></figure><p>grep选项列表参见《Linux命令行大全》P249</p><p>元字符(<code>^ $ . [ ] &#123; &#125; - ? * + ( ) | \</code>)和原义字符(除元字符外的其他所有字符)</p><p>锚点：插入符号<code>^</code>和美元符号<code>$</code>，意味着正则表达式只有在文本行的开头或末尾被找到时，才算发生一次匹配</p><p>正则表达式<code>ˆ$</code>（行首和行尾之间没有字符）会匹配空行</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>.</code>(圆点字符)</td><td style="text-align:center">匹配任意一个字符</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">匹配零个或一个元素</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">匹配零个或多个元素</td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">匹配一个或多个元素</td></tr><tr><td style="text-align:center"><code>&#123;&#125;</code></td><td style="text-align:center">匹配特定个数的元素</td></tr></tbody></table></div><ul><li>中括号表达式和字符类</li></ul><blockquote><p>中括号表达式能从一个指定的字符集合中匹配单个字符。通过中括号表达式，我们能够指定一个待匹配字符集合（包含在不加中括号的情况下会被解释为元字符的字符）</p><p>一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符是插入字符（ˆ），其被用来表示否定(必须是中括号表达式的第一个字符才具有否定的功能)；第二个是连字符字符（-），其被用来表示一个字符范围</p><p>若要在正则表达式中包含一个连字符，则需要使连字符成为表达式中的第一个字符</p></blockquote><ul><li>转换MS-DOS文本文件为Unix风格文本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; dos_file &gt; unix_file</span><br></pre></td></tr></table></figure><p><code>tr</code>命令可以执行ROT13文本编码(简易加密类型) (两次执行恢复原来的文本)</p><h3 id="15-格式化输出"><a href="#15-格式化输出" class="headerlink" title="15.格式化输出"></a>15.格式化输出</h3><ul><li>nl：添加行号</li><li>fold：限制文件行宽</li><li>fmt：填充和连接文本行，同时保留空白符和缩进</li><li>pr：格式化打印文本(给文本分页)</li><li>printf：格式化打印，较为详细请参见《Linux命令行大全》P320</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用构建源码包命令</span></span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><h3 id="16-bash脚本"><a href="#16-bash脚本" class="headerlink" title="16.bash脚本"></a>16.bash脚本</h3><blockquote><p>对于脚本文件，有两个常见的权限设置；权限为 755 的脚本，则每个人都能执行；权限为700 的脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的</p></blockquote><ul><li>添加PATH变量的目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=~/bin:<span class="string">&quot;<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">$ . .bashrc<span class="comment"># 点(.)命令是 source 命令的同义词，一个 shell 内建命令，用来读取一个指定的 shell命令文件，并把它看作是从键盘中输入的一样</span></span><br></pre></td></tr></table></figure><p>注意：shell在赋值过程中，变量名、等号和变量值之间<strong>必须没有空格</strong></p><ul><li>shell函数的两种语法形式</li></ul><blockquote><p>为使函数调用被识别出是 shell函数而不是被解释为外部程序的名字，在脚本中 shell 函数的定义必须出现在函数调用之前</p><p>在变量名之前加上单词 local，来定义局部变量</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name为函数名 commands为命令</span></span><br><span class="line"><span class="keyword">function</span> name &#123;</span><br><span class="line">    commands</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="title">name</span></span> () &#123;</span><br><span class="line">    commands</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if分支结构</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>当命令执行完毕后，命令（包括我们编写的脚本和 shell 函数）会给系统发送一个值，叫做退出状态。这个值是一个 0 到 255 之间的整数，说明命令执行成功或是失败。按照惯例，一个零值说明成功，其它所有值说明失败。Shell 提供了一个参数<code>$?</code>，我们可以用它检查退出状态</p><p>如果 if 之后跟随一系列命令，则将计算列表中的最后一个命令，到目前为止，经常与 if 一块使用的命令是 test。这个 test 命令执行各种各样的检查与比较。它有如下两种等价模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> expression</span><br><span class="line">---</span><br><span class="line">[ expression ]<span class="comment"># 更为流行</span></span><br></pre></td></tr></table></figure><p>这里的 expression 是一个表达式，其执行结果是 true 或者是 false。当表达式为真时，这个test 命令返回一个零退出状态，当表达式为假时，test 命令退出状态为 1；当与 test 一块使用的时候，&gt; 和 &lt; 表达式操作符必须用引号引起来（或者是用反斜杠转义）。如果不这样，它们会被 shell 解释为重定向操作符，造成潜在的破坏结果</p><p>计算文件状态的文件表达式，详细请参见《Linux命令行大全》P387</p><p>计算字符串表达式，详细请参见《Linux命令行大全》P390</p><p>计算整型表达式，详细请参见《Linux命令行大全》P391</p></blockquote><ul><li>操作控制符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br><span class="line">command2 || command2</span><br></pre></td></tr></table></figure><p>对于 &amp;&amp; 操作符，先执行 command1，并且只有 command1执行成功后，才会执行 command2</p><p>对于 || 操作符，先执行 command1，并且只有command1 执行失败后，才会执行 command2</p><ul><li>读取键盘输入</li></ul><blockquote><p>read: 从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，读取文件中的一行数据，详细选项参数请参加《Linux命令行大全》P403</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [-options] [variable...]</span><br></pre></td></tr></table></figure><ul><li>while/until循环</li></ul><blockquote><p>和 if 一样，while 计算一系列命令的退出状态。只要退出状态为零，它就执行循环内的命令；而 until 循环会继续执行直到它接受了一个退出状态零</p><p><strong>跳出循环</strong>：</p><p>break 命令立即终止一个循环，且程序继续执行循环之后的语句</p><p>continue 命令导致程序跳过循环中剩余的语句，且程序继续执行下一次循环</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while命令语法</span></span><br><span class="line"><span class="keyword">while</span> commands; <span class="keyword">do</span> commands; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>case分支</li></ul><blockquote><p>早于 4.0的 bash，对于 case 语法绝不能匹配多个测试条件。现在的 bash 版本，添加“;;&amp;”表达式来终止每个行动，其允许 case 语句继续执行下一条测试，而不是简单地终止运行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> word <span class="keyword">in</span></span><br><span class="line">[pattern [| pattern]...) commands ;;]...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ul><li>for循环</li></ul><blockquote><p>传统shell格式的for循环中，variable 是一个变量的名字，这个变量在循环执行期间会增加，words 是一个可选的条目列表，其值会按顺序赋值给 variable，commands 是在每次循环迭代中要执行的命令</p><p>C语言格式的for循环中，expression1 用来初始化循环条件，expression2 用来决定循环结束的时间，还有在每次循环迭代的末尾会执行 expression3</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统shell格式</span></span><br><span class="line"><span class="keyword">for</span> variable [<span class="keyword">in</span> words]; <span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">---</span><br><span class="line"><span class="comment"># C语言格式(最新版本bash)</span></span><br><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )); <span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="17-位置参数"><a href="#17-位置参数" class="headerlink" title="17.位置参数"></a>17.位置参数</h3><ul><li>命令行访问</li></ul><blockquote><p>shell 提供了一个称为位置参数的变量集合，这个集合包含了命令行中所有独立的单词。这些变量按照从 0 到 9 给予命名，实际上通过参数展开方式你可以访问的参数个数多于 9 个。只要指定一个大于 9 的数字，用花括号把该数字括起来就可以。例如 <code>$&#123;10&#125;、$&#123;55&#125;、$&#123;211&#125;</code>等等</p><p>确定命令行参数个数：<code>$#</code></p><p>访问多个命令行参数：<code>shift</code>，执行一次 shift 命令，就会导致所有的位置参数“向下移动一个位置”。事实上，用 shift 命令也可以处理只有一个参数的情况（除了其值永远不会改变的变量 $0）</p></blockquote><h3 id="18-字符串和数字"><a href="#18-字符串和数字" class="headerlink" title="18.字符串和数字"></a>18.字符串和数字</h3><ul><li>管理空变量的展开</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;parameter:-word&#125;</span>(若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。若 parameter不为空，则展开结果是 parameter 的值)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter:=word&#125;</span>(若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值并且word的值会赋值给parameter。若 parameter不为空，则展开结果是 parameter 的值)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter:?word&#125;</span>(若 parameter 没有设置（例如，不存在）或者为空，展开会导致脚本带有错误退出且word的内容会发送到标准错误。若 parameter不为空，则展开结果是 parameter 的值)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter:+word&#125;</span>(若 parameter 没有设置（例如，不存在）或者为空，展开结果为空。若 parameter不为空，则展开结果会用word的值替换掉 parameter 的值但parameter的值本身不会改变)</span><br></pre></td></tr></table></figure><ul><li>返回变量名的参数展开</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;!prefix*&#125;</span></span><br><span class="line"><span class="variable">$&#123;!prefix@&#125;</span></span><br><span class="line"><span class="comment"># 这种展开会返回以 prefix 开头的已有变量名</span></span><br></pre></td></tr></table></figure><ul><li>字符串展开</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#parameter&#125;</span> 展开成由 parameter 所包含的字符串的长度，通常，parameter 是一个字符串；然而，如果</span><br><span class="line">parameter 是 @ 或者是 * 的话，则展开结果是位置参数的个数</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter:offset&#125;</span></span><br><span class="line"><span class="variable">$&#123;parameter:offset:length&#125;</span></span><br><span class="line">上面两个展开用来从 parameter 所包含的字符串中提取一部分字符。提取的字符始于第 offset个字符（从字符串开头算起）直到字符串的末尾，除非指定提取的长度；若 offset 的值为负数，则认为 offset 值是从字符串的末尾开始算起，而不是从开头。注意负数前面必须有一个空格，为防止与 <span class="variable">$&#123;parameter:-word&#125;</span> 展开形式混淆。length，若出现，则必须不能小于零。如果 parameter 是 @，展开结果是 length 个位置参数，从第 offset 个位置参数开始</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter#pattern&#125;</span></span><br><span class="line"><span class="variable">$&#123;parameter##pattern&#125;</span></span><br><span class="line">这些展开会从 paramter 所包含的字符串中清除开头一部分文本，这些字符要匹配定义的pattern。pattern 是通配符模式，就如那些用在路径名展开中的模式。这两种形式的差异之处是该 <span class="string">&#x27;#&#x27;</span> 形式清除最短的匹配结果，而该 <span class="string">&#x27;##&#x27;</span> 模式清除最长的匹配结果(贪心和非贪心匹配)</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter%pattern&#125;</span></span><br><span class="line"><span class="variable">$&#123;parameter%%pattern&#125;</span></span><br><span class="line">这些展开和上面的 <span class="string">&#x27;#&#x27;</span> 和 <span class="string">&#x27;##&#x27;</span> 展开一样，除了它们清除的文本从 parameter 所包含字符串的末尾开始，而不是开头</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter/pattern/string&#125;</span></span><br><span class="line"><span class="variable">$&#123;parameter//pattern/string&#125;</span></span><br><span class="line"><span class="variable">$&#123;parameter/#pattern/string&#125;</span></span><br><span class="line"><span class="variable">$&#123;parameter/%pattern/string&#125;</span></span><br><span class="line">这种形式的展开对 parameter 的内容执行查找和替换操作。如果找到了匹配通配符 pattern的文本，则string 的内容替换它。在正常形式下，只有第一个匹配项会被替换掉。在该 //形式下，所有的匹配项都会被替换掉。该 <span class="string">&#x27;/#&#x27;</span> 要求匹配项出现在字符串的开头，而 /% 要求匹配项出现在字符串的末尾。/string 可能会省略掉，这样会导致删除匹配的文本</span><br><span class="line"></span><br><span class="line">大小写参数转换，详细请参见《Linux命令行大全》P468</span><br><span class="line"></span><br><span class="line">数基，详情参见《Linux命令行大全》P469</span><br></pre></td></tr></table></figure><blockquote><p> shell 算术只操作整型，所以除法运算的结果总是整数</p><p>常用赋值运算符及位运算符请参见《Linux命令行大全》P472~P473</p></blockquote><ul><li>bc 一种高精度计算器语言</li></ul><h3 id="19-数组"><a href="#19-数组" class="headerlink" title="19.数组"></a>19.数组</h3><ul><li>创建数组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ a[1]=abc <span class="comment"># 访问时自动创建</span></span><br><span class="line">$ <span class="built_in">declare</span> -a abc <span class="comment"># 创建数组abc(使用 -a 选项，declare 命令可以创建数组 abc)</span></span><br><span class="line"><span class="comment"># 数组第一个元素的下标是 0，而不是 1</span></span><br></pre></td></tr></table></figure><ul><li>数组赋值</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ name[subscript]=value<span class="comment"># 单个数组元素赋值</span></span><br><span class="line">$ name=(value1 value2 ...)<span class="comment"># 多个值赋值</span></span><br><span class="line">$ name=([num1]=value1 [num2]=value2 [num3]=value3 ...)<span class="comment"># 指定下标把值赋给数组中的特定元素</span></span><br></pre></td></tr></table></figure><blockquote><p>输出整个数组的内容：下标 * 和 @ 可以被用来访问数组中的每一个元素。与位置参数一样，@ 表示法在两者之中更有用处</p><p>使用参数展开，我们能够确定数组元素的个数，与计算字符串长度的方式几乎相同；任何没有下标的对数组变量的引用都指向数组元素 0即第一个数组元素</p><p>其他数组操作请详见《Linux命令行大全》P486</p></blockquote><ul><li>组命令和子shell (将命令组合在一起，用来管理重定向)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 组命令</span></span><br><span class="line">&#123; command1; command2; [command3; ...] &#125;</span><br><span class="line"><span class="comment"># 子shell</span></span><br><span class="line">(command1; command2; [command3; ...])</span><br><span class="line"><span class="comment"># 这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell 用括号。值得注意的是，鉴于 bash 实现组命令的方式，花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止</span></span><br></pre></td></tr></table></figure><blockquote><p>一个组命令在当前 shell 中执行它的所有命令，而一个子 shell（顾名思义）在当前 shell 的一个子副本中执行它的命令。这意味着运行环境被复制给了一个新的shell 实例。当这个子 shell 退出时，环境副本会消失，所以在子 shell 环境（包括变量赋值）中的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell，组命令比子 shell更受欢迎。组命令运行很快并且占用的内存也少</p></blockquote><ul><li>进程替换</li></ul><blockquote><p>管道线中的命令总是在子 shell 中执行，任何给变量赋值的命令都会遭遇这样的问题(子shell的任何变量赋值都不能传递给当前shell)。幸运地是，shell 提供了一种奇异的展开方式，叫做进程替换，它可以用来解决这种麻烦</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用于产生标准输出的进程</span></span><br><span class="line">&lt;(list)</span><br><span class="line"><span class="comment"># 适用于接收标准输入的进程</span></span><br><span class="line">&gt;(list)</span><br><span class="line"><span class="comment"># list为命令列表</span></span><br></pre></td></tr></table></figure><ul><li>陷阱(当脚本接收到该程序即将提前终止的信号，此时让脚本执行如删除创建的临时文件等代码)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> argument signal [signal...]</span><br><span class="line"><span class="comment"># 这里的 argument 是一个字符串，它被读取并被当作一个命令，signal 是一个信号的说明，它会触发执行所要解释的命令</span></span><br></pre></td></tr></table></figure><ul><li><p>异步执行(wait命令导致一个父脚本暂停运行直到特定进程运行结束)</p></li><li><p>命名管道</p></li></ul><blockquote><p>当在管道的另一端没有任何对象来接收数据时相关命令会挂起，这种现象被称为管道阻塞。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，管道阻塞则会结束</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++之socket编程</title>
      <link href="/2023/07/10/C-C-%E4%B9%8Bsocket%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/07/10/C-C-%E4%B9%8Bsocket%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章：</p><p>1.<a href="https://blog.csdn.net/m0_52169086/article/details/125687577?spm=1001.2014.3001.5506">socket编程基础知识</a></p><p>2.<a href="https://blog.csdn.net/m0_52169086/article/details/125691474?spm=1001.2014.3001.5506">socket编程UDP程序</a></p><p>3.<a href="https://blog.csdn.net/m0_52169086/article/details/125698902?spm=1001.2014.3001.5506">socket编程TCP程序</a></p><p>4.<a href="https://juejin.cn/s/unix%20domain%20socket%20%E7%BC%96%E7%A8%8B">unix domain socket 编程</a></p><p>5.<a href="https://github.com/linalalala/linux/blob/master/socket_unix.md">Unix Domain Socket 实现原理</a></p><p>6.<a href="https://zhuanlan.zhihu.com/p/131402832">Linux C Socket UDP编程详解及实例分享</a></p><p>7.<a href="https://www.cnblogs.com/skyfsm/p/6287787.html">Linux编程之UDP SOCKET全攻略</a></p><p>8.<a href="https://www.cnblogs.com/liang-hk/archive/2012/04/28/2475199.html">udp 超时设置（select函数的一种用法）</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>socket</code>通信本质上就是两个进程间的通信(<strong>跨网络的进程间通信</strong>)</p></li><li><p><code>IP</code>地址能够唯一标识公网内的一台主机，而端口号能够唯一标识一台主机上的一个进程，因此<code>IP</code>地址+端口号就能够唯一标识网络上的某一台主机的某一个进程</p></li><li><p>或者这样说：<code>IP</code>地址就像是某个快递点的位置，端口号就是其中快递包裹的编号，而进程是收或寄快递的人</p></li><li><p><code>TCP</code>协议：面向连接、可靠、基于字节流的传输层通信协议</p></li><li><code>UDP</code>协议：无需建立连接的、不可靠的、面向数据报的传输层通信协议</li><li>计算机存储策略：<ul><li>大端模式：数据高字节保存到内存低字节，数据低字节保存到内存高字节(大对小，小对大/==低地址高字节==) -&gt; 网络数据流采用<strong>大端模式</strong></li><li>小端模式：数据高字节保存到内存高字节，数据低字节保存到内存低字节(大对大，小对小/==低地址低字节==)</li></ul></li><li>网络字节序和主机字节序之间的转换函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;<span class="comment">//主机字节序转换为网络字节序 32位</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;<span class="comment">//主机字节序转换为网络字节序 16位</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;<span class="comment">//网络字节序转换为主机字节序 32位</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;<span class="comment">//网络字节序转换为主机字节序 16位</span></span><br><span class="line"><span class="comment">// h: hostn: network</span></span><br></pre></td></tr></table></figure><ul><li><code>sockaddr</code>结构(跨网络通信：<code>sockaddr_in</code>和本地通信：<code>sockaddr_un</code>)：统一套接字的网络通信和本地通信，使之能使用同一套函数；设置参数时通过设置协议家族(<code>16</code>位地址类型)这个字段，来表明我们是要进行网络通信还是本地通信；实际进行网络通信时，定义的还是<code>sockaddr_in</code>结构体，在传参时将该结构体的地址类型强制转换为<code>sockaddr*</code> </li><li><code>UDP</code>通信流程框架图<ul><li><code>server</code>(服务器)接收请求步骤：<code>socket()-&gt;bind()-&gt;recvfrom()</code></li><li><code>client</code>(客户端)发送请求步骤：<code>socket()-&gt;sendto()</code></li><li>实际上<code>UDP</code>没有严格区分<code>server</code>端和<code>client</code>端，唯一的区别是绑不绑定（<code>bind</code>）端口</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/1093303-20170115195937619-2089905370.jpg" alt="1093303-20170115195937619-2089905370"></p><h1 id="套接字相关函数"><a href="#套接字相关函数" class="headerlink" title="套接字相关函数"></a>套接字相关函数</h1><h3 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket()"></a>1.socket()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">作用: 建立套接字文件描述符</span><br><span class="line">参数:</span><br><span class="line">(1) domain(以下列出常用网络通信域)</span><br><span class="line">AF_INET: 常用协议，使用TCP或UDP传输(用于IPV4)</span><br><span class="line">AF_INET6: 同上，区别在于是用于IPV6</span><br><span class="line">AF_UNIX: 本地协议，用于Unix和LInux系统(是同一台主机内进程间通信的机制，使用文件系统路径名作为地址来建立连接，比传统的网络Socket更加高效)</span><br><span class="line">(2) type</span><br><span class="line">SOCK_STREAM: TCP传输</span><br><span class="line">SOCK_DGRAM: UDP传输</span><br><span class="line">SOCK_RAW: 原始网络访问</span><br><span class="line">(3) protocol</span><br><span class="line">传0即可，使用默认协议</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回指向新创建的socket的文件描述符</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="2-bind"><a href="#2-bind" class="headerlink" title="2.bind()"></a>2.bind()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">作用: 将套接字文件描述符和一个地址类型变量进行绑定</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">socket文件描述符(监听端口的套接字文件描述符)，即调用socket()函数返回的文件描述符</span><br><span class="line">(2) addr</span><br><span class="line">与网络相关的属性信息，包括协议家族、ip地址和端口号等(需要绑定的ip和端口)</span><br><span class="line">(3) addrlen</span><br><span class="line">addr结构体的长度</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回0</span><br><span class="line">失败: 返回-1，设置errno</span><br><span class="line">备注:</span><br><span class="line">使用socket()创建完套接字后只是在系统层面打开了一个文件，但并没有将该文件与网络关联起来，需要调用bind()进行文件和网络的绑定和关联</span><br><span class="line">服务器需要绑定监听的网络地址和端口号，而客服端不需要</span><br><span class="line">INADDR_ANY表示绑定</span><br></pre></td></tr></table></figure><h3 id="3-recvfrom"><a href="#3-recvfrom" class="headerlink" title="3.recvfrom()"></a>3.recvfrom()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line">作用: 通过套接字接收数据</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">socket文件描述符(监听端口的套接字文件描述符)，即调用socket()函数返回的文件描述符</span><br><span class="line">(2) buf</span><br><span class="line">接收的数据存放的缓冲区</span><br><span class="line">(3) len</span><br><span class="line">接收数据字节数</span><br><span class="line">(4) flags</span><br><span class="line">接收方式，一般设置为0，表示阻塞接收</span><br><span class="line">(5) src_addr</span><br><span class="line">与对端网络相关的属性信息，包括协议家族、ip地址和端口号等</span><br><span class="line">指向发送数据的主机地址信息的结构体，即可以从该参数获取到数据是谁发出的</span><br><span class="line">(6) addrlen</span><br><span class="line">src_addr结构体长度</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回实际接收的字节数</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="4-sendto"><a href="#4-sendto" class="headerlink" title="4.sendto()"></a>4.sendto()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">作用: 通过套接字发送数据</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">socket文件描述符(监听端口的套接字文件描述符)，即调用socket()函数返回的文件描述符</span><br><span class="line">(2) buf</span><br><span class="line">待发送数据存放的缓冲区</span><br><span class="line">(3) len</span><br><span class="line">待发送数据字节数</span><br><span class="line">(4) flags</span><br><span class="line">发送方式，一般设置为0，表示阻塞发送</span><br><span class="line">(5) dest_addr</span><br><span class="line">与对端网络相关的属性信息，包括协议家族、ip地址和端口号等</span><br><span class="line">指向接收数据的主机地址信息的结构体，即指定数据要发送到哪个主机的哪个进程</span><br><span class="line">(6) addrlen</span><br><span class="line">dest_addr结构体长度</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回实际发送的字节数</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="5-close"><a href="#5-close" class="headerlink" title="5.close()"></a>5.close()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line">int close(int fd);</span><br><span class="line">作用: 关闭创建的socket</span><br><span class="line">参数:</span><br><span class="line">fd</span><br><span class="line">socket()函数返回的fd</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回0</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="6-inet-addr-inet-ntoa"><a href="#6-inet-addr-inet-ntoa" class="headerlink" title="6.inet_addr()/inet_ntoa()"></a>6.inet_addr()/inet_ntoa()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">函数原型:</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">类似于inet_aton()函数</span><br><span class="line">参数:</span><br><span class="line">cp: 待转换字符串ip</span><br><span class="line">返回值:</span><br><span class="line">转换后的整数ip</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line">char *inet_ntoa(struct in_addr in);</span><br><span class="line">参数:</span><br><span class="line">in: 待转换整数ip</span><br><span class="line">返回值:</span><br><span class="line">转换后的字符串ip</span><br></pre></td></tr></table></figure><h3 id="7-connect"><a href="#7-connect" class="headerlink" title="7.connect()"></a>7.connect()</h3><blockquote><p><code>udp</code>套接字也可以使用，因而<code>udp</code>套接字可以分为已连接的<code>udp</code>套接字和未连接的<code>udp</code>套接字</p><p>已连接的<code>udp</code>套接字，必须先经过<code>connect()</code>来向目标服务器进行指定，然后调用<code>read/write</code>进行信息的收发，目标主机的<code>IP</code>和端口是在<code>connect()</code>时确定的，也就是说，一旦<code>conenct()</code>成功，我们就只能收发该主机的信息</p><p>当知道目的地址和端口时，采用连接的<code>udp</code>套接字效率更高</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/1093303-20170115202743119-1345209901.jpg" alt="1093303-20170115202743119-1345209901"></p><p>参考: <a href="https://blog.csdn.net/m0_52169086/article/details/125698902?spm=1001.2014.3001.5506">socket编程TCP程序</a></p><p><a href="https://www.geeksforgeeks.org/socket-programming-cc/">Socket Programming in C/C++</a></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/StatediagramforserverandclientmodelofSocketdrawio2-448x660.png" alt="StatediagramforserverandclientmodelofSocketdrawio2-448x660"></p><h3 id="1-listen"><a href="#1-listen" class="headerlink" title="1.listen()"></a>1.listen()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数原型:</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">作用: It puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection.</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">需要监听套接字对应的文件描述符</span><br><span class="line">(2) backlog</span><br><span class="line">全连接队列的最大长度。如果有多个客户端同时发来连接请求，此时未被服务器处理的连接就会放入连接队列(超出的连接请求会被忽略)，该参数代表的就是这个全连接队列的最大长度，一般不要设置太大，设置为5或10即可</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回0</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="2-accept"><a href="#2-accept" class="headerlink" title="2.accept()"></a>2.accept()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">函数原型:</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">作用: It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. At this point, the connection is established between client and server, and they are ready to transfer data.</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">需要监听套接字对应的文件描述符(监听套接字)</span><br><span class="line">(2) addr</span><br><span class="line">对端网络相关属性信息，包括协议家族、ip和端口等</span><br><span class="line">(3) addrlen</span><br><span class="line">addr结构体长度，返回实际读取到的addr结构体长度(输入输出型参数)</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回一个新的socket文件描述符(服务套接字)，用于和客户端通信</span><br><span class="line">失败: 返回-1，设置errno</span><br><span class="line">1.监听套接字：用于获取客户端发来的连接请求。accept函数会不断从监听套接字当中获取新连接。</span><br><span class="line">2.accept函数返回的套接字：用于为本次accept获取到的连接提供服务。监听套接字的任务只是不断获取新连接，而真正为这些连接提供服务的套接字是accept函数返回的套接字</span><br></pre></td></tr></table></figure><h3 id="3-connect"><a href="#3-connect" class="headerlink" title="3.connect()"></a>3.connect()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数原型:</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">作用:  The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. Server&#x27;s address and port is specified in addr.</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">需要连接套接字对应的文件描述符(通过该套接字发起连接请求)</span><br><span class="line">(2) addr</span><br><span class="line">对端网络相关属性信息，包括协议家族、ip和端口等</span><br><span class="line">(3) addrlen</span><br><span class="line">addr结构体长度</span><br><span class="line">返回值:</span><br><span class="line">成功: 连接成功</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="4-read"><a href="#4-read" class="headerlink" title="4.read()"></a>4.read()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数原型:</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">作用: 从连接的套接字中读取数据</span><br><span class="line">参数:</span><br><span class="line">(1) fd</span><br><span class="line">对应套接字的文件描述符</span><br><span class="line">(2) buf</span><br><span class="line">读取到的数据存储位置</span><br><span class="line">(3) count</span><br><span class="line">读取数据字节数</span><br><span class="line">返回值:</span><br><span class="line">成功: 实际读取的字节数</span><br><span class="line">失败: 返回0(文件结束/对端关闭连接)或-1(读取错误)，设置errno</span><br></pre></td></tr></table></figure><h3 id="5-write"><a href="#5-write" class="headerlink" title="5.write()"></a>5.write()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数原型:</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">作用: 从连接的套接字中读取数据</span><br><span class="line">参数:</span><br><span class="line">(1) fd</span><br><span class="line">对应套接字的文件描述符</span><br><span class="line">(2) buf</span><br><span class="line">需要写入数据的位置</span><br><span class="line">(3) count</span><br><span class="line">写入数据字节数</span><br><span class="line">返回值:</span><br><span class="line">成功: 实际写入的字节数</span><br><span class="line">失败: 返回-1，设置errno</span><br></pre></td></tr></table></figure><h3 id="6-setsockopt"><a href="#6-setsockopt" class="headerlink" title="6.setsockopt()"></a>6.setsockopt()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">函数原型:</span><br><span class="line">int setsockopt(int sockfd, int level, int optname,  const void *optval, socklen_t optlen);</span><br><span class="line">作用:</span><br><span class="line">This helps in manipulating options for the socket referred by the file descriptor sockfd. This is completely optional, but it helps in reuse of address and port. Prevents error such as: &quot;address already in use&quot;</span><br><span class="line">参数:</span><br><span class="line">(1) sockfd</span><br><span class="line">套接字描述符</span><br><span class="line">(2) level</span><br><span class="line">设置选项的级别，如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET</span><br><span class="line">(3) optname</span><br><span class="line">需要设置的选项</span><br><span class="line">(4) optval</span><br><span class="line">指向存放选项值的缓冲区</span><br><span class="line">(5) optlen</span><br><span class="line">optval 缓冲区的长度</span><br><span class="line">返回值:</span><br><span class="line">成功: 返回0</span><br><span class="line">失败: 返回-1, 设置errno</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/cthon/p/9270778.html">setsockopt函数功能及参数详解</a></p><ul><li>阻塞接收时避免永久阻塞</li></ul><p>传统的recvfrom是阻塞进行的，即调用recvfrom之后程序就会阻塞，等待数据包的到来，如果没有数据包，程序就永远等待</p><p>解决方法：给客户端调用的<code>recvfrom()</code>函数设置超时处理，超时之后没有接收到数据就直接返回</p><p>（1）select()函数+recvfrom()函数</p><p>对于select()函数，可参考: <a href="https://www.cnblogs.com/wuyepeng/p/9745573.html">select函数及fd_set介绍</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buf_n=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;readfds);<span class="comment">// 清空</span></span><br><span class="line">        <span class="built_in">FD_SET</span>(fd,&amp;readfds);<span class="comment">// 置位fd，将需要处理的sock加入到上一步清空后的集合中</span></span><br><span class="line">        <span class="comment">// 设置超时参数 sec和usec</span></span><br><span class="line">        tv.tv_sec=sec;</span><br><span class="line">        tv.tv_usec=usec;</span><br><span class="line">        <span class="comment">// 以非阻塞方式调用select()函数，设置时间内有数据则返回并设置readfds中fd对应位为1，否则返回并设置readfds中对应位为0</span></span><br><span class="line">        <span class="built_in">select</span>(fd+<span class="number">1</span>,&amp;readfds,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;tv);</span><br><span class="line">        <span class="comment">// 测试readfds中fd对应位有没有置1，如果置1则返回成功，否则返回失败</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fd,&amp;readfds))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n=<span class="built_in">recvfrom</span>(fd,buf,buf_n,<span class="number">0</span>,&amp;addr,&amp;len))&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 成功接收处理代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 超时处理代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>如果设定时间内没有数据到来还想继续等待N次，那么一定要注意重新设置readfds，因为它已经被select破坏了，如果不重新设置的话，你的select语句会返回-1，strerr时会打印出参数设置出错，主要是由于readfds中全部为零，select不知道该去监视哪个sock</p></li><li><p>重复等待时不只是要重新设置readfds，同时还要重新设置一下tv的值，因为select同时也破坏了tv的值（select在返回时会改变tv，改变的公式是tv=tv-等待的时间，所以如果tv时间内没有数据到达的话，select返回时tv会变成0）</p></li></ul><p>（2）<a href="https://blog.csdn.net/daiyudong2020/article/details/70039409">UDP服务recvfrom函数设置非阻塞</a></p><p>（3）<a href="https://zhuanlan.zhihu.com/p/612347070">Linux Socket 网络编程 阻塞与非阻塞 断线重连机制</a></p><p>（4）使用信号中断处理超时</p><h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><blockquote><p>Linux系统下关于使用socket进行UDP和TCP通信的代码已放到如下链接中：</p><p><a href="https://github.com/Thee24LYJ/LearningCode/tree/main/tcp%26udp%20socket%20code">https://github.com/Thee24LYJ/LearningCode/tree/main/tcp%26udp%20socket%20code</a></p><p>该文件夹下子文件夹对应的代码解释如下：</p><ul><li>udp_test -&gt; udp通信</li><li>tcp_test -&gt; tcp通信</li><li>tcp_test_SIGCHLD -&gt; tcp通信(多进程之捕捉SIGCHLD信号)</li><li>tcp_test_son -&gt; tcp通信(多进程之孙子进程)</li><li>tcp_test_thread -&gt; tcp通信(多线程)</li><li>tcp_test_threadpool -&gt; tcp通信(线程池)</li></ul></blockquote><h2 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h2><ul><li>本地不同进程间进行通信：<a href="https://juejin.cn/s/unix%20domain%20socket%20%E7%BC%96%E7%A8%8B">unix domain socket 编程</a></li></ul><h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><blockquote><p>单进程版本：一个server同一时刻只能响应一个client的请求</p><p>多进程的tcp示例</p><ul><li><p>子进程继承父进程的文件描述符表: 即父进程打开的文件描述符是3，此时父进程创建的子进程的3号文件描述符也会指向这个打开的文件，而如果子进程再创建一个子进程，那么子进程创建的子进程的3号文件描述符也同样会指向这个打开的文件</p></li><li><p>子进程等待: 父进程创建子进程后，需要等待子进程退出(否则子进程会变成僵尸进程)</p><p>  阻塞等待/非阻塞等待</p><p>  不等待子进程退出: </p><ul><li>捕捉SIGCHLD信号，将其处理动作设置为忽略。</li><li>让祖父进程创建父进程，父进程再创建孙子进程，最后让孙子进程为客户端提供服务(孙子进程由系统回收)(不推荐)</li></ul></li></ul><p>多线程的tcp示例</p><ul><li>当服务进程调用accept函数获取到一个新连接后，就可以直接创建一个线程，让该线程为对应客户端提供服务。主线程（服务进程）创建出新线程后，也是需要等待新线程退出的，否则也会造成类似于僵尸进程这样的问题。但对于线程来说，如果不想让主线程等待新线程退出，可以让创建出来的新线程调用pthread_detach函数进行线程分离，当这个线程退出时系统会自动回收该线程所对应的资源。此时主线程（服务进程）就可以继续调用accept函数获取新连接，而让新线程去服务对应的客户端。</li><li>文件描述符表维护的是进程与文件之间的对应关系，因此一个进程对应一张文件描述符表。而主线程创建出来的新线程依旧属于这个进程，因此创建线程时并不会为该线程创建独立的文件描述符表，所有的线程看到的都是同一张文件描述符表。</li><li><p>当服务进程（主线程）调用accept函数获取到一个文件描述符后，其他创建的新线程是能够直接访问这个文件描述符的。虽然新线程能够直接访问主线程accept上来的文件描述符，但此时新线程并不知道它所服务的客户端对应的是哪一个文件描述符，因此主线程创建新线程后需要告诉新线程对应应该访问的文件描述符的值，也就是告诉每个新线程在服务客户端时，应该对哪一个套接字进行操作</p></li><li><p>由于代码当中用到了多线程，因此编译时需要携带上 -l pthread 选项。此外，由于我们现在要监测的是一个个的线程，因此在监控时使用的不再是ps -axj 命令，而是 ps -aL 命令。</p></li><li>当一个客户端连接到服务端后，此时主线程就会为该客户端构建一个参数结构体，然后创建一个新线程，将该参数结构体的地址作为参数传递给这个新线程，此时该新线程就能够从这个参数结构体当中提取出对应的参数，然后调用Service函数为该客户端提供服务</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机之静态 arp 绑定</title>
      <link href="/2023/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%9D%99%E6%80%81arp%E7%BB%91%E5%AE%9A/"/>
      <url>/2023/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%9D%99%E6%80%81arp%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/8b3dba40556f">在 Windows 上 arp 绑定</a></li><li><a href="https://www.cnblogs.com/macoffee/p/14116731.html">arp 绑定网关</a></li><li><a href="https://blog.csdn.net/yangshihuz/article/details/103869076">linux arp 的操作解释，永久生效的方法</a></li></ul><p>计算机上设置静态<code>arp</code>的方式不止一种，以下只介绍比较常用的两种方式：</p><ul><li>方式一：<code>arp -s</code>绑定，但是只能实现临时静态<code>arp</code>绑定，系统重启后失效 （绑定静态<code>arp</code>后，使用命令<code>arp -a</code>查看，对应绑定的静态<code>arp</code>会有<code>PERM</code>标识，表示静态<code>arp</code>，即<code>permanent</code>，永久的）</li><li>方式二：<code>netsh</code>绑定，可实现永久<code>arp</code>绑定，系统重启后也不会失效，且能指定网络接口</li></ul></blockquote><h3 id="1-arp-s-方式-windows-和-linux-系统均可使用）"><a href="#1-arp-s-方式-windows-和-linux-系统均可使用）" class="headerlink" title="1. arp -s 方式 (windows 和 linux 系统均可使用）"></a>1. arp -s 方式 (windows 和 linux 系统均可使用）</h3><ul><li><p>查看<code>windows</code>上的<code>arp</code>表</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arp -a</span><br></pre></td></tr></table></figure></li><li><p>绑定静态<code>arp</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arp -s ip mac<span class="comment"># 第一个参数为点十分进制 ip 地址，第二个参数为需要绑定的 mac 地址</span></span><br><span class="line">$ arp -s 192.168.1.81 11-22-33-44-55-66<span class="comment"># 示例</span></span><br></pre></td></tr></table></figure></li><li><p>删除静态绑定</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arp -d ip</span><br><span class="line">$ arp -d 192.168.1.81 <span class="comment"># 示例</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-netsh-方式（仅适用于-windows-系统）"><a href="#2-netsh-方式（仅适用于-windows-系统）" class="headerlink" title="2. netsh 方式（仅适用于 windows 系统）"></a>2. netsh 方式（仅适用于 windows 系统）</h3><ul><li><p>查看计算机网卡对应的索引 (<code>Idx</code>)</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netsh i i show <span class="keyword">in</span></span><br></pre></td></tr></table></figure></li><li><p>绑定静态<code>arp</code>（需要管理员权限）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ netsh -c i i add ne Idx ip mac<span class="comment"># 简写</span></span><br><span class="line">$ netsh -c interface ipv4 add neighbors Idx ip mac</span><br><span class="line">$ netsh -c i i add ne 2 192.168.1.81 11-22-33-44-55-66<span class="comment"># 示例，我这里以太网的 Idx 为 2</span></span><br><span class="line">$ netsh -c i i add ne Idx ip mac store=active <span class="comment"># 临时绑定静态 arp</span></span><br></pre></td></tr></table></figure></li><li><p>删除静态绑定</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netsh -c i i del ne Idx<span class="comment"># 简写</span></span><br><span class="line">$ netsh -c i i delete neighbors Idx</span><br><span class="line">$ netsh -c interface ipv4 delete neighbors <span class="comment"># 删除所有网卡静态绑定的 arp</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 系统设置开机自启脚本方式</title>
      <link href="/2023/06/20/linux%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/06/20/linux%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-系统开机自启动脚本执行"><a href="#linux-系统开机自启动脚本执行" class="headerlink" title="linux 系统开机自启动脚本执行"></a>linux 系统开机自启动脚本执行</h1><blockquote><p>参考：<a href="https://www.baeldung.com/linux/run-script-on-startup">Run a Script on Startup in Linux</a></p></blockquote><h1 id="一、crontab"><a href="#一、crontab" class="headerlink" title="一、crontab"></a>一、crontab</h1><blockquote><p><a href="https://blog.51cto.com/u_15966109/6082825">Linux 定时任务 crontab 实现秒级定时以及@reboot 的一些问题</a></p><p><a href="https://www.cnblogs.com/doseoer/p/5663187.html">如何查看 crontab 的日志记录</a></p><p><a href="https://unix.stackexchange.com/questions/188042/running-a-script-during-booting-startup-init-d-vs-cron-reboot">Running a script during booting/startup; init.d vs cron @reboot</a></p></blockquote><ul><li>使用<code>crontab -e</code>命令编辑 crontab 文件，添加如下内容：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@reboot /bin/bash SCRIPT_PATH</span><br></pre></td></tr></table></figure><p>系统重启后会自动执行脚本</p><ul><li>注意：<ul><li>可能得使用 root 权限才能正常自启动执行</li><li>假如说执行脚本中有重定向到某个文件或终端的情况<ul><li>重定向到文件：可能得需要程序执行完才能看到重定向到文件的内容</li><li>重定向到终端：这得需要执行脚本的时候存在该终端，否则可能会因为打不开终端而导致执行失败</li></ul></li></ul></li><li><p>关于 crontab</p><ul><li>可以执行任何命令或脚本</li><li>任何用户都可以添加，不只局限于 root 用户</li><li>on a Debian system with systemd: cron’s @reboot is executed during <code>multi-user.target</code>. on a Debian system with SysV (not systemd), crontab(5) mention: <em>Please note that startup, as far as @reboot is concerned, is the time when the cron(8) daemon startup. In particular, it may be before some system daemons, or other facilities, were startup. This is due to the boot order sequence of the machine.</em></li></ul></li><li><p>crontab 日志记录</p><p>  文件位置：<code>/var/log/cron.log</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">tail</span> -f /var/log/cron.log<span class="comment"># 查看日志信息</span></span><br><span class="line"><span class="comment"># 注意：有可能会出现没有这个日志文件的情况，我这里就没有这个文件</span></span><br></pre></td></tr></table></figure><p>  另一种方法：</p><p>  文件目录位置：<code>/var/spool/mail/</code>，其中存放着不同用户的 crontab 执行的日志情况</p><p>  使用<code>tail -f /var/spool/mail/root</code> 即可查看 root 用户最近的 crontab 执行情况，其他用户同理</p></li></ul><h1 id="二、rc-local"><a href="#二、rc-local" class="headerlink" title="二、rc.local"></a>二、rc.local</h1><blockquote><p>参考文章：</p><ul><li><p><a href="https://blog.csdn.net/kk3909/article/details/105025144">利用 rc.local 开机自启动程序</a></p></li><li><p><a href="https://www.cnblogs.com/wucongzhou/p/12588682.html">Linux 开机启动程序 rc.local</a></p></li></ul></blockquote><ul><li><p>rc.local 文件</p><blockquote><ul><li>文件位置：<code>/etc/rc.local</code>，在<code>/etc/rc.d/</code>下有它的软连接</li><li>文件原始内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line">#</span><br><span class="line"># It is highly advisable to create own systemd services or udev rules</span><br><span class="line"># to run scripts during boot instead of using this file.</span><br><span class="line">#</span><br><span class="line"># In contrast to previous versions due to parallel execution during boot</span><br><span class="line"># this script will NOT be run after all other services.</span><br><span class="line">#</span><br><span class="line"># Please note that you must run &#x27;chmod +x /etc/rc.d/rc.local&#x27; to ensure</span><br><span class="line"># that this script will be executed during boot.</span><br></pre></td></tr></table></figure><p>这里推荐我们使用 systemd 服务或 udev 规则而不是直接使用该文件，虽然不推荐直接使用，但是我们也是可以使用的，不过它的缺点是引导期间并行</p></blockquote></li><li><p>配置 rc.local 文件</p><blockquote><p>正常情况下，rc.local 服务应该是开启了的，如果没有开启则使用<code>sudo systemctl enable rc-local</code>打开该服务；除此之外，该文件应该也具有执行权限，若没有则执行<code>sudo chmod +x /etc/rc.local</code>即可</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/date &gt;&gt; /tmp/date1.log# 写入当前时间至 date1.log</span><br><span class="line">/bin/sleep 10# 睡眠 10s</span><br><span class="line">/bin/date &gt;&gt; /tmp/date2.log# 写入当前时间至 date2.log</span><br></pre></td></tr></table></figure><p>  做完以上步骤后，重启系统时将会自动执行上述命令（当然也可以用自定义脚本替代上述命令）</p></li><li><p>查看脚本执行日志（错误信息）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -e -u rc-local.service</span><br><span class="line">$ sudo <span class="built_in">cat</span> /var/log/syslog | grep -i rc.local</span><br></pre></td></tr></table></figure></li><li><p>注意</p><blockquote><p>rc.local 脚本在操作系统启动时只执行一次，执行过程时没有环境变量，需要把命令的完整路径加上才能成功执行</p><p>rc.local 是一个脚本，是按顺序执行的，执行完一个程序后才会执行下一个程序，如果某程序不是后台程序，就应该加&amp;让程序运行在后台，否则 rc.local 会挂起</p><p>在带有 SysV（不是 systemd）的 Debian 系统上：rc.local（几乎）是最后一个启动的服务，但在带有 systemd 的 Debian 系统上：默认情况下 rc.local 在 network.target 之后执行（不是 network-online.target ！）</p><p>该脚本是在系统初始化级别脚本运行之后再执行的，因此可以安全地在里面添加我们想在系统启动之后执行的脚本</p></blockquote></li></ul><h1 id="三、init-d"><a href="#三、init-d" class="headerlink" title="三、init.d"></a>三、init.d</h1><blockquote><p>参考文章：</p><p><a href="https://transformerswsz.github.io/2019/07/01/Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Linux 开机自启动</a></p><p><a href="https://blog.nowcoder.net/n/2b1853a33f2240e481dc7d15a44536f5">Linux 设置开机自启动</a></p><p><a href="https://codeleading.com/article/15821729029/">linux 服务器开机自启动某个脚本程序（可设定启动优先级的高级启动方式）</a></p></blockquote><ul><li><p>关于 init.d</p><ul><li>init.d 也称为 SysV 脚本，用于在系统初始化和关闭期间启动和停止服务（/etc/init.d/ 脚本也可以在启用 systemd 的系统上运行以实现兼容性）</li><li>默认情况下，该脚本在启动和关闭期间执行</li><li>该 init.d 脚本不仅仅是一个简单的脚本，而应该支持启动和停止等</li></ul></li><li><p>（系统环境是 Ubuntu 18.04)<code>/etc/rc#.d</code>目录下都是到 <code>/etc/init.d/</code> 目录的部分脚本的软链接。每个运行级别要执行哪些服务就在相对应的目录下，比如运行级别 5 要启动的服务就都放在 rc5.d 下，但是放在这个 rc5.d 下的都是一些软链接文件，链接到 <code>/etc/init.d/</code> 中相对应的文件，真正干活的是 <code>/etc/init.d/</code> 里的脚本，#代表一个指定的初始化运行级别，范围为 0~6</p></li><li><p>运行级别</p><blockquote><p>0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</p><p>1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆</p><p>2：多用户状态（没有 NFS)</p><p>3：完全的多用户状态（有 NFS)，登陆后进入控制台命令行模式</p><p>4：系统未使用，保留</p><p>5：X11 控制台，登陆后进入图形 GUI 模式</p><p>6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</p></blockquote></li><li><p>在这些目录之下，包含了许多对进程进行控制的脚本。这些脚本要么以 <code>K##</code> 开头，要么以 <code>S##</code> 开头：</p><ul><li>K：kill，系统将终止对应的服务</li><li>S：start，系统将启动对应的服务</li><li><h2 id="：同一运行级别下脚本执行的顺序，数值小的先执行，数值大的后执行。很多时候这些执行顺序是很重要的，比如要启动-Apache-服务，就必须先配置网络接口"><a href="#：同一运行级别下脚本执行的顺序，数值小的先执行，数值大的后执行。很多时候这些执行顺序是很重要的，比如要启动-Apache-服务，就必须先配置网络接口" class="headerlink" title="：同一运行级别下脚本执行的顺序，数值小的先执行，数值大的后执行。很多时候这些执行顺序是很重要的，比如要启动 Apache 服务，就必须先配置网络接口"></a>：同一运行级别下脚本执行的顺序，数值小的先执行，数值大的后执行。很多时候这些执行顺序是很重要的，比如要启动 Apache 服务，就必须先配置网络接口</h2></li></ul></li><li><p>init.d 文件夹下的脚本文件 test 格式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">echo &quot;Starting myscript&quot;</span><br><span class="line"># 执行你的启动代码</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo &quot;Stopping myscript&quot;</span><br><span class="line"># 执行你的停止代码</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: /etc/init.d/myscript &#123;start|stop&#125;&quot;</span><br><span class="line">exit 1</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>  在上述示例中，你需要将<code>start</code>和<code>stop</code>函数中的代码替换为你自己的启动和停止代码。同时，确保修改脚本文件权限，使其可执行</p></li><li><p>在 Ubuntu/debain 里，可以使用 update-rc.d 命令来把示例脚本安装到各个运行等级中（这里需要将对应脚本文件放到<code>/etc/init.d</code>目录下）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-rc.d <span class="built_in">test</span> defaults 99</span><br></pre></td></tr></table></figure><p>  update-rc.d 后面有三个参数，分别是/etc/init.d 下的脚本名字，默认安装方式，运行的优先级。优先级的数字越大，表示越迟运行，这里我们把自己写的服务放在最后运行</p><p>  如果上述代码不能生效，得手动在<code>/etc/rc#.d</code>(#表示对应的运行等级）目录下建立一个软链接，指向<code>/etc/init.d</code>目录下对应的脚本，命名格式是：开头必须大写 S（表示启动服务），后面跟的数字 99，是我们设定的启动序号，即优先级，后面名字无限定</p><p>  如果要卸载随机启动的服务，执行下面命令即可：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-rc.d -f <span class="built_in">test</span> remove</span><br></pre></td></tr></table></figure><p>  现在，当系统启动时，脚本将自动执行。你可以使用<code>sudo service test start</code>来手动启动它，使用<code>sudo service test stop</code>来停止它，使用<code>sudo service test restart</code>来重启它</p></li></ul><h1 id="四、systemd"><a href="#四、systemd" class="headerlink" title="四、systemd"></a>四、systemd</h1><h2 id="4-1-使用-systemd-管理开机自启脚本"><a href="#4-1-使用-systemd-管理开机自启脚本" class="headerlink" title="4.1 使用 systemd 管理开机自启脚本"></a>4.1 使用 systemd 管理开机自启脚本</h2><blockquote><p>参考文章：</p><ul><li><p><a href="https://www.cnblogs.com/Areas/p/13439000.html">Linux Ubuntu 20.04 —添加开机启动（服务/脚本）</a></p></li><li><p><a href="https://cshihong.github.io/2018/10/15/Linux%E4%B8%8Bsystemctl%E5%91%BD%E4%BB%A4%E5%92%8Cservice%E3%80%81chkconfig%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/">Linux 下 systemctl 命令和 service、chkconfig 命令的区别</a></p></li><li><p><a href="https://segmentfault.com/a/1190000038458363">Linux init、service、systemctl 三者区别</a></p></li></ul><p>Systemctl 是一个 systemd 工具，主要负责控制 systemd 系统和服务管理器，systemd 即为 system daemon, 是 linux 下的一种 init 软件</p><p>Systemd 是一个系统管理守护进程、工具和库的集合，用于取代 System V 初始进程。Systemd 的功能是用于集中管理和配置类 UNIX 系统</p><p>在 Ubuntu 18.04 系统中，可以按照以下步骤使用 systemctl 设置开机自启动脚本：</p></blockquote><ol><li><p>创建一个启动脚本文件（例如 <code>startup.sh</code>）并编辑它：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /path/to/startup.sh</span><br></pre></td></tr></table></figure><p> 在脚本文件中添加希望在开机时执行的命令或脚本</p></li><li><p>添加执行权限给脚本文件：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x /path/to/startup.sh</span><br></pre></td></tr></table></figure></li><li><p>创建一个 systemd 服务单元文件（例如 <code>myservice.service</code>）并编辑它：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/systemd/system/myservice.service</span><br></pre></td></tr></table></figure><p> 在服务单元文件中添加以下内容：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=My Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/path/to/startup.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><p> 举例(arp静态绑定):<br> <code>arpfixed.service</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ARP_Fixed Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/project_public/arp_fixed.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><p> <code>/home/project_public/arp_fixed.sh</code>脚本内容：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">sleep</span> 120 <span class="comment"># 延时2min</span></span><br><span class="line"><span class="comment"># 绑定静态arp</span></span><br><span class="line">arp -s 192.168.1.81 90:2b:34:ab:00:01</span><br></pre></td></tr></table></figure></li><li><p>保存并关闭服务单元文件</p></li><li><p>启用服务（设置开机自启动）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> myservice.service</span><br></pre></td></tr></table></figure></li><li><p>重新加载 systemd 配置：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p> 做完以上步骤，当重启系统时，<code>startup.sh</code> 脚本将会自动执行</p><blockquote><ul><li>systemctl 常用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reboot<span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl rescue <span class="comment"># 进入救援模式（单用户状态）</span></span><br><span class="line">$ sudo systemctl start nginx<span class="comment"># 开启 nginx 服务</span></span><br><span class="line">$ sudo systemctl restart nginx<span class="comment"># 重启</span></span><br><span class="line">$ sudo systemctl stop nginx<span class="comment"># 停止</span></span><br><span class="line">$ sudo systemctl reload nginx<span class="comment"># 重新加载</span></span><br><span class="line">$ sudo systemctl status nginx<span class="comment"># 查询状态</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="4-2-查看服务启动日志"><a href="#4-2-查看服务启动日志" class="headerlink" title="4.2 查看服务启动日志"></a>4.2 查看服务启动日志</h2><blockquote><p>参考文章：</p><ul><li><p><a href="https://blog.csdn.net/mikelv01/article/details/108201676?app_version=5.15.6&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22108201676%22%2C%22source%22%3A%22unlogin%22%7D&amp;utm_source=app">查看 systemctl 或 service 启动服务日志</a></p></li><li><p><a href="https://www.cnblogs.com/leigepython/p/10302056.html">journalctl 日志查看方法</a></p></li><li><p><a href="https://www.cnblogs.com/sparkdev/p/8795141.html">linux journalctl 命令</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/105116548#:~:text=Linux%206%E7%A7%8D%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E4%BC%9A%E7%9C%8B%E6%97%A5%E5%BF%97%E4%BC%9A%E8%A2%AB%E9%84%99%E8%A7%86%E7%9A%84%201%201%E3%80%81tail%20%E8%BF%99%E4%B8%AA%E6%98%AF%E6%88%91%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F%20%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%3A%20tail%20%5B%E5%BF%85%E8%A6%81%E5%8F%82%E6%95%B0%5D,less%E5%91%BD%E4%BB%A4%E5%9C%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%97%B6%EF%BC%8C%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%20...%207%20%E4%B8%80%E8%88%AC%E6%9C%AC%E4%BA%BA%E6%9F%A5%E6%97%A5%E5%BF%97%E9%85%8D%E5%90%88%E5%BA%94%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%20...%208%20linux%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E%20">Linux 6 种日志查看方法，不会看日志会被鄙视的</a></p></li></ul><p><code>journalctl</code> 用来查询<code>systemd-journald</code> 服务收集到的日志。<code>systemd-journald</code> 服务是 <code>systemd init</code> 系统提供的收集系统日志的服务</p></blockquote><ul><li><code>journalctl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u 服务名</span><br></pre></td></tr></table></figure><ul><li>系统日志</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /var/log/message</span><br><span class="line">$ <span class="built_in">cat</span> /var/log/syslog</span><br></pre></td></tr></table></figure><ul><li><code>linux</code>常用日志文件</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/var/log/message 系统启动后的信息和错误日志，是 Red Hat Linux 中最常用的日志之一</span><br><span class="line">/var/log/syslog系统启动日志，Ubuntu 系统</span><br><span class="line">/var/log/secure 与安全相关的日志信息</span><br><span class="line">/var/log/maillog 与邮件相关的日志信息</span><br><span class="line">/var/log/cron 与定时任务相关的日志信息</span><br><span class="line">/var/log/spooler 与 UUCP 和 news 设备相关的日志信息</span><br><span class="line">/var/log/boot.log 守护进程启动和停止相关的日志消息</span><br><span class="line">/var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZYNQ学习笔记</title>
      <link href="/2023/06/15/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/15/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ZYNQ开发板和电脑网络连接"><a href="#ZYNQ开发板和电脑网络连接" class="headerlink" title="ZYNQ开发板和电脑网络连接"></a>ZYNQ开发板和电脑网络连接</h1><blockquote><p>注：这里是不使用路由器而只采用ZYNQ开发板、电脑和虚拟机的网络连接记录</p></blockquote><h3 id="1-ZYNQ开发板和电脑以太网连接"><a href="#1-ZYNQ开发板和电脑以太网连接" class="headerlink" title="1.ZYNQ开发板和电脑以太网连接"></a>1.ZYNQ开发板和电脑以太网连接</h3><ul><li>开发板使用网线连接电脑以太网后，给电脑以太网口手动配置<code>ip</code>为<code>192.168.1.100/24</code>，然后在开发板<code>Linux</code>系统上使用命令<code>ifconfig eth0 192.168.1.27</code>将网口<code>0</code>(实际上是<code>ETH1</code>)的<code>ip</code>地址设置为<code>192.168.1.27/24</code>。</li><li>一般这样配置好<code>ip</code>地址后应该能互相<code>ping</code>通，但是可能由于防火墙的问题导致不能<code>ping</code>通，此时就需要关闭<code>windows</code>电脑和开发板的防火墙，然后应该就能<code>ping</code>通了</li></ul><h3 id="2-ZYNQ开发板和虚拟机连接"><a href="#2-ZYNQ开发板和虚拟机连接" class="headerlink" title="2.ZYNQ开发板和虚拟机连接"></a>2.ZYNQ开发板和虚拟机连接</h3><ul><li>如果虚拟机网络配置选择<code>net</code>模式的话，一般是虚拟机能<code>ping</code>通开发板但是开发板或电脑都不能<code>ping</code>通虚拟机</li><li>此时需要修改虚拟机网络配置为桥接模式，并手动配置虚拟机网络<code>ip</code>地址与电脑以太网同一网段，例如<code>192.168.1.30/24</code>，此时应该开发板和虚拟机都能互相<code>ping</code>通</li></ul><p><code>Linux</code>删除路由：<code>sudo route del -net 192.168.1.0 netmask 255.255.255.0</code></p><p><code>linux</code>显示网关：<code>ip route show</code>，<code>`default via</code>字段后面的<code>IP</code>即为网关<code>IP</code></p><p>通过<code>NFS</code>共享运行代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t nfs -o nolock 192.168.1.30:/home/lyj/work /mnt</span><br></pre></td></tr></table></figure><h1 id="Linux下点灯实验"><a href="#Linux下点灯实验" class="headerlink" title="Linux下点灯实验"></a>Linux下点灯实验</h1><blockquote><p>官网驱动用法链接：<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842398/Linux+GPIO+Driver">Linux GPIO Driver</a></p></blockquote><h3 id="1-SHELL控制GPIO来点灯"><a href="#1-SHELL控制GPIO来点灯" class="headerlink" title="1.SHELL控制GPIO来点灯"></a>1.SHELL控制GPIO来点灯</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gpio_test.sh</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">gpio_test</span></span>() &#123;</span><br><span class="line">        gpio=<span class="variable">$1</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$gpio</span> &gt; /sys/class/gpio/export</span><br><span class="line">        <span class="built_in">echo</span> out &gt; /sys/class/gpio/gpio<span class="variable">$&#123;gpio&#125;</span>/direction</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 3)</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> 0 &gt;/sys/class/gpio/gpio<span class="variable">$&#123;gpio&#125;</span>/value</span><br><span class="line">                <span class="built_in">sleep</span> 1</span><br><span class="line">                <span class="built_in">echo</span> 1 &gt;/sys/class/gpio/gpio<span class="variable">$&#123;gpio&#125;</span>/value</span><br><span class="line">                <span class="built_in">sleep</span> 1</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$gpio</span> &gt; /sys/class/gpio/unexport</span><br><span class="line">&#125;</span><br><span class="line">gpio_test 900</span><br><span class="line">gpio_test 1019</span><br></pre></td></tr></table></figure><ul><li>这里点亮两个<code>LED</code>灯，<code>900</code>对应的是核心板上的<code>LED1</code>，<code>1019</code>对应扩展板上的<code>PL_LED1</code></li><li>代码理解(对于<code>gpio_test 900</code>来说)：<ul><li>配置<code>GPIO</code>：首先将<code>900</code>赋值给<code>gpio</code>，然后<code>echo $gpio &gt; /sys/class/gpio/export</code>来生成该端口的输入输出设置等配置文件</li><li>设置<code>GPIO</code>输入还是输出：<code>out</code>表示输出，<code>in</code>表示输入</li><li>设置<code>GPIO</code>输出电平：循环点亮和熄灭三次<code>LED</code>即向该<code>GPIO</code>端口输出对应的电平，<code>1</code>表示输出高电平，<code>0</code>表示输出低电平</li><li>关闭<code>GPIO</code>：<code>echo $gpio &gt; /sys/class/gpio/unexport</code>，删除<code>GPIO</code>配置文件</li></ul></li></ul><h3 id="2-C语言控制GPIO来点灯"><a href="#2-C语言控制GPIO来点灯" class="headerlink" title="2.C语言控制GPIO来点灯"></a>2.C语言控制GPIO来点灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gpio.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// The specific GPIO being used must be setup and replaced thru</span></span><br><span class="line"><span class="comment">// this code.  The GPIO of 240 is in the path of most the sys dirs</span></span><br><span class="line"><span class="comment">// and in the export write.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Figuring out the exact GPIO was not totally obvious when there</span></span><br><span class="line"><span class="comment">// were multiple GPIOs in the system. One way to do is to go into</span></span><br><span class="line"><span class="comment">// the gpiochips in /sys/class/gpio and view the label as it should</span></span><br><span class="line"><span class="comment">// reflect the address of the GPIO in the system. The name of the</span></span><br><span class="line"><span class="comment">// the chip appears to be the 1st GPIO of the controller.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The export causes the gpio240 dir to appear in /sys/class/gpio.</span></span><br><span class="line"><span class="comment">// Then the direction and value can be changed by writing to them.</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// The performance of this is pretty good, using a nfs mount,</span></span><br><span class="line"><span class="comment">// running on open source linux, on the ML507 reference system,</span></span><br><span class="line"><span class="comment">// the GPIO can be toggled about every 4 usec.</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// The following commands from the console setup the GPIO to be</span></span><br><span class="line"><span class="comment">// exported, set the direction of it to an output and write a 1</span></span><br><span class="line"><span class="comment">// to the GPIO.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// bash&gt; echo 900 &gt; /sys/class/gpio/export</span></span><br><span class="line"><span class="comment">// bash&gt; echo out &gt; /sys/class/gpio/gpio900/direction</span></span><br><span class="line"><span class="comment">// bash&gt; echo 1 &gt; /sys/class/gpio/gpio900/value</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// if sysfs is not mounted on your system, the you need to mount it</span></span><br><span class="line"><span class="comment">// bash&gt; mount -t sysfs sysfs /sys</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// the following bash script to toggle the gpio is also handy for</span></span><br><span class="line"><span class="comment">// testing</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// while [ 1 ]; do</span></span><br><span class="line"><span class="comment">//  echo 1 &gt; /sys/class/gpio/gpio900/value</span></span><br><span class="line"><span class="comment">//sleep 1</span></span><br><span class="line"><span class="comment">//  echo 0 &gt; /sys/class/gpio/gpio900/value</span></span><br><span class="line"><span class="comment">//sleep 1</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// to compile this, use the following command</span></span><br><span class="line"><span class="comment">// gcc gpio.c -o gpio</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// The kernel needs the following configuration to make this work.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// CONFIG_GPIO_SYSFS=y</span></span><br><span class="line"><span class="comment">// CONFIG_SYSFS=y</span></span><br><span class="line"><span class="comment">// CONFIG_EXPERIMENTAL=y</span></span><br><span class="line"><span class="comment">// CONFIG_GPIO_XILINX=y</span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> valuefd, exportfd, directionfd;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPIO test running...\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// The GPIO has to be exported to be able to see it</span></span><br><span class="line">    <span class="comment">// in sysfs</span></span><br><span class="line">  </span><br><span class="line">    exportfd = open(<span class="string">&quot;/sys/class/gpio/export&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (exportfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot open GPIO to export it\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    write(exportfd, <span class="string">&quot;900&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(exportfd);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPIO exported successfully\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update the direction of the GPIO to be an output</span></span><br><span class="line">  </span><br><span class="line">    directionfd = open(<span class="string">&quot;/sys/class/gpio/gpio900/direction&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (directionfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot open GPIO direction it\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    write(directionfd, <span class="string">&quot;out&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(directionfd);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPIO direction set as output successfully\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Get the GPIO value ready to be toggled</span></span><br><span class="line">  </span><br><span class="line">    valuefd = open(<span class="string">&quot;/sys/class/gpio/gpio900/value&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (valuefd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot open GPIO value\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPIO value opened, now toggling...\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// toggle the GPIO as fast a possible forever, a control c is needed</span></span><br><span class="line">    <span class="comment">// to stop it</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(valuefd,<span class="string">&quot;1&quot;</span>, <span class="number">2</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">        write(valuefd,<span class="string">&quot;0&quot;</span>, <span class="number">2</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /opt/Xilinx/Vivado/2017.4/settings64.sh</span><br><span class="line">$ arm-linux-gnueabihf-gcc gpio.c -o gpio</span><br></pre></td></tr></table></figure><hr><h1 id="Linux源码编译"><a href="#Linux源码编译" class="headerlink" title="Linux源码编译"></a>Linux源码编译</h1><p>参考：<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842481/Build+kernel">Build kernel</a></p><h3 id="1-编译环境准备"><a href="#1-编译环境准备" class="headerlink" title="1.编译环境准备"></a>1.编译环境准备</h3><blockquote><p>注意：这里的都采用<code>2017.4</code>版本</p></blockquote><h5 id="1-交叉编译工具链安装"><a href="#1-交叉编译工具链安装" class="headerlink" title="1.交叉编译工具链安装"></a>1.交叉编译工具链安装</h5><p>参考：<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842547/Install+Xilinx+Tools">Install Xilinx Tools</a></p><p>(这里如果安装了<code>vivado</code>的话就不用再安装其他工具)</p><ul><li>设置交叉编译器的环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> CROSS_COMPILE=&lt;x-tool prefix&gt;</span><br><span class="line"><span class="comment"># 例如export CROSS_COMPILE=arm-linux-gnueabihf-</span></span><br><span class="line">$ <span class="built_in">source</span> &lt;vivado <span class="built_in">dir</span>&gt;/settings64.sh</span><br><span class="line"><span class="comment"># 在当前bash环境下读取并执行settings64.sh中的命令(使交叉编译工具能够在该bash使用)</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Xilinx tools</code>提供一下交叉编译工具链</p><div class="table-container"><table><thead><tr><th style="text-align:center">Target Architecture</th><th style="text-align:center">x-tool prefix</th></tr></thead><tbody><tr><td style="text-align:center">Zynq-7000 (CodeSourcery - soft float)</td><td style="text-align:center">arm-xilinx-linux-gnueabi-</td></tr><tr><td style="text-align:center">Zynq-7000 (Linaro - hard float)</td><td style="text-align:center">arm-linux-gnueabihf-</td></tr><tr><td style="text-align:center">Zynq UltraScale+ MPSoC (ZynqMP) / Versal</td><td style="text-align:center">aarch64-linux-gnu-</td></tr><tr><td style="text-align:center">Microblaze little endian</td><td style="text-align:center">microblazeel-xilinx-linux-gnu-</td></tr><tr><td style="text-align:center">Microblaze big endian</td><td style="text-align:center">microblaze-xilinx-linux-gnu-</td></tr><tr><td style="text-align:center">PowerPC</td><td style="text-align:center">powerpc-eabi-</td></tr></tbody></table></div></blockquote><h5 id="2-编译FSBL-只是编译内核不需要这步"><a href="#2-编译FSBL-只是编译内核不需要这步" class="headerlink" title="2.编译FSBL(只是编译内核不需要这步)"></a>2.编译FSBL(只是编译内核不需要这步)</h5><p>参考：<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841798/Build+FSBL">Build FSBL</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hsi</span><br><span class="line">hsi% <span class="built_in">set</span> hwdsgn [open_hw_design design_1_wrapper.hdf]</span><br><span class="line">hsi% generate_app -hw <span class="variable">$hwdsgn</span> -os standalone -proc ps7_cortexa9_0 -app zynq_fsbl -compile -sw fsbl -<span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure><p>报错：<code>ERROR: [Common 17-70] Application Exception: Not found in path: gmake</code></p><p>解决：网上说gmake其实就是make，所以添加软链接<code>sudo ln -s /usr/bin/make /usr/bin/gmake</code>再次执行就没问题了</p><h5 id="3-生成设备树编译器-dtc"><a href="#3-生成设备树编译器-dtc" class="headerlink" title="3.生成设备树编译器(dtc)"></a>3.生成设备树编译器(dtc)</h5><p>参考：<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841988/Build+Device+Tree+Compiler+dtc">Build Device Tree Compiler (dtc)</a></p><p>下载地址：<a href="https://git.kernel.org/pub/scm/utils/dtc/dtc.git">https://git.kernel.org/pub/scm/utils/dtc/dtc.git</a></p><ul><li>编译<code>dtc</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><blockquote><p>这是可能会提示<code>## Skipping pylibfdt (install python dev and swig to build)</code>，此时需要使用命令<code>sudo apt install python-dev</code>和<code>sudo apt install swig</code>来安装缺失库</p></blockquote><ul><li>添加<code>dtc</code>的环境变量</li></ul><blockquote><p>构建过程完成后，有必要让工具（例如U-Boot构建过程）访问dtc二进制文件的路径。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h5 id="4-编译U-Boot"><a href="#4-编译U-Boot" class="headerlink" title="4.编译U-Boot"></a>4.编译U-Boot</h5><p>参考：<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841973/Build+U-Boot">Build U-Boot</a></p><p>下载地址：<a href="https://github.com/Xilinx/u-boot-xlnx">https://github.com/Xilinx/u-boot-xlnx</a></p><ul><li>添加工具链路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Zynq:</span></span><br><span class="line">$ <span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line">$ <span class="built_in">export</span> ARCH=arm</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make distclean</span><br><span class="line">$ make zynq_zc706_defconfig</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><blockquote><p>为了使编译<code>Linux</code>内核源码时<code>mkimage</code>可用，建议将工具目录添加到<code>$PATH</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> tools</span><br><span class="line">$ <span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-编译Linux内核源码"><a href="#2-编译Linux内核源码" class="headerlink" title="2.编译Linux内核源码"></a>2.编译Linux内核源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make ARCH=arm xilinx_zynq_defconfig</span><br><span class="line">$ make ARCH=arm menuconfig</span><br><span class="line"><span class="comment"># 编译内核镜像文件</span></span><br><span class="line">$ make ARCH=arm UIMAGE_LOADADDR=0x8000 uImage</span><br></pre></td></tr></table></figure><p><img src="F:\typora-user-imgs\uTools_1672401219902.png" alt="uTools_1672401219902"></p><h3 id="3-生成镜像文件和启动文件"><a href="#3-生成镜像文件和启动文件" class="headerlink" title="3.生成镜像文件和启动文件"></a>3.生成镜像文件和启动文件</h3><h1 id="Linux内核文件解释"><a href="#Linux内核文件解释" class="headerlink" title="Linux内核文件解释"></a>Linux内核文件解释</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/***.h&gt; 是在linux-2.6.29/include/linux下面寻找源文件。</span><br><span class="line">#include &lt;asm/***.h&gt; 是在linux-2.6.29/arch/arm/include/asm下面寻找源文件。</span><br><span class="line">#include &lt;mach/***.h&gt; 是在linux-2.6.29/arch/arm/mach-s3c2410/include/mach下面寻找源文件。</span><br><span class="line"> </span><br><span class="line">#include &lt;plat/regs-adc.h&gt;在linux-2.6.31_TX2440A20100510\linux-2.6.31_TX2440A\arch\arm\plat-s3c\include\plat</span><br><span class="line">#include &lt;linux/module.h&gt; //最基本的文件，支持动态添加和卸载模块。Hello World驱动要这一个文件就可以了</span><br><span class="line">#include &lt;linux/fs.h&gt; //包含了文件操作相关struct的定义，例如大名鼎鼎的struct file_operations</span><br><span class="line"> </span><br><span class="line">//包含了struct inode 的定义，MINOR、MAJOR的头文件。</span><br><span class="line">#include &lt;linux/errno.h&gt; //包含了对返回值的宏定义，这样用户程序可以用perror输出错误信息。</span><br><span class="line">#include &lt;linux/types.h&gt; //对一些特殊类型的定义，例如dev_t, off_t, pid_t.其实这些类型大部分都是unsigned int型通过一连串的typedef变过来的，只是为了方便阅读。</span><br><span class="line">#include &lt;linux/cdev.h&gt; //对字符设备结构cdev以及一系列的操作函数的定义。//包含了cdev 结构及相关函数的定义。</span><br><span class="line">#include &lt;linux/wait.h&gt; //等代队列相关头文件//内核等待队列，它包含了自旋锁的头文件</span><br><span class="line"> </span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt; </span><br><span class="line">#include &lt;linux/slab.h&gt; //包含了kcalloc、kzalloc内存分配函数的定义。</span><br><span class="line">#include &lt;linux/uaccess.h&gt; //包含了copy_to_user、copy_from_user等内核访问用户进程内存地址的函数定义。</span><br><span class="line">#include &lt;linux/device.h&gt; //包含了device、class 等结构的定义</span><br><span class="line">#include &lt;linux/io.h&gt; //包含了ioremap、iowrite等内核访问IO内存等函数的定义。</span><br><span class="line">#include &lt;linux/miscdevice.h&gt; //包含了miscdevice结构的定义及相关的操作函数。</span><br><span class="line">#include &lt;linux/interrupt.h&gt; //使用中断必须的头文件</span><br><span class="line">#include &lt;mach/irqs.h&gt; //使用中断必须的头文件</span><br><span class="line">#include &lt;asm/bitops.h&gt; //包含set_bit等位操作函数，实现Input子系统时可用。</span><br><span class="line">#include &lt;linux/semaphore.h&gt; //使用信号量必须的头文件</span><br><span class="line">#include &lt;linux/spinlock.h&gt; //自旋锁</span><br><span class="line"> </span><br><span class="line">#include &lt;linux/sched.h&gt; //内核等待队列中要使用的TASK_NORMAL、TASK_INTERRUPTIBLE包含在这个头文件</span><br><span class="line">#include &lt;linux/kfifo.h&gt; //fifo环形队列</span><br><span class="line">#include &lt;linux/timer.h&gt; //内核定时器</span><br><span class="line">#include &lt;linux/input.h&gt; //中断处理</span><br><span class="line"> </span><br><span class="line">头文件主目录include</span><br><span class="line"> </span><br><span class="line">头文件目录中总共有32个.h头文件。其中主目录下有13个，asm子目录中有4个，linux子目录中有10个，sys子目录中有5个。这些头文件各自的功能如下，具体的作用和所包含的信息请参见第14章。</span><br><span class="line"> </span><br><span class="line">&lt;a.out.h&gt;：a.out头文件，定义了a.out执行文件格式和一些宏。</span><br><span class="line">&lt;const.h&gt;：常数符号头文件，目前仅定义了i节点中i_mode字段的各标志位。</span><br><span class="line">&lt;ctype.h&gt;：字符类型头文件，定义了一些有关字符类型判断和转换的宏。</span><br><span class="line">&lt;errno.h&gt;：错误号头文件，包含系统中各种出错号。(Linus从minix中引进的)。</span><br><span class="line">&lt;fcntl.h&gt;：文件控制头文件，用于文件及其描述符的操作控制常数符号的定义。</span><br><span class="line">&lt;signal.h&gt;：信号头文件，定义信号符号常量，信号结构以及信号操作函数原型。</span><br><span class="line">&lt;stdarg.h&gt;：标准参数头文件，以宏的形式定义变量参数列表。主要说明了一个类型（va_list）和3个宏（va_start, va_arg和va_end），用于vsprintf、vprintf、vfprintf函数。</span><br><span class="line">&lt;stddef.h&gt;：标准定义头文件，定义了NULL, offsetof(TYPE, MEMBER)。</span><br><span class="line">&lt;string.h&gt;：字符串头文件，主要定义了一些有关字符串操作的嵌入函数。</span><br><span class="line">&lt;termios.h&gt;：终端输入输出函数头文件，主要定义控制异步通信口的终端接口。</span><br><span class="line">&lt;time.h&gt;：时间类型头文件，主要定义了tm结构和一些有关时间的函数原形。</span><br><span class="line">&lt;unistd.h&gt;：Linux标准头文件，定义了各种符号常数和类型，并声明了各种函数。如，定义了__LIBRARY__，则还包括系统调用号和内嵌汇编_syscall0()等。</span><br><span class="line">&lt;utime.h&gt;：用户时间头文件，定义了访问和修改时间结构以及utime()原型。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">（1）体系结构相关头文件子目录include/asm</span><br><span class="line">这些头文件主要定义了一些与CPU体系结构密切相关的数据结构、宏函数和变量。共4个文件。</span><br><span class="line"> </span><br><span class="line">&lt;asm/io.h&gt;：I/O头文件，以宏的嵌入汇编程序形式定义对I/O端口操作的函数。</span><br><span class="line">&lt;asm/memory.h&gt;：内存拷贝头文件，含有memcpy()嵌入式汇编宏函数。</span><br><span class="line">&lt;asm/segment.h&gt;：段操作头文件，定义了有关段寄存器操作的嵌入式汇编函数。</span><br><span class="line">&lt;asm/system.h&gt;：系统头文件，定义了设置或修改描述符/中断门等的嵌入式汇编宏。</span><br><span class="line"> </span><br><span class="line">（2）Linux内核专用头文件子目录include/linux</span><br><span class="line"> </span><br><span class="line">&lt;linux/config.h&gt;：内核配置头文件，定义键盘语言和硬盘类型（HD_TYPE）可选项。</span><br><span class="line">&lt;linux/fdreg.h&gt;：软驱头文件，含有软盘控制器参数的一些定义。</span><br><span class="line">&lt;linux/fs.h&gt;：文件系统头文件，定义文件表结构（file,buffer_head,m_inode等）。</span><br><span class="line">&lt;linux/hdreg.h&gt;：硬盘参数头文件，定义访问硬盘寄存器端口、状态码和分区表等信息。</span><br><span class="line">&lt;linux/head.h&gt;：head头文件，定义了段描述符的简单结构，和几个选择符常量。</span><br><span class="line">&lt;linux/kernel.h&gt;：内核头文件，含有一些内核常用函数的原形定义。</span><br><span class="line">&lt;linux/mm.h&gt;：内存管理头文件，含有页面大小定义和一些页面释放函数原型。</span><br><span class="line">&lt;linux/sched.h&gt;： 调度程序头文件，定义了任务结构task_struct、初始任务0的数据，</span><br><span class="line">以及一些有关描述符参数设置和获取的嵌入式汇编函数宏语句。</span><br><span class="line">&lt;linux/sys.h&gt;：系统调用头文件，含有72个系统调用C函数处理程序,以&quot;sys_&quot;开头。</span><br><span class="line">&lt;linux/tty.h&gt;：tty头文件，定义了有关tty_io，串行通信方面的参数、常数。</span><br><span class="line"> </span><br><span class="line">（3）系统专用数据结构子目录include/sys</span><br><span class="line">&lt;sys/stat.h&gt;： 文件状态头文件，含有文件或文件系统状态结构stat&#123;&#125;和常量。</span><br><span class="line">&lt;sys/times.h&gt;：定义了进程中运行时间结构tms以及times()函数原型。</span><br><span class="line">&lt;sys/types.h&gt;：类型头文件，定义了基本的系统数据类型。</span><br><span class="line">&lt;sys/utsname.h&gt;：系统名称结构头文件。</span><br><span class="line">&lt;sys/wait.h&gt;：等待调用头文件，定义系统调用wait()和waitpid()及相关常数符号。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;assert.h&gt; 验证程序断言</span><br><span class="line">&lt;complex.h&gt; 支持复数算术运算</span><br><span class="line">&lt;ctype.h&gt; 字符类型</span><br><span class="line">&lt;errno.h&gt; 出错码</span><br><span class="line">&lt;fenv.h&gt; 浮点环境</span><br><span class="line">&lt;float.h&gt; 浮点常量</span><br><span class="line">&lt;inttypes.h&gt; 整形格式转换</span><br><span class="line">&lt;iso646.h&gt; 替代关系操作符宏</span><br><span class="line">&lt;limits.h&gt; 实现常量</span><br><span class="line">&lt;locale.h&gt; 局部类别</span><br><span class="line">&lt;math.h&gt; 数学常量</span><br><span class="line">&lt;setjmp.h&gt; 非局部goto</span><br><span class="line">&lt;signal.h&gt; 信号</span><br><span class="line">&lt;stdarg.h&gt; 可变参数表</span><br><span class="line">&lt;stdbool.h&gt; 布尔类型和值</span><br><span class="line">&lt;stddef.h&gt; 标准定义</span><br><span class="line">&lt;stdint.h&gt; 整型</span><br><span class="line">&lt;stdio.h&gt; 标准I/O库</span><br><span class="line">&lt;stdlib.h&gt; 实用程序库函数</span><br><span class="line">&lt;string.h&gt; 字符串操作</span><br><span class="line">&lt;tgmath.h&gt; 通用类型数学宏</span><br><span class="line">&lt;time.h&gt; 时间和日期</span><br><span class="line">&lt;wchar.h&gt; 扩展的多字节和宽字符支持</span><br><span class="line">&lt;wctype.h&gt; 宽字符分类和映射支持</span><br><span class="line">POSIX标准定义的头文件</span><br><span class="line">[ sell=2]&lt;direct.h&gt; 目录项</span><br><span class="line">&lt;fchtol.h&gt; 文件控制</span><br><span class="line">&lt;fnmatch.h&gt; 文件名匹配类型</span><br><span class="line">&lt;glob.h&gt; 路径名模式匹配类型</span><br><span class="line">&lt;grp.h&gt; 组文件</span><br><span class="line">&lt;netdb.h&gt; 网络数据库操作</span><br><span class="line">&lt;pwd.h&gt; 口令文件</span><br><span class="line">&lt;regex.h&gt; 正则表达式</span><br><span class="line">&lt;tar.h&gt; tar归档值</span><br><span class="line">&lt;termios.h&gt; 终端I/O</span><br><span class="line">&lt;unistd.h&gt; 符号常量</span><br><span class="line">&lt;utime.h&gt; 文件时间</span><br><span class="line">&lt;wordexp.h&gt; 字扩展类型</span><br><span class="line">&lt;arpa/inet.h&gt; Internet定义</span><br><span class="line">&lt;net/if.h&gt; 套接字本地接口</span><br><span class="line">&lt;netinet/in.h&gt; Internet地址族</span><br><span class="line">&lt;sys/mman.h&gt; 内存管理声明</span><br><span class="line">&lt;sys/select.h&gt; select函数</span><br><span class="line">&lt;sys/socket.h&gt; 套接字接口</span><br><span class="line">&lt;sys/stat.h&gt; 文件状态</span><br><span class="line">&lt;sys/times.h&gt; 进程时间</span><br><span class="line">&lt;sys/types.h&gt; 基本系统数据类型</span><br><span class="line">&lt;sys/un.h&gt; UNIX域套接字定义</span><br><span class="line">&lt;sys/utsname.h&gt; 系统名</span><br><span class="line">&lt;sys/wait.h&gt; 进程控制</span><br><span class="line"> </span><br><span class="line">POSIX标准定义的XSI扩展头文件</span><br><span class="line">&lt;cpio.h&gt; cpio归档值</span><br><span class="line">&lt;dlfcn.h&gt; 动态连接</span><br><span class="line">&lt;fmtmsg.h&gt; 消息显示结构</span><br><span class="line">&lt;ftw.h&gt; 文件树漫游</span><br><span class="line">&lt;iconv.h&gt; 代码集转换实用程序</span><br><span class="line">&lt;langinfo.h&gt; 语言信息常量</span><br><span class="line">&lt;libgen.h&gt; 模式匹配函数定义</span><br><span class="line">&lt;monetary.h&gt; 货币类型</span><br><span class="line">&lt;ndbm.h&gt; 数据库操作</span><br><span class="line">&lt;nl_types.h&gt; 消息类别</span><br><span class="line">&lt;poll.h&gt; 轮询函数</span><br><span class="line">&lt;search.h&gt; 搜索表</span><br><span class="line">&lt;strings.h&gt; 字符串操作</span><br><span class="line">&lt;syslog.h&gt; 系统出错日志记录</span><br><span class="line">&lt;ucontext.h&gt; 用户上下文</span><br><span class="line">&lt;ulimit.h&gt; 用户限制</span><br><span class="line">&lt;utmpx.h&gt; 用户账户数据库</span><br><span class="line">&lt;sys/ipc.h&gt; IPC</span><br><span class="line">&lt;sys/msg.h&gt; 消息队列</span><br><span class="line">&lt;sys/resource.h&gt;资源操作</span><br><span class="line">&lt;sys/sem.h&gt; 信号量</span><br><span class="line">&lt;sys/shm.h&gt; 共享存储</span><br><span class="line">&lt;sys/statvfs.h&gt; 文件系统信息</span><br><span class="line">&lt;sys/time.h&gt; 时间类型</span><br><span class="line">&lt;sys/timeb.h&gt; 附加的日期和时间定义</span><br><span class="line">&lt;sys/uio.h&gt; 矢量I/O操作</span><br><span class="line">&lt;aio.h&gt; 异步I/O</span><br><span class="line">&lt;mqueue.h&gt; 消息队列</span><br><span class="line">&lt;pthread.h&gt; 线程</span><br><span class="line">&lt;sched.h&gt; 执行调试</span><br><span class="line">&lt;semaphore.h&gt; 信号量</span><br><span class="line">&lt;spawn.h&gt; 实时spawn接口</span><br><span class="line">&lt;stopts.h&gt; XSI STREAMS 接口</span><br><span class="line">&lt;trace.h&gt; 时间跟踪[/sell]</span><br></pre></td></tr></table></figure><hr><h1 id="i2c模块编译"><a href="#i2c模块编译" class="headerlink" title="i2c模块编译"></a>i2c模块编译</h1><h1 id="驱动程序开发步骤"><a href="#驱动程序开发步骤" class="headerlink" title="驱动程序开发步骤"></a>驱动程序开发步骤</h1><ul><li><p>查看原理图以及数据手册</p></li><li><p>修改设备树</p></li><li><p>套用设备框架编写驱动</p></li><li><p>编译动程序</p></li></ul><h1 id="petalinux定制Linux系统"><a href="#petalinux定制Linux系统" class="headerlink" title="petalinux定制Linux系统"></a>petalinux定制Linux系统</h1><h3 id="1-建立petalinux工程"><a href="#1-建立petalinux工程" class="headerlink" title="1.建立petalinux工程"></a>1.建立petalinux工程</h3><ul><li>添加环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /opt/pkg/petalinux/settings.sh</span><br><span class="line">$ <span class="built_in">source</span> /opt/Xilinx/Vivado/2017.4/settings64.sh</span><br></pre></td></tr></table></figure><ul><li>创建<code>petalinux</code>工程(<code>peta_linux</code>)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ petalinux-create --<span class="built_in">type</span> project --template zynq --name peta_linux</span><br></pre></td></tr></table></figure><ul><li>配置<code>petalinux</code>工程硬件信息(<code>../linux_base.sdk</code>目录下就是<code>vivado</code>导出的硬件信息)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> peta_linux</span><br><span class="line">$ petalinux-config --get-hw-description ../linux_base.sdk</span><br></pre></td></tr></table></figure><ul><li>接再来会弹出窗口来配置<code>petalinux</code>工程，配置过后想再次配置可以运行<code>petalinux-config</code>命令</li></ul><h3 id="2-配置Linux内核"><a href="#2-配置Linux内核" class="headerlink" title="2.配置Linux内核"></a>2.配置Linux内核</h3><ul><li>使用以下命令配置内核</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ petalinux-config -c kernel</span><br></pre></td></tr></table></figure><ul><li>等待一段时间后弹出配置内核的界面，在此界面进行内核配置</li></ul><h3 id="3-配置根文件系统"><a href="#3-配置根文件系统" class="headerlink" title="3.配置根文件系统"></a>3.配置根文件系统</h3><ul><li>使用以下命令配置根文件系统</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ petalinux-config -c rootfs</span><br></pre></td></tr></table></figure><ul><li>同样等待一段时间后弹出配置根文件系统的界面，在此界面进行配置</li></ul><h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h3><ul><li>使用以下命令配置编译<code>uboot</code>、内核、根文件系统、设备树等，也需要等待一段时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ petalinux-build</span><br></pre></td></tr></table></figure><h3 id="5-生成BOOT文件"><a href="#5-生成BOOT文件" class="headerlink" title="5.生成BOOT文件"></a>5.生成BOOT文件</h3><ul><li>使用以下命令生成<code>BOOT</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ petalinux-package --boot --fsbl ./images/linux/zynq_fsbl.elf --fpga ./images/linux/design_1_wrapper.bit --u-boot --force</span><br></pre></td></tr></table></figure><ul><li>生成的<code>BOOT</code>文件在<code>./images/linux/</code>目录下，将<code>BOOT.BIN</code>和<code>image.ub</code>复制到<code>SD</code>卡，插到开发板上并设置为<code>SD</code>卡启动</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vscode调试笔记</title>
      <link href="/2023/05/05/Vscode%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/05/Vscode%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Vscode</code>配置调试文件及其参数含义的笔记，这里以<code>Linux</code>下的<code>C/C++</code>调试环境为例进行说明</p></blockquote><h2 id="一、调试文件的配置"><a href="#一、调试文件的配置" class="headerlink" title="一、调试文件的配置"></a>一、调试文件的配置</h2><p>在<code>vscode</code>中，通过配置<code>launch.json</code>文件进行调试。在侧边栏的调试(像虫子一样)中，如果没有配置就会显示如下类似的界面：</p><p><img src="https://s2.loli.net/2023/05/04/6hy3kbglW9CHI1a.png" alt=""></p><blockquote><p>这时可以直接<strong>点击运行和调试</strong>，也可以点击<strong><code>创建 launch.json 文件</code></strong>，然后会提示选择调试环境，<code>Linux</code>类系统选择<code>C++(GDB/LLDB)</code>，<code>Windows</code>系统选择<code>C++(Windows)</code>，选择<code>C++(GDB/LLDB)</code>后，会提示选择配置(若没有这一步则会直接生成一个空的<code>launch.json</code>)，此时选择<code>gcc - 生成和调试活动文件</code>，就会在项目根目录的<code>.vscode</code>内创建<code>launch.json</code>和<code>task.json</code>共两个文件；</p><p>个人理解是：<code>launch,json</code>文件是用来配置目标程序调试相关的参数，<code>task.json</code>是用来指定某个<code>task</code>如何编译当前的项目。</p></blockquote><h3 id="1-launch-json内容"><a href="#1-launch-json内容" class="headerlink" title="1.launch.json内容"></a>1.<code>launch.json</code>内容</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>name</code>：配置的名字，可以存在不同配置，一般是一个调试目标有一个配置（显示在调试侧边栏上下拉选择列表中）；</li><li><code>type</code>：表明调试器的类型，使用<code>Visual Studio Windows Debuger</code>的时候必须是<code>cppvsdbg</code>；使用<code>GDB</code>或者<code>LLDB</code>时为<code>cppdbg</code>；</li><li><code>request</code>：表明是执行（<code>launch</code>）目标程序，还是连接（<code>attach</code>）已有的实例；</li><li><code>program</code>：表明调试的目标程序；</li><li><code>args</code>：执行目标参数需要的参数，格式为<code>json</code>列表；</li><li><code>cwd</code>：目标程序执行的工作目录；</li><li><code>MIMode</code>：表明使用的调试器，<code>gdb</code>或者是<code>lldb</code>；</li><li><code>preLaunchTask</code>：就是在开始调试前需要执行的任务，定义在<code>task.json</code>文件中，一般用来定义编译任务，生成目标程序。</li></ul><h3 id="2-task-json内容"><a href="#2-task-json内容" class="headerlink" title="2.task.json内容"></a>2.<code>task.json</code>内容</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里其实就是执行指定<code>args</code>参数的<code>command</code>，其作用是编译当前的活动文件。 其中<code>label</code>字段定义的就是一个task的名字，在<code>launch.json</code>中通过<code>preLaunchTask</code>字段指明<code>task</code>的名字就可以了。</p></blockquote><ul><li><code>type</code>：表明<code>task</code>的类型；</li><li><code>options</code>：就是一些其他可选的设置；</li><li><code>group</code>：是该<code>task</code>的组别，可以通过命令面板执行同一个组别的多个<code>task</code>。</li></ul><p>一般情况下，编译采用编译脚本进行自动编译，比如在项目根目录的<code>build.sh</code>采用<code>cmake</code>和<code>make</code>的方式自动编译生成目标程序，此时可以新增一个如下的<code>task</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Build All Targets&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./build.sh&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自动编译生成目标程序&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意<code>type</code>指定成了<code>shell</code>，如果你的脚本是可以直接执行的，那么<code>command</code>也可以直接写成<code>./build.sh</code>；此时，<code>command</code>也可以是任何在shell中能够使用的命令。</p></blockquote><p><strong>综上：<code>Vscode</code>的配置文件中，<code>launch.json</code>指明要调试的目标、需要的参数和工作目录；<code>task.json</code>中指明具体编译实现的方式。</strong></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/360303220">vscode实战：代码调试</a></p><p><a href="https://code.visualstudio.com/docs/editor/debugging#_launch-configurations">Debugging</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎的搜索技巧</title>
      <link href="/2023/04/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/04/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理记录一下搜索引擎的搜索技巧，方便以后使用。</p><ul><li>1.完全匹配搜索 </li></ul><p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配</p></blockquote><p>百度和<code>Google</code>都支持这个指令，例如搜索： <code>&quot;方法图片&quot;</code></p><ul><li>2.搜索范围限定在<code>URL</code></li></ul><blockquote><p>inurl: 用于搜索查询词出现在url 中的页面</p></blockquote><p>百度和<code>Google</code>都支持<code>inurl</code>指令。<code>inurl</code>支持中文和英文。 比如搜索：<code>inurl:搜索引擎优化</code>，返回的结果都是网址中包含“搜索引擎优化”的页面。由于关键词出现在<code>url</code>中对排名有一定影响，使用<code>inurl</code>搜索可以更准确地找到竞争对手。</p><ul><li>3.搜索范围限定在标题  </li></ul><blockquote><p>intitle: 指令返回的是页面title中包含关键词的页面</p></blockquote><p>百度和<code>Google</code>都支持<code>intitle</code>指令。 使用<code>intitle</code>指令找到的是更准确的竞争页面。如果关键词只出现在页面可见文字中，而没有出现在<code>title</code>中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。 </p><ul><li>4.搜索范围限定在指定网站</li></ul><blockquote><p>在查询词后输入 <code>site:网站名</code>，网站名就是你要查的资料或信息来源网站，这里的冒号为英文冒号</p></blockquote><p>例如搜索：<code>户口 site:www.beijing.gov.cn</code>，得到的网页一定都来自北京政务门户网站。</p><ul><li>5.搜索特定书名</li></ul><blockquote><p>在查询词外加上《》。注意这里是中文的尖括号符号。搜索的结果中，书名号中的内容不会被拆分</p></blockquote><p>例如搜索：<code>《三体》</code></p><ul><li>6.并行搜索查询</li></ul><blockquote><p>在两个查询词A和B中间加入<code>|</code>，在竖杠<code>|</code>的前后都需要空一格。搜索结果会包含词语A和B中任意一个，即包含词语A的信息或者词语B的信息</p></blockquote><p>例如搜索：<code>北京 | 地坛</code></p><ul><li>7.allintitle </li></ul><blockquote><p>allintitle:搜索返回的是页面标题中包含多组关键词的文件</p></blockquote><p>例如：<code>allintitle:SEO 搜索引擎优化</code>就相当于：<code>intitle:SEO intitle:搜索引擎优化</code>，返回的是标题中中既包含<code>SEO</code>，也包含搜索引擎优化的页面</p><ul><li>8.allinurl </li></ul><blockquote><p>与allintitle: 类似</p></blockquote><p><code>allinurl:SEO 搜索引擎优化</code>就相当于：<code>inurl:SEO inurl:搜索引擎优化</code></p><ul><li>9.搜索范围限定在指定格式</li></ul><blockquote><p>filetype 用于搜索特定文件格式</p></blockquote><p>百度和<code>Google</code>都支持<code>filetype</code>指令。 比如搜索<code>filetype:pdf SEO</code>返回的就是包含<code>SEO</code>这个关键词的所有<code>pdf</code>文件</p><ul><li>10.site</li></ul><blockquote><p>最熟悉的高级搜索指令，用来搜索某个域名下的所有文件</p></blockquote><p>例如：<code>site:baidu.com</code></p><ul><li>11.related</li></ul><blockquote><p>related:指令只适用于Google，返回的结果是与某个网站有关联的页面</p></blockquote><p>这种关联到底指的是什么，<code>Google</code>并没有明确说明，一般认为指的是有共同外部链接的网站</p><p>把上面这些指令混合使用则更强大。 <code>inurl:gov 减肥</code>返回的就是<code>url</code>中包含<code>gov</code>，页面中有减肥这个词的页面</p><ul><li>12.inanchor </li></ul><blockquote><p>inanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面</p></blockquote><p>百度不支持<code>inanchor</code>。 比如在<code>Google</code>搜索：<code>inanchor:点击这里</code>返回的结果页面本身并不一定包含 点击这里 这四个字，而是指向这些页面的链接锚文字中出现了 点击这里 这四个字</p><ul><li><p>特定查询词处理</p><ul><li><p>加号</p><blockquote><p>在想要搜到的词前面加上加号+，加号前要空一格，加号后不空格。搜索结果中就一定会包含加号后的词。如 唐代诗人 +李白</p></blockquote></li><li><p>减号 </p><blockquote><p>减号代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。百度和Google都支持这个指令。例如：<code>搜索 -引擎</code>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果 </p></blockquote></li><li><p>3、星号</p><blockquote><p>星号*是常用的通配符，也可以用在搜索中。百度不支持*号搜索指令。 比如在Google中搜索：<code>搜索*擎</code>，其中的*号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</p></blockquote></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++常用语法学习笔记</title>
      <link href="/2023/03/22/C++%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/22/C++%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇笔记是跟着菜鸟教程<code>C++</code>的复习笔记(不全面)</p></blockquote><h1 id="一、C-基础复习"><a href="#一、C-基础复习" class="headerlink" title="一、C++基础复习"></a>一、C++基础复习</h1><blockquote><p>这里只列出不熟悉的(或者是<code>C</code>中没有的语法)</p></blockquote><h3 id="1-三字符组"><a href="#1-三字符组" class="headerlink" title="1.三字符组"></a>1.三字符组</h3><blockquote><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头(==现在很少使用==)</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">三字符组</th><th style="text-align:center">替换</th></tr></thead><tbody><tr><td style="text-align:center">??=</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">??/</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">??’</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">??(</td><td style="text-align:center">[</td></tr><tr><td style="text-align:center">??)</td><td style="text-align:center">]</td></tr><tr><td style="text-align:center">??!</td><td style="text-align:center">\</td><td></td></tr><tr><td style="text-align:center">??&lt;</td><td style="text-align:center">{</td></tr><tr><td style="text-align:center">??&gt;</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">??-</td><td style="text-align:center">~</td></tr></tbody></table></div><h3 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2.类型转换"></a>2.类型转换</h3><ul><li>静态转换：强制转换为另外一种数据类型(<strong>不进行任何运行时类型检查</strong>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i);<span class="comment">//静态</span></span><br></pre></td></tr></table></figure><ul><li>动态转换：通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base * ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base);<span class="comment">//将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure><ul><li>常量转换：用于将 const 类型的对象转换为非 const 类型的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i);<span class="comment">//const int转换为int</span></span><br></pre></td></tr></table></figure><ul><li>重新解释转换：将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i);<span class="comment">//int转换为float</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/22/Nfdm6DseTAaqMlV.png" alt=""></p><blockquote><p>当需要使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次</p><ul><li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li><li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</li></ul><p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，==局部变量的值会覆盖全局变量的值==，对于<code>char</code>的数据类型，使用<code>&#39;\0&#39;</code>进行初始化</p><p>块作用域指在代码块内部声明的变量，同样，块作用域内变量的值会覆盖外部作用域的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;  <span class="comment">// 块作用域变量</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;块变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;外部变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类作用域：在类内部声明的变量</p><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>，推荐把常量定义为大写字母形式</p><p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）</p><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改</p><p>thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁，每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并，可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">后缀</td><td style="text-align:center">() [] -&gt; . ++ - -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">一元</td><td style="text-align:center">+ - ! ~ ++ - - (type)* &amp; sizeof</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">乘除</td><td style="text-align:center">* / %</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">加减</td><td style="text-align:center">+ -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">移位</td><td style="text-align:center">&lt;&lt; &gt;&gt;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">关系</td><td style="text-align:center">&lt; &lt;= &gt; &gt;=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">相等</td><td style="text-align:center">== !=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位与 AND</td><td style="text-align:center">&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位异或 XOR</td><td style="text-align:center">^</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位或 OR</td><td style="text-align:center">\</td><td style="text-align:center"></td><td>从左到右</td></tr><tr><td style="text-align:center">逻辑与 AND</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">逻辑或 OR</td><td style="text-align:center">\</td><td style="text-align:center">\</td><td></td><td>从左到右</td></tr><tr><td style="text-align:center">条件</td><td style="text-align:center">?:</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">赋值</td><td style="text-align:center">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= \</td><td style="text-align:center">=</td><td>从右到左</td></tr><tr><td style="text-align:center">逗号</td><td style="text-align:center">,</td><td style="text-align:center">从左到右</td></tr></tbody></table></div><blockquote><p><code>lambda</code>函数与表达式</p><p><code>Lambda</code> 表达式把函数看作对象。<code>Lambda</code> 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。<code>Lambda</code> 表达式本质上与函数声明非常类似，具体形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>引用与指针的不同之处：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li></ul><p>引用通常用于函数参数列表和函数返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = i;<span class="comment">//创建引用(引用可以被看做是变量附属与内存位置的第二个标签)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = i;<span class="comment">//r是一个初始化为i的整形引用</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&amp;i=&quot;</span> &lt;&lt; &amp;i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;&amp;r=&quot;</span> &lt;&lt; &amp;r &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;r=&quot;</span> &lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：(可以看出i和r地址相同)</span></span><br><span class="line">&amp;i=<span class="number">000000B</span>990EFF544 &amp;r=<span class="number">000000B</span>990EFF544</span><br><span class="line">i=<span class="number">12</span> r=<span class="number">12</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cin</code>空格后面的数据不会读入(如果有空格分隔则读取到空格处结束)</p><p><code>cerr</code>为标准错误流：<code>cerr</code> 对象附属到标准输出设备，通常也是显示屏，但是 <code>cerr</code> 对象是非缓冲的，且每个流插入到 <code>cerr</code> 都会立即输出</p><p><code>clog</code>为标准日志流：<code>clog</code> 对象附属到标准输出设备，通常也是显示屏，但是 <code>clog</code> 对象是缓冲的。这意味着每个流插入到 <code>clog</code> 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出</p></blockquote><h1 id="二、C-面向对象"><a href="#二、C-面向对象" class="headerlink" title="二、C++面向对象"></a>二、C++面向对象</h1><h3 id="1-C-类-amp-对象"><a href="#1-C-类-amp-对象" class="headerlink" title="1.C++类&amp;对象"></a>1.C++类&amp;对象</h3><blockquote><p>类是 C++ 的核心特性，通常被称为用户定义的类型(==实际说白了就是C中的结构体，只不过类扩展了它，还包括可以执行哪些操作(个人理解)==)</p><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作</p><p>声明类的对象，就像声明基本类型的变量一样。</p><p>只有类和友元函数可以访问私有成员，protected（受保护）成员在派生类（即子类）中是可访问的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">classname</span><span class="comment">//class 类名</span></span><br><span class="line">&#123;</span><br><span class="line">    Access specifiers:<span class="comment">//访问修饰符:private/public/protected</span></span><br><span class="line">    Date members/variables;<span class="comment">//变量</span></span><br><span class="line">    <span class="function">Member <span class="title">function</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//方法</span></span><br><span class="line">&#125;;<span class="comment">//类以分号结束</span></span><br></pre></td></tr></table></figure><blockquote><p>public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p><ul><li><strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private(基类的非私有成员在子类的访问属性不变)</li><li><strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private(基类的非私有成员都为子类的保护成员)</li><li><strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private(基类中的非私有成员都称为子类的私有成员)</li></ul><p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数</p><p>使用 <strong>static</strong> 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本</p><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <strong>::</strong> 就可以访问。</p><p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。静态成员函数有一个类范围，他们不能访问类的 this 指针。可以使用静态成员函数来判断类的某些对象是否已被创建</p></blockquote><h3 id="2-C-继承"><a href="#2-C-继承" class="headerlink" title="2.C++继承"></a>2.C++继承</h3><blockquote><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><p>class derived-class: access-specifier base-class</p><p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private</p><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数</li></ul></blockquote><ul><li>多继承</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;: &lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;, &lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-重载运算符和重载函数"><a href="#3-重载运算符和重载函数" class="headerlink" title="3.重载运算符和重载函数"></a>3.重载运算符和重载函数</h3><ul><li>函数重载</li></ul><blockquote><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数</p></blockquote><ul><li>运算符重载</li></ul><blockquote><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表</p></blockquote><h3 id="4-C-多态"><a href="#4-C-多态" class="headerlink" title="4.C++多态"></a>4.C++多态</h3><blockquote><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数</p><p>虚函数是在基类中使用关键字<code>virtual</code>声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数</p><p>纯虚函数：函数不用给出具体实现</p><p>定义方式：</p><p><code>virtual int area() = 0;</code> <code>=0</code>告诉编译器函数没有主体，为纯虚函数</p></blockquote><h3 id="5-C-数据抽象和数据封装"><a href="#5-C-数据抽象和数据封装" class="headerlink" title="5.C++数据抽象和数据封装"></a>5.C++数据抽象和数据封装</h3><blockquote><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术，可以说是像<code>python</code>调用库函数一样</p><p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即<strong>数据隐藏</strong>。</p><p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制</p></blockquote><h3 id="6-C-接口"><a href="#6-C-接口" class="headerlink" title="6.C++接口"></a>6.C++接口</h3><blockquote><p>接口描述了类的行为和功能，而不需要完成类的特定实现。C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的</p></blockquote><h1 id="三、C-高级教程"><a href="#三、C-高级教程" class="headerlink" title="三、C++高级教程"></a>三、C++高级教程</h1><h3 id="1-C-异常"><a href="#1-C-异常" class="headerlink" title="1.C++异常"></a>1.C++异常</h3><blockquote><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p><ul><li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li><li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li><li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块</li></ul><p>使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型</p><p>让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 <code>...</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//catch块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(ExceptionName e2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//catch块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-C-动态内存"><a href="#2-C-动态内存" class="headerlink" title="2.C++动态内存"></a>2.C++动态内存</h3><blockquote><p>使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p><p>如果您不再需要动态分配的内存空间，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存</p><p><strong>malloc()</strong> 函数在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p></blockquote><h5 id="2-1-new和delete运算符"><a href="#2-1-new和delete运算符" class="headerlink" title="2.1 new和delete运算符"></a>2.1 new和delete运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_type p = <span class="keyword">new</span> data_type;<span class="comment">//使用new运算符为任意数据类型分配内存通用语法</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//释放p指向的内存</span></span><br></pre></td></tr></table></figure><h5 id="2-2-数组的动态内存分配"><a href="#2-2-数组的动态内存分配" class="headerlink" title="2.2 数组的动态内存分配"></a>2.2 数组的动态内存分配</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为数组动态分配内存</span></span><br><span class="line"><span class="type">char</span>* p =<span class="literal">NULL</span>;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure><h3 id="3-C-命名空间"><a href="#3-C-命名空间" class="headerlink" title="3.C++命名空间"></a>3.C++命名空间</h3><blockquote><p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称</p><p>调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：<code>name::code;</code>，<code>code</code>可以是变量或函数</p><p>使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-C-模版"><a href="#4-C-模版" class="headerlink" title="4.C++模版"></a>4.C++模版</h3><blockquote><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式</p></blockquote><h5 id="4-1-函数模板"><a href="#4-1-函数模板" class="headerlink" title="4.1 函数模板"></a>4.1 函数模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版函数定义一般形式</span></span><br><span class="line"><span class="comment">//type 是函数所使用的数据类型的占位符名称, 这个名称可以在函数定义中使用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="function">ret_type <span class="title">func_name</span><span class="params">(parameter list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-类模板"><a href="#4-2-类模板" class="headerlink" title="4.2 类模板"></a>4.2 类模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类声明一般形式</span></span><br><span class="line"><span class="comment">//type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-C-预处理器"><a href="#5-C-预处理器" class="headerlink" title="5.C++预处理器"></a>5.C++预处理器</h3><blockquote><p># 运算符会把 replacement-text 令牌转换为用引号引起来的字符串</p><p>## 运算符用于连接两个令牌</p></blockquote><h3 id="6-C-信号处理"><a href="#6-C-信号处理" class="headerlink" title="6.C++信号处理"></a>6.C++信号处理</h3><blockquote><p>下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号定义在 C++ 头文件 <code>&lt;csignal&gt;</code>中</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">信号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SIGABRT</td><td style="text-align:center">程序的异常终止，如调用 <strong>abort</strong>。</td></tr><tr><td style="text-align:center">SIGFPE</td><td style="text-align:center">错误的算术运算，比如除以零或导致溢出的操作。</td></tr><tr><td style="text-align:center">SIGILL</td><td style="text-align:center">检测非法指令。</td></tr><tr><td style="text-align:center">SIGINT</td><td style="text-align:center">程序终止(interrupt)信号。</td></tr><tr><td style="text-align:center">SIGSEGV</td><td style="text-align:center">非法访问内存。</td></tr><tr><td style="text-align:center">SIGTERM</td><td style="text-align:center">发送到程序的终止请求。</td></tr></tbody></table></div><h5 id="6-1-signal函数"><a href="#6-1-signal函数" class="headerlink" title="6.1 signal函数"></a>6.1 signal函数</h5><blockquote><p>注册信号及其信号处理函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span> (<span class="type">int</span> sig, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//以下语法等同</span></span><br><span class="line"><span class="built_in">signal</span>(registered signal, signal handler);</span><br></pre></td></tr></table></figure><blockquote><p>这个函数接收两个参数：第一个参数是要设置的信号的标识符，第二个参数是指向信号处理函数的指针。函数返回值是一个指向先前信号处理函数的指针。如果先前没有设置信号处理函数，则返回值为 SIG_DFL。如果先前设置的信号处理函数为 SIG_IGN，则返回值为 SIG_IGN</p></blockquote><h5 id="6-2-raise函数"><a href="#6-2-raise函数" class="headerlink" title="6.2 raise函数"></a>6.2 raise函数</h5><blockquote><p>生成信号</p><p>这里<strong>sig</strong> 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(signal sig)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-C-多线程"><a href="#7-C-多线程" class="headerlink" title="7.C++多线程"></a>7.C++多线程</h3><blockquote><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p><ul><li>基于进程的多任务处理是程序的并发执行。</li><li>基于线程的多任务处理是同一程序的片段的并发执行</li></ul></blockquote><h5 id="7-1-创建线程"><a href="#7-1-创建线程" class="headerlink" title="7.1 创建线程"></a>7.1 创建线程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_create</span>(thread, attr, start_routine, arg);</span><br></pre></td></tr></table></figure><h5 id="7-2-终止线程"><a href="#7-2-终止线程" class="headerlink" title="7.2 终止线程"></a>7.2 终止线程</h5><blockquote><p><strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_exit</span>(status);</span><br></pre></td></tr></table></figure><h5 id="7-3-连接和分离线程"><a href="#7-3-连接和分离线程" class="headerlink" title="7.3 连接和分离线程"></a>7.3 连接和分离线程</h5><blockquote><p>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span> (threadid, status) </span><br><span class="line"><span class="built_in">pthread_detach</span> (threadid) </span><br></pre></td></tr></table></figure><h5 id="7-4-std-thread"><a href="#7-4-std-thread" class="headerlink" title="7.4 std::thread"></a>7.4 std::thread</h5><blockquote><p>C++ 11 之后添加了新的标准线程库 <strong>std::thread</strong>，<strong>std::thread</strong> <strong>在 <thread></strong> 头文件中声明，因此使用 <strong>std::thread</strong> 时需要包含 在 <strong><thread></strong> 头文件</p><p><strong>std::thread</strong>默认构造函数创建一个空的<strong>std::thread</strong>执行对象</p><p>一个可调用对象可以是以下三个中的任何一个：</p><ul><li>函数指针</li><li>函数对象</li><li>lambda 表达式</li></ul><p>定义 callable 后，将其传递给 <strong>std::thread</strong> 构造函数 <strong>thread_object</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function">std::thread <span class="title">thread_object</span><span class="params">(callable)</span></span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="8-C-STL简单教程"><a href="#8-C-STL简单教程" class="headerlink" title="8.C++ STL简单教程"></a>8.C++ STL简单教程</h3><blockquote><p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈</p><p>C++ 标准模板库的核心包括以下三个组件：</p><div class="table-container"><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">容器（Containers）</td><td style="text-align:center">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td style="text-align:center">算法（Algorithms）</td><td style="text-align:center">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td style="text-align:center">迭代器（iterators）</td><td style="text-align:center">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td></tr></tbody></table></div></blockquote><ul><li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li><li>size( ) 函数显示向量的大小。</li><li>begin( ) 函数返回一个指向向量开头的迭代器。</li><li>end( ) 函数返回一个指向向量末尾的迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建向量存储int</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示vec原始大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;vector size=&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加5个值到向量中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示扩展后的大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;extend vector size=&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问vec</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;value of vec[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; vec[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器iterator访问</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (v!=vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;value of v=&quot;</span> &lt;&lt; *v &lt;&lt; std::endl;</span><br><span class="line">v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-C-标准库"><a href="#9-C-标准库" class="headerlink" title="9.C++标准库"></a>9.C++标准库</h3><p>C++ 标准库可以分为两部分：</p><ul><li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li><li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li></ul><p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p><h5 id="9-1-标准函数库"><a href="#9-1-标准函数库" class="headerlink" title="9.1 标准函数库"></a>9.1 标准函数库</h5><p>标准函数库分为以下几类：</p><ul><li>输入/输出 I/O</li><li>字符串和字符处理</li><li>数学</li><li>时间、日期和本地化</li><li>动态分配</li><li>其他</li><li>宽字符函数</li></ul><h5 id="9-2-面向对象类库"><a href="#9-2-面向对象类库" class="headerlink" title="9.2 面向对象类库"></a>9.2 面向对象类库</h5><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：</p><ul><li>标准的 C++ I/O 类</li><li>String 类</li><li>数值类</li><li>STL 容器类</li><li>STL 算法</li><li>STL 函数对象</li><li>STL 迭代器</li><li>STL 分配器</li><li>本地化库</li><li>异常处理类</li><li>杂项支持库</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>莫斯密码笔记</title>
      <link href="/2023/03/20/%E8%8E%AB%E6%96%AF%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/20/%E8%8E%AB%E6%96%AF%E5%AF%86%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>26字母和10个数字的莫斯密码笔记</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">字母</th><th style="text-align:center">莫斯密码</th><th style="text-align:center">字母</th><th style="text-align:center">莫斯密码</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center"><code>.-</code></td><td style="text-align:center">B</td><td style="text-align:center"><code>-...</code></td></tr><tr><td style="text-align:center">C</td><td style="text-align:center"><code>-.-.</code></td><td style="text-align:center">D</td><td style="text-align:center"><code>-..</code></td></tr><tr><td style="text-align:center">E</td><td style="text-align:center"><code>.</code></td><td style="text-align:center">F</td><td style="text-align:center"><code>..-.</code></td></tr><tr><td style="text-align:center">G</td><td style="text-align:center"><code>--.</code></td><td style="text-align:center">H</td><td style="text-align:center"><code>....</code></td></tr><tr><td style="text-align:center">I</td><td style="text-align:center"><code>..</code></td><td style="text-align:center">J</td><td style="text-align:center"><code>.---</code></td></tr><tr><td style="text-align:center">K</td><td style="text-align:center"><code>-.-</code></td><td style="text-align:center">L</td><td style="text-align:center"><code>.-..</code></td></tr><tr><td style="text-align:center">M</td><td style="text-align:center"><code>--</code></td><td style="text-align:center">N</td><td style="text-align:center"><code>-.</code></td></tr><tr><td style="text-align:center">O</td><td style="text-align:center"><code>---</code></td><td style="text-align:center">P</td><td style="text-align:center"><code>.--.</code></td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center"><code>--.-</code></td><td style="text-align:center">R</td><td style="text-align:center"><code>.-.</code></td></tr><tr><td style="text-align:center">S</td><td style="text-align:center"><code>...</code></td><td style="text-align:center">T</td><td style="text-align:center"><code>-</code></td></tr><tr><td style="text-align:center">U</td><td style="text-align:center"><code>..-</code></td><td style="text-align:center">V</td><td style="text-align:center"><code>...-</code></td></tr><tr><td style="text-align:center">W</td><td style="text-align:center"><code>.--</code></td><td style="text-align:center">X</td><td style="text-align:center"><code>-..-</code></td></tr><tr><td style="text-align:center">Y</td><td style="text-align:center"><code>-.--</code></td><td style="text-align:center">Z</td><td style="text-align:center"><code>--..</code></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">数字</th><th style="text-align:center">莫斯密码</th><th style="text-align:center">数字</th><th style="text-align:center">莫斯密码</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"><code>-----</code></td><td style="text-align:center">1</td><td style="text-align:center"><code>.----</code></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><code>..---</code></td><td style="text-align:center">3</td><td style="text-align:center"><code>...--</code></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><code>....-</code></td><td style="text-align:center">5</td><td style="text-align:center"><code>.....</code></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"><code>-....</code></td><td style="text-align:center">7</td><td style="text-align:center"><code>--...</code></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"><code>---..</code></td><td style="text-align:center">9</td><td style="text-align:center"><code>----.</code></td></tr></tbody></table></div><blockquote><p>SOS: <code>.../---/...</code></p><p>HELLO WORLD: <code>...././.-../.-../---/.--/---/.-./.-../-..</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 莫斯密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用简要教程</title>
      <link href="/2023/03/12/git%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/"/>
      <url>/2023/03/12/git%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章来源于<a href="https://weread.qq.com/web/reader/173323a0718ff5d9173e0afk4e73277021a4e732ced3b55">《GitHub入门与实践》第4章 通过实际操作学习Git</a></p></blockquote><h1 id="1、基本操作"><a href="#1、基本操作" class="headerlink" title="1、基本操作"></a>1、基本操作</h1><ul><li>git init — 初始化仓库</li></ul><blockquote><p>初始化成功后该目录下会生成.git目录(也称为<strong>附属于该仓库的工作树</strong>)，储存管理当前目录内容所需的仓库数据</p><p>文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in C:/Users/G3/Desktop/git test/.git/</span><br></pre></td></tr></table></figure></p><ul><li>git status —查看仓库的状态</li></ul><p>工作树和仓库在被操作的过程中，状态会不断发生变化<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p><p>所谓提交（Commit），是指“记录工作树中所有文件的当前状态”</p><p>新建README.md文件后的status如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ touch README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        README.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>git add —向暂存区中添加文件</li></ul><blockquote><p>只是用Git仓库的工作树创建了文件，那么该文件并不会被记入Git仓库的版本管理对象当中。因此我们用git status命令查看README.md文件时，它会显示在Untracked files里。</p><p>要想让文件成为Git仓库的管理对象，就需要用gitadd命令将其加入暂存区（Stage或者Index）中。暂存区是提交之前的一个临时区域</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README.md</span><br></pre></td></tr></table></figure><ul><li>git commit —保存仓库的历史记录</li></ul><blockquote><p>该命令将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件</p><p>-m参数后的称为提交信息，是对该提交的概述</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git commit -m &quot;First commit&quot;</span><br><span class="line">[master (root-commit) 066eaf7] First commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure><p><strong>记录详细提交信息</strong></p><blockquote><p>不加-m参数，直接执行git commit命令，接着会打开对应的编辑器编辑提交信息，其格式如下：</p><p>第一行：用一行文字简述提交的更改内容</p><p>第二行：空行</p><p>第三行以后：记述更改的原因和详细内容<br><strong>终止提交</strong><br>在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止<br><strong>查看提交后状态</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><ul><li>git log —查看提交日志</li></ul><blockquote><p>查看以往仓库中提交的日志。包括可以查看什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别<br><strong>注：若日志较长无法完全显示，可回车往下显示一行，并且按”q”正常退出，若非正常退出则会造成继续输入命令时无法正常显示出来；若出现这样的情况可以输入<code>reset</code>命令重置git bash，也可关闭当前终端重新打开</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git log</span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2 (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>只显示提交信息第一行</strong></p><blockquote><p>使用命令<code>git log --pretty=short</code>即可<br><strong>只显示指定目录、文件日志</strong><br>使用命令<code>git log filename</code>即可</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git log README.md</span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2 (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><p><strong>显示文件改动</strong></p><blockquote><p>使用命令<code>git log -p</code>即可在提交信息后显示文件的前后差别<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p</span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2 (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index e69de29..71b6fb7 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -0,0 +1,5 @@</span><br><span class="line">+# hello world</span><br><span class="line">+</span><br><span class="line">+This is a test, I am trying to learn git and do some excise(maybe).</span><br><span class="line">+</span><br><span class="line">+And this is a test file.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>git diff —查看更改前后的差别</li></ul><blockquote><p>git diff命令可以查看工作树、暂存区、最新提交之间的差别</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 71b6fb7..5b82da4 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -2,4 +2,6 @@</span><br><span class="line"></span><br><span class="line"> This is a test, I am trying to learn git and do some excise(maybe).</span><br><span class="line"></span><br><span class="line">-And this is a test file.</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+The line be deleted. This is a description.</span><br><span class="line">+</span><br><span class="line">+And this is a new line.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><blockquote><p>由于我们尚未用git add命令向暂存区添加任何东西，所以程序只会显示工作树与最新提交状态之间的差别</p><p>+”号标出的是新添加的行，被删除的行则用“-”号标出</p></blockquote><p><em>使用git add README.md将README.md文件加入暂存区</em></p><p><strong>查看工作树和最新提交的差别</strong></p><blockquote><p>现在执行<code>git diff</code><br>命令，由于工作树和暂存区的状态并无差别，结果什么都不会显示。要查看与最新提交的差别，请执行命令<code>git diff HEAD</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git diff HEAD</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 71b6fb7..5b82da4 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -2,4 +2,6 @@</span><br><span class="line"></span><br><span class="line"> This is a test, I am trying to learn git and do some excise(maybe).</span><br><span class="line"></span><br><span class="line">-And this is a test file.</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+The line be deleted. This is a description.</span><br><span class="line">+</span><br><span class="line">+And this is a new line.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><blockquote><p>不妨养成这样一个好习惯：在执行<code>git commit</code>命令之前先执行<code>git diff HEAD</code>命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的HEAD是指向当前分支中最新一次提交的指针</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Add something new and delete something old&quot;</span><br><span class="line">[master a071997] Add something new and delete something old</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>查看提交日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit a07199771e6436b72a32b6fec45b90caf4ed8c1b (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:51:20 2022 +0800</span><br><span class="line"></span><br><span class="line">    Add something new and delete something old</span><br><span class="line"></span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><h1 id="2、分支操作"><a href="#2、分支操作" class="headerlink" title="2、分支操作"></a>2、分支操作</h1><ul><li>git branch —显示分支一览表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><blockquote><p>标 * 表示当前所在分支</p><ul><li>git checkout —创建(添加参数-b)、切换分支</li></ul><p>使用如下命令进行切换：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-A</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b feature-A</span><br><span class="line">Switched to a new branch &#x27;feature-A&#x27;</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-A)</span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-A)</span><br><span class="line">$ git branch</span><br><span class="line">* feature-A</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><blockquote><p>此时修改代码、执行git add命令提交，代码会提交到feature-A分支，像这样不断对一个分支（例如feature-A）进行提交的操作，我们称为“培育分支”</p></blockquote><p><strong>注：这里在feature-A修改代码并提交后再切换到master分支，代码不会有相应的改动</strong></p><p><strong>切换回上一个分支</strong></p><blockquote><p>用“-”（连字符）代替分支名，就可以切换至上一个分支。当然，将“-”替换成master同样可以切换到master分支<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-A)</span><br><span class="line">$ git checkout -</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>特性分支</strong></p><blockquote><p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master分支担当</p></blockquote><p><strong>主干分支</strong></p><blockquote><p>主干分支是刚才我们讲解的特性分支的原点，同时也是合并的终点。通常人们会用master分支作为主干分支</p><ul><li>git merge —合并分支</li></ul><p>使用命令<code>git merge --no-ff feature-A</code>，参数—no-ff是为了在历史记录中明确记录下本次分支合并</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git merge --no-ff feature-A</span><br><span class="line">hint: Waiting for your editor to close the file...</span><br><span class="line">[main 2022-02-22T06:12:20.690Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:12:21.135Z] ExtensionHostStarterWorker created</span><br><span class="line">[main 2022-02-22T06:12:23.323Z] Starting extension host with pid 13468 (fork() took 103 ms).</span><br><span class="line">[main 2022-02-22T06:12:23.324Z] ExtensionHostStarterWorker.start() took 106 ms.</span><br><span class="line">[main 2022-02-22T06:12:50.696Z] update#setState checking for updates</span><br><span class="line">[main 2022-02-22T06:12:50.792Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:13:03.000Z] Extension host with pid 13468 exited with code: 0, signal: null.</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md | 6 +++++-</span><br><span class="line"> 1 file changed, 5 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>git log —graph 以图表形式查看分支</li></ul><blockquote><p>用git log —graph命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br><span class="line">*   commit 4c6d8896e9e288b21a36aa840f0c536d8154d683 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: a071997 40d98e7</span><br><span class="line">| | Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| | Date:   Tue Feb 22 14:12:18 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |     Merge branch &#x27;feature-A&#x27; into master</span><br><span class="line">| |</span><br><span class="line">| * commit 40d98e76c16be3748c4cc78d178049b579450e13 (feature-A)</span><br><span class="line">|/  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">|   Date:   Tue Feb 22 14:01:11 2022 +0800</span><br><span class="line">|</span><br><span class="line">|       add to feature-A</span><br><span class="line">|</span><br><span class="line">* commit a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:51:20 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     Add something new and delete something old</span><br><span class="line">|</span><br><span class="line">* commit 02117edd38575da4a4de7a40be083cef2e7883b2</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     file context changed.</span><br><span class="line">|</span><br><span class="line">|     I am trying to change this context of the README.md file</span><br><span class="line">|     changed by LYJ</span><br><span class="line">|</span><br><span class="line">* commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">  Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">      First commit</span><br></pre></td></tr></table></figure><h1 id="3、更改提交操作"><a href="#3、更改提交操作" class="headerlink" title="3、更改提交操作"></a>3、更改提交操作</h1><ul><li>git reset —回溯历史版本</li></ul><blockquote><p>这里为熟悉对历史版本的操作，先回溯历史版本，创建一个名为fix-B的特性分支</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b fix-B</span><br><span class="line">Switched to a new branch &#x27;fix-B&#x27;</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git branch</span><br><span class="line">  feature-A</span><br><span class="line">* fix-B</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><strong>回溯到创建feature-A分支前</strong></p><blockquote><p>要让仓库的HEAD、暂存区、当前工作树回溯到指定状态，需要用到gitreset —hard命令。只要提供目标时间点的哈希值[插图]，就可以完全恢复至该时间点的状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git reset --hard a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">HEAD is now at a071997 Add something new and delete something old</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>已经成功回溯到特性分支（feature-A）创建之前的状态。由于所有文件都回溯到了指定哈希值对应的时间点上，README.md文件的内容也恢复到了当时的状态<br><strong>创建fix-B分支</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b fix-B</span><br><span class="line">Switched to a new branch &#x27;fix-B&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>修改代码内容并提交<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git commit -m &quot;fix-B change&quot;</span><br><span class="line">[fix-B e690648] fix-B change</span><br><span class="line"> 1 file changed, 9 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>推进至feature-A分支合并后的状态</strong></p><blockquote><p>首先恢复到feature-A分支合并后的状态。不妨称这一操作为“推进历史”</p><p>git log命令只能查看以当前状态为终点的历史日志。所以这里要使用gitreflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过git reset —hard命令恢复到回溯历史前的状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git reflog</span><br><span class="line">e690648 (HEAD -&gt; fix-B) HEAD@&#123;0&#125;: commit: fix-B change</span><br><span class="line">a071997 (master) HEAD@&#123;1&#125;: checkout: moving from master to fix-B</span><br><span class="line">a071997 (master) HEAD@&#123;2&#125;: reset: moving to a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">4c6d889 HEAD@&#123;3&#125;: checkout: moving from fix-B to master</span><br><span class="line">4c6d889 HEAD@&#123;4&#125;: checkout: moving from master to fix-B</span><br><span class="line">4c6d889 HEAD@&#123;5&#125;: merge feature-A: Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">a071997 (master) HEAD@&#123;6&#125;: checkout: moving from feature-A to master</span><br><span class="line">40d98e7 (feature-A) HEAD@&#123;7&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;8&#125;: checkout: moving from master to master</span><br><span class="line">a071997 (master) HEAD@&#123;9&#125;: checkout: moving from feature-A to master</span><br><span class="line">40d98e7 (feature-A) HEAD@&#123;10&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;11&#125;: checkout: moving from feature-A to master</span><br><span class="line">40d98e7 (feature-A) HEAD@&#123;12&#125;: commit: add to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;13&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;14&#125;: checkout: moving from feature-A to master</span><br><span class="line">a071997 (master) HEAD@&#123;15&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;16&#125;: commit: Add something new and delete something old</span><br><span class="line">02117ed HEAD@&#123;17&#125;: commit: file context changed.</span><br><span class="line">066eaf7 HEAD@&#123;18&#125;: commit (initial): First commit</span><br></pre></td></tr></table></figure><blockquote><p>在日志中，我们可以看到commit、checkout、reset、merge等Git命令的执行记录。只要不进行Git的GC（Garbage Collection，垃圾回收），就可以通过日志随意调取近期的历史状态，就像给时间机器指定一个时间点，在过去未来中自由穿梭一般。即便开发者错误执行了Git操作，基本也都可以利用git reflog命令恢复到原先的状态</p><p>恢复到回溯前的历史状态<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git reset --hard 4c6d889</span><br><span class="line">HEAD is now at 4c6d889 Merge branch &#x27;feature-A&#x27; into master</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>消除冲突</strong></p><p>现在只要合并fix-B分支，就可以得到我们想要的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git merge --no-ff fix-B</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict in README.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><blockquote><p>系统告诉我们README.md文件发生了冲突（Conflict）。系统在合并README.md文件时，feature-A分支更改的部分与本次想要合并的fix-B分支更改的部分发生了冲突。不解决冲突就无法完成合并，所以我们打开README.md文件解决这个冲突</p></blockquote><p><strong>提交解决后结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master|MERGING)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master|MERGING)</span><br><span class="line">$ git commit -m &quot;Fix conflict by LYJ&quot;</span><br><span class="line">[master 898df01] Fix conflict by LYJ</span><br></pre></td></tr></table></figure><ul><li>git commit —amend 修改提交信息</li></ul><blockquote><p>要修改上一条提交信息，可以使用git commit —amend命令。我们将上一条提交信息记为了”Fix conflict”，但它其实是fix-B分支的合并，解决合并时发生的冲突只是过程之一，这样标记实在不妥。于是，我们要修改这条提交信息</p><p>执行上述命令后再打开的编辑器中修改之前提交信息，之后保存文件并关闭编辑器</p></blockquote><ul><li>如果只是想修改上一次提交的代码内容，可以先修改代码文件，然后使用以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>其中<code>&lt;file&gt;</code>为要修改的文件名。这样就可以修改上一次提交的代码内容了。需要注意的是，如果已经将修改推送到远程仓库，不建议修改历史提交记录，以免引起其他人的代码混乱。</p><ul><li>4.合并至master分支</li></ul><blockquote><p>执行git log —graph命令，可以看到提交日志中的相应内容也已经被修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph</span><br><span class="line">*   commit a783495d5c1328df81c759b2c2521cae175d4ae6 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: 4c6d889 e690648</span><br><span class="line">| | Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| | Date:   Tue Feb 22 14:41:40 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |     Merge branch &#x27;fix-B&#x27;</span><br><span class="line">| |</span><br><span class="line">| * commit e6906488cc59494f376a0673f65d0da0dd260c97 (fix-B)</span><br><span class="line">| | Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| | Date:   Tue Feb 22 14:32:16 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |     fix-B change</span><br><span class="line">| |</span><br><span class="line">* |   commit 4c6d8896e9e288b21a36aa840f0c536d8154d683</span><br><span class="line">|\ \  Merge: a071997 40d98e7</span><br><span class="line">| |/  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">|/|   Date:   Tue Feb 22 14:12:18 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |       Merge branch &#x27;feature-A&#x27; into master</span><br><span class="line">| |</span><br><span class="line">| * commit 40d98e76c16be3748c4cc78d178049b579450e13 (feature-A)</span><br><span class="line">|/  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">|   Date:   Tue Feb 22 14:01:11 2022 +0800</span><br><span class="line">|</span><br><span class="line">|       add to feature-A</span><br><span class="line">|</span><br><span class="line">* commit a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:51:20 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     Add something new and delete something old</span><br><span class="line">|</span><br><span class="line">* commit 02117edd38575da4a4de7a40be083cef2e7883b2</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     file context changed.</span><br><span class="line">|</span><br><span class="line">|     I am trying to change this context of the README.md file</span><br><span class="line">|     changed by LYJ</span><br><span class="line">|</span><br><span class="line">* commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">  Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">      First commit</span><br></pre></td></tr></table></figure><h3 id="git-rebase-i-压缩历史"><a href="#git-rebase-i-压缩历史" class="headerlink" title="git rebase -i 压缩历史"></a>git rebase -i 压缩历史</h3><blockquote><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录</p><ul><li>1.创建feature-C分支</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b feature-C</span><br><span class="line">Switched to a new branch &#x27;feature-C&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>作为feature-C的功能实现，我们在README.md文件中添加一行文字，并且故意留下拼写错误，以便之后修正.<br>提交这部分内容。这个小小的变更就没必要先执行git add命令再执行git commit命令了，我们用git commit -am命令来一次完成这两步操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &quot;add feature-C&quot;</span><br><span class="line">[feature-C a6c2906] add feature-C</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><ul><li>2.修正拼写错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index e49ccca..8b79141 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -17,4 +17,4 @@ hello world...!</span><br><span class="line"></span><br><span class="line"> ---</span><br><span class="line"></span><br><span class="line">-- faeture-C</span><br><span class="line">+- feature-C</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>然后提交</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-C)</span><br><span class="line">$ git commit -am &quot;Fix typo&quot;</span><br><span class="line">[feature-C 508e161] Fix typo</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><blockquote><p>错字漏字等失误称作typo，所以我们将提交信息记为”Fix typo”。实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们</p><ul><li>3.更改历史</li></ul><p>将”Fix typo”修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><blockquote><p>用上述方式执行git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pickup a6c2906 add feature-C</span><br><span class="line">pickup 508e161 Fix typo</span><br><span class="line">---修改</span><br><span class="line">pickup a6c2906 add feature-C</span><br><span class="line">fixup 508e161 Fix typo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~2</span><br><span class="line">hint: Waiting for your editor to close the file...</span><br><span class="line">[main 2022-02-22T06:53:27.400Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:53:27.436Z] ExtensionHostStarterWorker created</span><br><span class="line">[main 2022-02-22T06:53:28.558Z] Starting extension host with pid 12816 (fork() took 51 ms).</span><br><span class="line">[main 2022-02-22T06:53:28.558Z] ExtensionHostStarterWorker.start() took 51 ms.</span><br><span class="line">[main 2022-02-22T06:53:57.413Z] update#setState checking for updates</span><br><span class="line">[main 2022-02-22T06:53:57.507Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:54:12.586Z] Extension host with pid 12816 exited with code: 0, signal: null.</span><br><span class="line">Successfully rebased and updated refs/heads/feature-C.</span><br></pre></td></tr></table></figure><blockquote><p>此时再查看日志会发现add feature-C的哈希值改变了，这样一来，Fix typo就从历史中被抹去，也就相当于Add feature-C中从来没有出现过拼写错误。这算是一种良性的历史改写</p></blockquote><p>4.修改上一次提交的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>执行上述命令后，会打开编辑器，并显示上一次提交时的提交信息。在编辑器中修改提交信息后保存并退出即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff feature-C</span><br><span class="line">hint: Waiting for your editor to close the file...</span><br><span class="line">[main 2022-02-22T06:59:46.546Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:59:46.575Z] ExtensionHostStarterWorker created</span><br><span class="line">[main 2022-02-22T06:59:47.640Z] Starting extension host with pid 15528 (fork() took 54 ms).</span><br><span class="line">[main 2022-02-22T06:59:47.640Z] ExtensionHostStarterWorker.start() took 55 ms.</span><br><span class="line">[main 2022-02-22T07:00:00.585Z] Waiting for extension host with pid 15528 to exit.</span><br><span class="line">[main 2022-02-22T07:00:00.585Z] Extension host with pid 15528 exited with code: 0, signal: null.</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md | 3 +++</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><h1 id="4、推送至远程仓库"><a href="#4、推送至远程仓库" class="headerlink" title="4、推送至远程仓库"></a>4、推送至远程仓库</h1><blockquote><p>前面三个部分都是针对本地单一仓库的操作，现在开始接触网络上的远程仓库</p><h3 id="1-git-remote-add-—添加远程仓库"><a href="#1-git-remote-add-—添加远程仓库" class="headerlink" title="1.git remote add —添加远程仓库"></a>1.git remote add —添加远程仓库</h3></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/git-tutorial.git</span><br></pre></td></tr></table></figure><h3 id="2-git-push-—推送至远程仓库"><a href="#2-git-push-—推送至远程仓库" class="headerlink" title="2.git push —推送至远程仓库"></a>2.git push —推送至远程仓库</h3><ul><li>推送至master分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>像这样执行git push命令，当前分支的内容就会被推送给远程仓库origin的master分支。-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream（上游）。添加了这个参数，将来运行git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从origin的master分支获取内容，省去了另外添加参数的麻烦</p><p>执行该操作后，当前本地仓库master分支的内容将会被推送到GitHub的远程仓库中</p></blockquote><ul><li>推送至master以外的分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin feature-D</span><br></pre></td></tr></table></figure><h1 id="5、从远程仓库获取"><a href="#5、从远程仓库获取" class="headerlink" title="5、从远程仓库获取"></a>5、从远程仓库获取</h1><h3 id="1-git-clone-—获取远程仓库"><a href="#1-git-clone-—获取远程仓库" class="headerlink" title="1.git clone —获取远程仓库"></a>1.git clone —获取远程仓库</h3><ul><li>获取远程仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:用户名/git-tutorial.git</span><br></pre></td></tr></table></figure><blockquote><p>执行git clone命令后我们会默认处于master分支下，同时系统会自动将origin设置成该远程仓库的标识符。也就是说，当前本地仓库的master分支与GitHub端远程仓库（origin）的master分支在内容上是完全相同的</p></blockquote><p><strong>用git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息</strong></p><ul><li>获取远程的feature-D分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-D origin/feature-D</span><br></pre></td></tr></table></figure><blockquote><p>-b参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了origin/feature-D，就是说以名为origin的仓库（这里指GitHub端的仓库）的feature-D分支为来源，在本地仓库中创建feature-D分支</p><ul><li>向本地的feature-D分支提交更改</li></ul><p>这里跟之前的一样</p><ul><li>推送feature-D分支</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote><p>从远程仓库获取feature-D分支，在本地仓库中提交更改，再将feature-D分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育feature-D分支，实现某些功能</p><h3 id="2-git-pull-—获取最新的远程仓库"><a href="#2-git-pull-—获取最新的远程仓库" class="headerlink" title="2.git pull —获取最新的远程仓库"></a>2.git pull —获取最新的远程仓库</h3><p>使用git pull命令，将本地的feature-D分支更新到最新状态。当前分支为feature-D分支</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin feature-D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux后台运行程序命令</title>
      <link href="/2023/02/01/Linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/01/Linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Linux/Unix</code>下,通常只有守护进程可在脱离终端的情况下能继续执行,而普通进程在关闭终端时会因收到<code>SIGHUP</code>信号(挂起信号)而退出。当终端退出后,由该终端启动的后台程序自动退出，像<code>xshell</code>等软件使用<code>ssh</code>协议进行远程连接时，实质上还是相当于在远程服务器上的终端，因此运行的普通进程会在退出终端时(包括<code>xshell</code>等软件)自动退出，但是可以使用一些方法来使进程后台运行(已运行的进程在退出终端后仍能继续运行)</p><p>这里介绍<code>nohup</code>、<code>&amp;</code>和<code>screen</code>三种方式</p></blockquote><h1 id="amp-命令"><a href="#amp-命令" class="headerlink" title="&amp;命令"></a><code>&amp;</code>命令</h1><ul><li><code>&amp;</code>的作用是让程序在当前终端继续运行而终端可以接着执行其他命令，即在当前终端未被关闭的情况下在后台运行</li></ul><blockquote><p><code>ctrl z</code> 挂起进程并放入后台<br><code>ctrl c</code> 结束进程<br><code>jobs</code> 显示当前暂停的进程<br><code>bg %N</code> 使第N个任务在后台运行(%前有空格)<br><code>fg %N</code> 使第N个任务在前台运行</p></blockquote><h1 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a><code>nohup</code>命令</h1><blockquote><p><code>nohup</code> 英文全称 <code>no hang up</code>（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p><p>该命令在默认情况下（非重定向时），会输出一个名叫 <code>nohup.out</code> 的文件到当前目录下，如果当前目录的 <code>nohup.out</code> 文件不可写，输出重定向到 <code>$HOME/nohup.out</code> 文件中</p><ul><li>语法格式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> Command [Arg...] [&amp;]</span><br></pre></td></tr></table></figure><code>Command</code>：要执行的命令。<br><code>Arg</code>：一些参数，可以指定输出文件。<br><code>&amp;</code>：让命令在后台执行，终端退出后命令仍旧执行<br>(实际测试不加<code>&amp;</code>退出终端也能执行，区别在于不加<code>&amp;</code>时终端会被该命令占用不能执行其他命令)</li></ul></blockquote><ul><li>例如后台执行程序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> ./run_program &amp;</span><br></pre></td></tr></table></figure></li><li>需要重定向输出文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> ./run_program &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><blockquote><p><code>2&gt;&amp;1</code> 解释：<br>将标准错误 <code>2</code> 重定向到标准输出 <code>&amp;1</code> ，标准输出 <code>&amp;1</code> 再被重定向输入到 <code>test.log</code> 文件中。</p><p>0 – stdin (standard input，标准输入)<br>1 – stdout (standard output，标准输出)<br>2 – stderr (standard error，标准错误输出)</p></blockquote></li></ul><h1 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a><code>screen</code>命令</h1><blockquote><p>通过<code>screen</code>，将执行的命令放到<code>screen</code>后台任务里，<code>screen</code>任务作为一个进程在服务器后台执行</p><p>一般情况下，只要没有人去<code>kill</code>你的<code>screen</code>任务进程，服务器也没有关机或重启操作，<code>screen</code>任务都会平稳运行</p></blockquote><ul><li>创建<code>screen</code>任务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S task</span><br></pre></td></tr></table></figure><blockquote><p>这种方式创建的是一个有名字的<code>screen</code>任务，任务名为<code>task</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen</span><br></pre></td></tr></table></figure><p>这种方式创建一个没有名字的<code>screen</code>任务</p></blockquote></li></ul><blockquote><p>执行以上两种命令的任意一种后就进入了<code>screen</code>的<code>shell</code>环境，此时执行的操作都是在该<code>shell</code>环境中运行的</p></blockquote><ul><li>查看已创建的<code>screen</code>任务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There is a screen on:</span><br><span class="line">11010.Minecraft(06/26/2022 12:52:06 PM)(Detached)</span><br><span class="line">1 Socket in /run/screen/S-root.</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>11010</code>就是该<code>screen</code>任务的<code>pid</code>，<code>detached</code>表示后台运行，而<code>Attached</code>表示正在终端中运行</p></blockquote></li></ul><blockquote><p>当<code>screen</code>的<code>shell</code>环境被进程占用而无法执行其他命令时，此时可以新开一个终端执行<code>screen -d pid</code>或<code>screen -d task</code>使其在后台运行，此时就能在原来的终端继续执行其他命令(其实可以直接关闭该终端，此时<code>scrren</code>中运行的进程仍然不受影响)</p></blockquote><ul><li><p>进入<code>screen</code>任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -r pid</span><br><span class="line">$ screen -r task</span><br></pre></td></tr></table></figure><blockquote><p>以上两种方式均可进入对应的<code>screen</code>任务，只不过分别是根据<code>pid</code>和任务名称进入该任务</p></blockquote></li><li><p>删除<code>screen</code>任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>进入<code>screen</code>任务后输入<code>exit</code>结束该任务</p></blockquote></li><li><p>结束进程</p></li></ul><p>根据对应进程<code>PID</code>使用如下命令结束：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 [PID]</span><br></pre></td></tr></table></figure></p><h3 id="这几种方式的对比"><a href="#这几种方式的对比" class="headerlink" title="这几种方式的对比"></a>这几种方式的对比</h3><ul><li><code>&amp;</code>只能在当前终端后台运行，终端退出后进程也会随之退出</li><li><code>nohup</code>则可以使进程在当前终端退出后也能接着运行</li><li><code>screen</code>跟<code>nohup</code>命令作用一样，但是某些进程使用<code>nohup</code>命令后台运行时可能无法正常工作，此时建议使用<code>screen</code>命令</li></ul><p>参考文章：<br><a href="https://www.runoob.com/linux/linux-comm-nohup.html">Linux nohup 命令</a></p><p><a href="https://blog.csdn.net/ZZQHELLO2018/article/details/109379425">Linux命令——后台运行（nohup 与 &amp;）</a></p><p><a href="https://blog.csdn.net/weixin_43557605/article/details/120265864">screen的使用方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台运行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile基础学习</title>
      <link href="/2022/12/28/Makefile%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/28/Makefile%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile基础学习"><a href="#Makefile基础学习" class="headerlink" title="Makefile基础学习"></a>Makefile基础学习</h1><blockquote><p><code>Makefile</code>：描述哪些文件需要编译、哪些文件需要重新编译的文件，使用<code>make</code>命令对工程进行编译</p><p>本篇文章参考《【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.7》的<code>3.3</code> <code>Makefile</code>基础部分</p></blockquote><h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h2><h3 id="1-1-代码"><a href="#1-1-代码" class="headerlink" title="1.1 代码"></a>1.1 代码</h3><ul><li><code>main.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calcu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,num;</span><br><span class="line"></span><br><span class="line">    input_int(&amp;a,&amp;b);</span><br><span class="line">    num=calcu(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d =%d\r\n&quot;</span>,a,b,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>input.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_int</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>calcu.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calcu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calcu</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>input.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INPUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_int</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_INPUT_H</span></span></span><br></pre></td></tr></table></figure><ul><li><code>calcu.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CALCU_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CALCU_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calcu</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_CALCU_H</span></span></span><br></pre></td></tr></table></figure><h3 id="1-2-编译运行"><a href="#1-2-编译运行" class="headerlink" title="1.2 编译运行"></a>1.2 编译运行</h3><ul><li><code>gcc</code>手动编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c calcu.c input.c -o main</span><br></pre></td></tr></table></figure><ul><li><code>Makefile</code>编译</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.o input.o calcu.o</span></span><br><span class="line">gcc -o main.o input.o calcu.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">gcc -c main.c</span><br><span class="line"><span class="section">input.o: input.c</span></span><br><span class="line">gcc -c input.c</span><br><span class="line"><span class="section">calcu.o: calcu.c</span></span><br><span class="line">gcc -c calcu.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>make</code>命令编译工程，<code>./main</code>执行可执行程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ ./main</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="二、Makefile语法"><a href="#二、Makefile语法" class="headerlink" title="二、Makefile语法"></a>二、Makefile语法</h2><h3 id="2-1-Makefile规则格式"><a href="#2-1-Makefile规则格式" class="headerlink" title="2.1 Makefile规则格式"></a>2.1 Makefile规则格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标...: 依赖文件集合...</span><br><span class="line">命令1</span><br><span class="line">命令2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p><code>make</code> 命令会为 <code>Makefile</code> 中的每个以 <code>TAB</code> 开始的命令创建一个 <code>Shell</code> 进程去执行</p></blockquote><ul><li>具体例子：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.o input.o calcu.o</span></span><br><span class="line">gcc -o main.o input.o calcu.o</span><br></pre></td></tr></table></figure><blockquote><p>这条规则的目标是 <code>main</code>，<code>`main.o、input.o、calcu.o</code> 是生成 <code>main</code> 的依赖文件，如果要更新目标 <code>main</code>，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表</p></blockquote><ul><li><code>1.2</code>中<code>Makefile</code>解释如下：</li></ul><blockquote><p>首先更新第一条规则中的 <code>main</code>，第一条规则的目标成为默认目标，只要默认目标更新了那么就认为<code>Makefile</code> 的工作完成。</p><p>在第一次编译的时候由于 <code>main</code> 还不存在，因此第一条规则会执行，第一条规则依赖于文件 <code>main.o input.o 、calcu.o</code>这个三个<code>.o</code> 文件，这三个<code>.o</code> 文件目前还都没有，因此必须先更新这三个文件。<code>make</code> 会查找以这三个<code>.o</code> 文件为目标的规则并执行。</p><p>以 <code>main.o</code>为例，发现更新 <code>main.o</code> 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为<code>gcc–c main.c</code>，不链接编译 <code>main.c</code>只是生成 <code>main.o</code>，其它两个<code>.o</code>文件同理。</p><p>最后一个规则目标是 <code>clean</code>，它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 <code>clean</code> 的话可以直接使用命令<code>make clean</code>，执行以后就会删除当前目录下所有的<code>.o</code>文件以及 <code>main</code>，因此 <code>clean</code> 的功能就是清理工程</p></blockquote><ul><li>综上，<code>Make</code>的执行过程如下：</li></ul><blockquote><p>1、<code>make</code> 命令会在当前目录下查找以 <code>Makefile</code>(<code>makefile</code> 其实也可以)命名的文件。</p><p>2、当找到 <code>Makefile</code> 文件以后就会按照 <code>Makefile</code> 中定义的规则去编译生成最终的目标文件。</p><p>3、当发现目标文件不存在，或者目标所依赖的文件比目标文件新(也就是最后修改时间比目标文件晚)的话就会执行后面的命令来更新目标</p></blockquote><h3 id="2-2-Makefile变量及赋值"><a href="#2-2-Makefile变量及赋值" class="headerlink" title="2.2 Makefile变量及赋值"></a>2.2 Makefile变量及赋值</h3><h4 id="2-2-1-变量"><a href="#2-2-1-变量" class="headerlink" title="2.2.1 变量"></a>2.2.1 变量</h4><blockquote><p><code>Makefile</code>变量都是字符串，类似于<code>C</code>语言中的宏</p><p>这里使用变量<code>objects</code>表示<code>main.o input.o calcu.o</code>，引用变量的方式是<code>$(变量名)</code>，这里就是<code>$(objects)</code>来使用变量<code>objects</code></p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;#&quot;号开头表示注释</span></span><br><span class="line"><span class="comment"># Makefile变量使用</span></span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o main <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-赋值"><a href="#2-2-2-赋值" class="headerlink" title="2.2.2 赋值"></a>2.2.2 赋值</h4><blockquote><p><code>Makefile</code>赋值符有<code>=</code>、<code>:=</code>、<code>?=</code>以及<code>+=</code>四种，只不过第四种是变量追加</p></blockquote><ul><li>赋值符<code>=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = lyj</span><br><span class="line">curname = <span class="variable">$(name)</span></span><br><span class="line">name = thee</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">@echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>Make</code> 在执行过程中会自动输出命令执行过程，使用<code>@</code>表示不输出命令执行过程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">print</span></span><br><span class="line"><span class="comment"># 输出：thee</span></span><br><span class="line"><span class="comment"># 不加@输出结果如下</span></span><br><span class="line"><span class="comment"># echo curname: thee</span></span><br><span class="line"><span class="comment"># curname: thee</span></span><br></pre></td></tr></table></figure><blockquote><p>这里输出<code>thee</code>而不是<code>lyj</code>的原因是该赋值符<code>=</code>表示被赋值变量<code>curname</code>会根据赋值变量<code>name</code>的改变而改变即<code>name</code>最终的值(变量真实值取决于它所引用变量最后一次有效值)</p></blockquote><ul><li>赋值符<code>:=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = lyj</span><br><span class="line">curname := <span class="variable">$(name)</span></span><br><span class="line">name = thee</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">@echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">print</span></span><br><span class="line"><span class="comment"># 输出：lyj</span></span><br></pre></td></tr></table></figure><blockquote><p>这里输出<code>lyj</code>是因为赋值符<code>:=</code>不会使用后面的定义的变量，只能使用前面已经定义好的(类似于<code>C</code>语言中变量的赋值，赋值结束后就不能更改了)</p></blockquote><ul><li>赋值符<code>?=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curname ?= jack</span><br></pre></td></tr></table></figure><blockquote><p>该赋值符<code>?=</code>表示如果变量 <code>curname</code> 前面没有被赋值，那么此变量就赋值为<code>jack</code>，否则该变量的值不变</p></blockquote><ul><li>变量追加<code>+=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = lyj</span><br><span class="line">name += thee</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">@echo name: <span class="variable">$(name)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line"><span class="comment"># 输出：lyj thee</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-Makefile模式规则"><a href="#2-2-3-Makefile模式规则" class="headerlink" title="2.2.3 Makefile模式规则"></a>2.2.3 Makefile模式规则</h4><ul><li><code>%</code>表示任意长度的非空字符串，类似于通配符，如<code>%.c</code>表示所有以<code>.c</code>结尾的文件</li></ul><h4 id="2-2-4-Makefile自动化变量"><a href="#2-2-4-Makefile自动化变量" class="headerlink" title="2.2.4 Makefile自动化变量"></a>2.2.4 Makefile自动化变量</h4><blockquote><p>自动化变量就是这种变量会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完</p></blockquote><ul><li>常用自动化变量(其中<code>$@/$&lt;/$^</code>较常用)</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">自动化变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>$@</code></td><td style="text-align:center">规则中的目标集合，在模式规则中，如果有多个目标的话，<code>$@</code>表示匹配模式中定义的目标集合</td></tr><tr><td style="text-align:center"><code>$%</code></td><td style="text-align:center">当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空</td></tr><tr><td style="text-align:center"><code>$&lt;</code></td><td style="text-align:center">依赖文件集合中的第一个文件，如果依赖文件是以模式(即<code>%</code>)定义的，那么<code>$&lt;</code>就是符合模式的一系列的文件集合</td></tr><tr><td style="text-align:center"><code>$?</code></td><td style="text-align:center">所有比目标新的依赖目标集合，以空格分开</td></tr><tr><td style="text-align:center"><code>$^</code></td><td style="text-align:center">所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，<code>$^</code>会去除重复的依赖文件，只保留一份</td></tr><tr><td style="text-align:center"><code>$+</code></td><td style="text-align:center">和<code>$^</code>类似，但是当依赖文件存在重复的话不会去除重复的依赖文件</td></tr><tr><td style="text-align:center"><code>$*</code></td><td style="text-align:center">这个变量表示目标模式中<code>%</code>及其之前的部分，如果目标是 <code>test/a.test.c</code>，目标模式为<code>a.%.c</code>，那么<code>$*</code>就是<code>test/a.test</code></td></tr></tbody></table></div><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o input.o calcu.o</span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o main <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c# 使用模式规则</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span><span class="comment"># 使用自动化变量</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><blockquote><p>这里使用模式规则和自动化变量将<code>1.2</code>中<code>Makefile</code>简化如上</p></blockquote><h4 id="2-2-5-Makefile伪目标"><a href="#2-2-5-Makefile伪目标" class="headerlink" title="2.2.5 Makefile伪目标"></a>2.2.5 Makefile伪目标</h4><blockquote><p><code>Makefile</code>中一般的目标名都是要生成的文件，而伪目标不代表真正的目标名，在执行 <code>make</code> 命令的时候通过指定这个伪目标来执行其所在规则的定义的命令</p><p>使用伪目标主要是为了避免 <code>Makefile</code> 中定义的执行命令的目标和工作目录下的实际文件出现名字冲突，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的</p><p>例如对于<code>clean</code>这个工程清理的代码，如果工作目录中存在<code>clean</code>的文件，此时执行<code>make clean</code>则会因为没有依赖文件而认定目标是最新的，后面的命令也不会执行，预先设想的清理功能也无法实现，为避免这个问题，将<code>clean</code>声明为伪目标，声明方式如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br></pre></td></tr></table></figure><p>这样不管当前工作目录是否存在名为<code>clean</code>的文件，执行<code>make clean</code>都会执行工程清理</p></blockquote><h4 id="2-2-6-Makefile条件判断"><a href="#2-2-6-Makefile条件判断" class="headerlink" title="2.2.6 Makefile条件判断"></a>2.2.6 Makefile条件判断</h4><ul><li>语法<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;条件关键字&gt;</span><br><span class="line">&lt;条件为真时执行的语句&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><ul><li>语法<code>2</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;条件关键字&gt;</span><br><span class="line">&lt;条件为真时执行的语句&gt;</span><br><span class="line">else</span><br><span class="line">&lt;条件为假时执行的语句&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><ul><li>条件关键词</li></ul><blockquote><p><code>ifeq/ifneq</code>、<code>ifdef/ifndef</code></p><ul><li><p><code>ifeq</code>使用方法(相同为真) 参数可以为函数返回值</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;参数 1&gt;, &lt;参数 2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;参数 1&gt;&#x27;,&#x27;&lt;参数 2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;参数 1&gt;&quot;</span>,<span class="string">&quot;&lt;参数 2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;参数 1&gt;&quot;</span>,&#x27;&lt;参数 2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;参数 1&gt;&#x27;,<span class="string">&quot;&lt;参数 2&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>ifneq</code>使用方法同<code>ifeq</code>(不相同为真)</p></li><li><p><code>ifdef</code>使用方法</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;变量名&gt;</span><br></pre></td></tr></table></figure><p>  如果”变量名”值非空，那么表达式为真，否则为假，”变量名”也可以是函数返回值</p></li><li><p><code>ifndef</code>使用方法同<code>ifdef</code>，但是含义与之相反</p></li></ul><blockquote><p>这里的<code>ifdef</code>和<code>ifndef</code>与<code>C</code>语言中含义类似</p></blockquote></blockquote><h4 id="2-2-7-Makefile函数使用"><a href="#2-2-7-Makefile函数使用" class="headerlink" title="2.2.7 Makefile函数使用"></a>2.2.7 Makefile函数使用</h4><blockquote><p><code>Makefile</code>支持函数，但无法自定义函数</p><p>函数用法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(函数名 参数集合)</span><br><span class="line"><span class="comment"># 或者是如下：</span></span><br><span class="line">$&#123;函数名 参数集合&#125;</span><br></pre></td></tr></table></figure><p>接下来是常用的几个函数</p></blockquote><ul><li><code>subst</code>函数：字符串替换</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 该函数功能是将字符串&lt;text&gt;中的&lt;from&gt;内容替换为&lt;to&gt;，返回被替换后的字符串</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> thee,lyj,hello thee!)</span></span><br><span class="line"><span class="comment"># 这里将thee替换为lyj,替换后的字符串为hello lyj!</span></span><br></pre></td></tr></table></figure><ul><li><code>patsubst</code>函数：模式字符串替换</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 此函数查找字符串&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配就用&lt;replacement&gt;来替换掉，&lt;pattern&gt;可以使用通配符&quot;%&quot;，表示任意长度的字符串，函数返回值就是替换后的字符串。如果&lt;replacement&gt;中也包涵&quot;%&quot;，那么&lt;replacement&gt;中的&quot;%&quot;将是&lt;pattern&gt;中的那个&quot;%&quot;所代表的字符串</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,a.c b.c c.c d.c)</span></span><br><span class="line"><span class="comment"># 这里将a.c b.c c.c d.c替换为a.o b.o c.o d.o</span></span><br></pre></td></tr></table></figure><ul><li><code>dir</code>函数：获取目录</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 此函数用来从文件名序列&lt;names&gt;中提取出目录部分，返回值是文件名序列&lt;names&gt;的目录部分</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;src/a.c&gt;)</span></span><br><span class="line"><span class="comment"># 返回目录部分即src/</span></span><br></pre></td></tr></table></figure><ul><li><code>notdir</code>函数：去除文件中的目录部分</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(notdir &lt;names...&gt;)</span><br><span class="line"># 此函数用与从文件名序列&lt;names&gt;中提取出文件名非目录部分</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;src/a.c&gt;)</span></span><br><span class="line"><span class="comment"># 返回非目录部分即a.c</span></span><br></pre></td></tr></table></figure><ul><li><code>foreach</code>函数：循环</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;所包含的表达式。每次&lt;text&gt;都会返回一个字符串，循环的过程中，&lt;text&gt;中所包含的每个字符串会以空格隔开，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串将会是函数 foreach 函数的返回值</span></span><br></pre></td></tr></table></figure><ul><li><code>wildcard</code>函数</li></ul><blockquote><p>通配符<code>%</code>只能用在规则中，只有在规则中它才会展开，如果在变量定义和函数使用时，通配符不会自动展开，这个时候就要用到函数 <code>wildcard</code>将其展开</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 获取当前目录所有.c文件，类似于%</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解C指针</title>
      <link href="/2022/12/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%E6%8C%87%E9%92%88/"/>
      <url>/2022/12/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章是《深入理解C指针》的阅读笔记。</p></blockquote><ul><li><code>printf</code>函数的格式</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">格式控制符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%d</td><td style="text-align:center">按照十进制整型数据实际长度输出</td></tr><tr><td style="text-align:center">%ld</td><td style="text-align:center">输出长整形数据</td></tr><tr><td style="text-align:center">%md</td><td style="text-align:center">m为指定输出字段宽度，如果数据位数小于m则左端补空格，否则按照实际位数输出</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">输出无符号整型数据，输出无符号整型也可以用 %d，这将无符号转换成有符号数，但没必要</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">输出一个字符</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">以小数形式输出单精度和双精度浮点数，不指定字段宽度由系统确定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入</td></tr><tr><td style="text-align:center">%.mf</td><td style="text-align:center">保留小数点后m位输出浮点数</td></tr><tr><td style="text-align:center">%o</td><td style="text-align:center">按照八进制整型数据输出</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">输出字符串</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">按照十六进制整型数据输出</td></tr></tbody></table></div><blockquote><p>%x、%X、%#x、%#X的区别</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">47</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#X\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="number">2f</span></span><br><span class="line"><span class="number">2F</span></span><br><span class="line"><span class="number">0x2f</span></span><br><span class="line"><span class="number">0X2F</span></span><br></pre></td></tr></table></figure><blockquote><p>输出<code>%d</code>、<code>\</code>和<code>&quot;&quot;</code></p><p>要输出<code>%d</code>只需在前面再加上一个<code>%</code>，要输出<code>\</code>只需在前面再加上一个<code>\</code>，要输出双引号也只需在前面加上一个<code>\</code>即可</p></blockquote><h2 id="1-3-指针操作符"><a href="#1-3-指针操作符" class="headerlink" title="1.3 指针操作符"></a>1.3 指针操作符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">无</td><td style="text-align:center">声明指针</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">解引</td><td style="text-align:center">解引指针</td></tr><tr><td style="text-align:center">-&gt;</td><td style="text-align:center">指向</td><td style="text-align:center">访问指针引用结构的字段</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">加</td><td style="text-align:center">对指针做加法</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减</td><td style="text-align:center">对指针做减法</td></tr><tr><td style="text-align:center">==/!=</td><td style="text-align:center">相等/不等于</td><td style="text-align:center">比较两个指针</td></tr><tr><td style="text-align:center">&gt;/&gt;=/&lt;/&lt;=</td><td style="text-align:center">大于/大于等于/小于/小于等于</td><td style="text-align:center">比较两个指针</td></tr><tr><td style="text-align:center">(数据转换)</td><td style="text-align:center">转换</td><td style="text-align:center">改变指针的类型</td></tr></tbody></table></div><h3 id="1-3-1-指针算术运算"><a href="#1-3-1-指针算术运算" class="headerlink" title="1.3.1 指针算术运算"></a>1.3.1 指针算术运算</h3><ul><li>指针加整数</li></ul><blockquote><p>实际上加这个整数和指针数据类型对应字节数的乘积，如<code>sizeof(int)*10</code></p><p>大部分编译器允许给<code>void</code>指针做算术运算，但可能导致语法错误</p></blockquote><ul><li>指针减整数</li></ul><blockquote><p>同指针加整数，实际上减去该整数和指针数据类型对应字节数乘积</p></blockquote><ul><li>指针相减</li></ul><blockquote><p>指针相减得到两个地址差值(整数1,2…)，通常用于判断数组中的元素顺序</p></blockquote><h3 id="1-3-2-比较指针"><a href="#1-3-2-比较指针" class="headerlink" title="1.3.2 比较指针"></a>1.3.2 比较指针</h3><blockquote><p>指针可以用标准的比较操作符来比较。通常比较结果可以用来判断数组元素的相对顺序</p></blockquote><h2 id="1-4-指针常见用法"><a href="#1-4-指针常见用法" class="headerlink" title="1.4 指针常见用法"></a>1.4 指针常见用法</h2><h3 id="1-4-1-多层间接引用"><a href="#1-4-1-多层间接引用" class="headerlink" title="1.4.1 多层间接引用"></a>1.4.1 多层间接引用</h3><blockquote><p>双重指针：指针的指针</p><p>使用多层间接引用可以为代码编写使用提供更多的灵活性</p><p>例子：<code>mian()</code>函数的<code>argv</code>和<code>argv</code>参数</p></blockquote><h3 id="1-4-2-常量与指针"><a href="#1-4-2-常量与指针" class="headerlink" title="1.4.2 常量与指针"></a>1.4.2 常量与指针</h3><ul><li>指向常量的指针</li></ul><blockquote><p>定义指向常量的指针<code>const int *p</code>意味着不能通过指针修改它所引用的值，但能访问该值和改变指针(指向另一个常量)</p></blockquote><ul><li>指向非常量的常量指针</li></ul><blockquote><p>定义指向非常量的常量指针<code>int *const p</code>意味着不能改变指针，但能修改它指向的数据</p></blockquote><ul><li>指向常量的常量指针</li></ul><blockquote><p><code>const int *const p</code>，很少使用，该指针本身不能修改，指向的数据也不能通过它修改</p></blockquote><ul><li>指向”指向常量的常量指针”的指针</li></ul><blockquote><p><code>const int *const *p</code></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">指针类型</th><th style="text-align:center">指针是否可以修改</th><th style="text-align:center">指向的数据是否可以修改</th></tr></thead><tbody><tr><td style="text-align:center">指向非常量的指针</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">指向常量的指针</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">指向非常量的常量指针</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">指向常量的常量指针</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr></tbody></table></div><h1 id="第二章-C的动态内存管理"><a href="#第二章-C的动态内存管理" class="headerlink" title="第二章 C的动态内存管理"></a>第二章 C的动态内存管理</h1><blockquote><p>动态内存管理：使用分配和释放函数手动实现</p></blockquote><h2 id="2-1-动态内存分配"><a href="#2-1-动态内存分配" class="headerlink" title="2.1 动态内存分配"></a>2.1 动态内存分配</h2><h3 id="1-C中动态分配内存基本步骤"><a href="#1-C中动态分配内存基本步骤" class="headerlink" title="1.C中动态分配内存基本步骤"></a>1.<code>C</code>中动态分配内存基本步骤</h3><blockquote><p>1.用malloc类的函数分配内存</p><blockquote><p>malloc函数的参数指定要分配的字节数。如果成功，它会返回从堆上分配的内存的指针；如果失败则会返回空指针</p></blockquote><p>2.用这些内存支持应用程序</p><p>3.用free函数释放内存</p></blockquote><h3 id="2-内存泄露"><a href="#2-内存泄露" class="headerlink" title="2.内存泄露"></a>2.内存泄露</h3><blockquote><p>如果不再使用已分配的内存却未将其释放就会发生内存泄漏，导致内存泄漏的情况可能如下：</p><ul><li>丢失内存地址</li><li>应该调用<code>free</code>函数却没调用(隐式泄露)</li></ul></blockquote><h2 id="2-2-动态内存分配函数"><a href="#2-2-动态内存分配函数" class="headerlink" title="2.2 动态内存分配函数"></a>2.2 动态内存分配函数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">malloc</td><td style="text-align:center">从堆上分配内存</td></tr><tr><td style="text-align:center">realloc</td><td style="text-align:center">在之前分配的内存块的基础上，将内存重新分配为更大或者更小的部分</td></tr><tr><td style="text-align:center">calloc</td><td style="text-align:center">从堆上分配内存并清零</td></tr><tr><td style="text-align:center">free</td><td style="text-align:center">将内存块返回堆(释放内存)</td></tr></tbody></table></div><h3 id="2-2-1-malloc函数"><a href="#2-2-1-malloc函数" class="headerlink" title="2.2.1 malloc函数"></a>2.2.1 malloc函数</h3><blockquote><p>malloc函数从堆上分配一块内存，所分配的字节数由该函数唯一的参数指定，返回值是void指针，如果内存不足，就会返回NULL。此函数不会清空或者修改内存，所以我们认为新分配的内存包含垃圾数据</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>传递参数给这个函数时要小心，因为如果参数是负数就会引发问题。在有些系统中，参数是负数会返回NULL。如果malloc的参数是0，其行为是实现相关的：可能返回NULL指针，也可能返回一个指向分配了0字节区域的指针。如果malloc函数的参数是NULL，那么一般会生成一个警告然后返回0字节</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> *pi=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(pi!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//指针没有问题，执行后续操作</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//无效指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要不要强制类型转换</li></ul><blockquote><p>C引入void指针之前，在两种互不兼容的指针类型之间赋值需要对malloc使用显式转换类型以避免产生警告。因为可以将void指针赋值给其他任何指针类型，所以不再需要显式类型转换了</p><p>如果没有引用malloc的头文件，类型转换可能会有问题，编译器可能会产生警告。C默认函数返回整数，如果没有引用malloc的原型，编译器会抱怨你试图把int赋值给指针</p></blockquote><ul><li>分配内存失败</li></ul><blockquote><p>如果声明了一个指针，但没有在使用之前为它指向的地址分配内存，那么内存通常会包含垃圾，这往往会导致一个无效内存引用的错误</p></blockquote><ul><li>没有给malloc传递正确参数</li></ul><blockquote><p>malloc函数分配的字节数是由它的参数指定的，在用这个函数分配正确的字节数时要小心</p></blockquote><ul><li>确认分配的内存数</li></ul><blockquote><p>malloc可分配的最大内存是跟系统相关的，看起来这个大小由size_t限制。不过这个限制可能受可用的物理内存和操作系统的其他限制所影响。</p><p>执行malloc时应该分配所请求数量的内存然后返回内存地址。如果操作系统采用“惰性初始化”策略直到访问内存才真正分配的话会怎样？这时候万一没有足够的内存用来分配就会有问题，答案取决于运行时和操作系统。开发者一般不需要处理这个问题，因为这种初始化策略非常罕见</p></blockquote><ul><li>静态、全局指针和malloc</li></ul><blockquote><ul><li>初始化静态或局部变量时不能调用函数进行初始化</li></ul><blockquote><p>对于静态变量，可以通过在后面用一个单独的语句给变量分配内存来避免这个问题。但是全局变量不能用单独的赋值语句，因为全局变量是在函数和可执行代码外部声明的，赋值语句这类代码必须出现在函数中</p></blockquote></blockquote><h3 id="2-2-2-calloc函数"><a href="#2-2-2-calloc函数" class="headerlink" title="2.2.2 calloc函数"></a>2.2.2 calloc函数</h3><blockquote><p>calloc会在分配内存的同时清空内存即将内容置为0</p><p>calloc函数会根据numElements和elementSize两个参数的乘积来分配内存，并返回一个指向内存的第一个字节的指针。如果不能分配内存，则会返回NULL。此函数最初用来辅助分配数组内存</p><p>如果numElements或elementSize为0，那么calloc可能返回空指针。如果calloc无法分配内存就会返回空指针，而且全局变量errno会设置为ENOMEM（内存不足），这是POSIX错误码，有的系统上可能没有</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> numElements,<span class="type">size_t</span> elementSize)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-recalloc函数"><a href="#2-2-3-recalloc函数" class="headerlink" title="2.2.3 recalloc函数"></a>2.2.3 recalloc函数</h3><blockquote><p>我们可能需要时不时地增加或减少为指针分配的内存，如果需要一个变长数组这种做法尤其有用，realloc函数会重新分配内存并释放掉原来旧的内存</p><p>realloc函数返回指向内存块的指针。该函数接受两个参数，第一个参数是指向原内存块的指针，第二个是请求的大小。重新分配的块大小和第一个参数引用的块大小不同。返回值是指向重新分配的内存的指针</p><p>请求的大小可以比当前分配的字节数小或者大。如果比当前分配的小，那么多余的内存会还给堆，不能保证多余的内存会被清空。如果比当前分配的大，那么可能的话，就在紧挨着当前分配内存的区域分配新的内存，否则就会在堆的其他区域分配并把旧的内存复制到新区域。</p><p>如果大小是0而指针非空，那么就释放内存。如果无法分配空间，那么原来的内存块就保持不变，不过返回的指针是空指针，且errno会设置为ENOMEM</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">recalloc</span><span class="params">(<span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">第一个参数</th><th style="text-align:center">第二个参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">空</td><td style="text-align:center">无</td><td style="text-align:center">同malloc</td></tr><tr><td style="text-align:center">非空</td><td style="text-align:center">0</td><td style="text-align:center">释放内存</td></tr><tr><td style="text-align:center">非空</td><td style="text-align:center">小于原内存</td><td style="text-align:center">利用当前块分配更小的块</td></tr><tr><td style="text-align:center">非空</td><td style="text-align:center">大于原内存</td><td style="text-align:center">在当前位置或其他位置分配更大的块</td></tr></tbody></table></div><h3 id="2-2-4-alloca函数和变长数组"><a href="#2-2-4-alloca函数和变长数组" class="headerlink" title="2.2.4 alloca函数和变长数组"></a>2.2.4 alloca函数和变长数组</h3><blockquote><p>alloca函数（微软为malloca）在函数的栈帧上分配内存。函数返回后会自动释放内存。若底层的运行时系统不基于栈，alloca函数会很难实现，所以这个函数是不标准的，如果应用程序需要可移植就尽量避免使用它</p><p>C99引入了变长数组（VLA），允许函数内部声明和创建其长度由变量决定的数组</p></blockquote><h2 id="2-3-使用free函数释放内存"><a href="#2-3-使用free函数释放内存" class="headerlink" title="2.3 使用free函数释放内存"></a>2.3 使用free函数释放内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>指针参数应该指向由malloc类函数分配的内存的地址，这块内存会被返还给堆。尽管指针仍然指向这块区域，但是我们应该将它看成指向垃圾数据。稍后可能重新分配这块区域，并将其装进不同的数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><blockquote><p>内存释放后仍然有可能包含原值，pi变量仍然指向之前的地址，这种情况称为迷途指针</p><p>如果传递给free函数的参数是空指针，通常它什么都不做。如果传入的指针所指向的内存不是由malloc类的函数分配，那么该函数的行为将是未定义的</p></blockquote><h3 id="2-3-1-将释放的指针赋值为NULL"><a href="#2-3-1-将释放的指针赋值为NULL" class="headerlink" title="2.3.1 将释放的指针赋值为NULL"></a>2.3.1 将释放的指针赋值为NULL</h3><blockquote><p>已释放的指针仍然可能造成问题。如果我们试图解引一个已释放的指针，其行为将是未定义的，因此调用free将指针赋值为NULL，该技术目的是解决迷途指针问题</p></blockquote><h3 id="2-3-2-重复释放"><a href="#2-3-2-重复释放" class="headerlink" title="2.3.2 重复释放"></a>2.3.2 重复释放</h3><blockquote><p>指两次释放同一块内存，这种情况是不应该出现的。</p></blockquote><h2 id="2-4-迷途指针"><a href="#2-4-迷途指针" class="headerlink" title="2.4 迷途指针"></a>2.4 迷途指针</h2><blockquote><p>内存已经释放而指针还在引用原始指针，这样的指针就是迷途指针，迷途指针没有指向有效对象，也被称为过早释放</p><p>使用迷途指针会造成一系列问题：</p><ul><li>如果访问内存，则行为不可预期；</li><li>如果内存不可访问，则是<strong>段错误</strong>；</li><li>潜在的安全隐患。</li></ul></blockquote><h3 id="2-4-1-迷途指针示例"><a href="#2-4-1-迷途指针示例" class="headerlink" title="2.4.1 迷途指针示例"></a>2.4.1 迷途指针示例</h3><ul><li>执行free函数后继续访问或修改该内存</li><li><p>一个以上指针同时指向同一内存区域而其中一个指针被释放，另外一个指针就是迷途指针</p></li><li><p>指针在块语句中赋值为局部变量地址，该块语句出栈后地址不在有效，此时指针就是迷途指针</p></li></ul><h3 id="2-4-2-处理迷途指针"><a href="#2-4-2-处理迷途指针" class="headerlink" title="2.4.2 处理迷途指针"></a>2.4.2 处理迷途指针</h3><ul><li>释放指针后置为NULL，后续使用这个指针会终止应用程序。不过，如果存在多个指针的话还是会有问题，因为赋值只会影响一个指针</li><li>写一个特殊的函数代替free函数</li><li>有些系统（运行时或调试系统）会在释放后覆写数据（比如0xDEADBEEF，取决于被释放的对象，Visual Studio会用0xCC、0xCD或者0xDD）。在不抛出异常的情况下，如果程序员在预期之外的地方看到这些值，可以认为程序可能在访问已释放的内存</li><li>用第三方工具检测迷途指针和其他问题</li></ul><h3 id="2-4-3-调试器对检测内存泄露的支持"><a href="#2-4-3-调试器对检测内存泄露的支持" class="headerlink" title="2.4.3 调试器对检测内存泄露的支持"></a>2.4.3 调试器对检测内存泄露的支持</h3><blockquote><p>微软提供解决动态内存分配的覆写和内存泄露的技术</p></blockquote><ul><li>检查堆的完整性；</li><li>检查内存泄漏；</li><li>模拟堆内存不够的情况</li></ul><blockquote><p>Mudflap库为GCC编译器提供了类似的功能，它的运行时库支持对内存泄漏的检测和其他功能，这种检测是通过监控指针解引操作来实现的。</p></blockquote><h2 id="2-5-动态内存分配技术"><a href="#2-5-动态内存分配技术" class="headerlink" title="2.5 动态内存分配技术"></a>2.5 动态内存分配技术</h2><h3 id="2-5-1-C的垃圾回收"><a href="#2-5-1-C的垃圾回收" class="headerlink" title="2.5.1 C的垃圾回收"></a>2.5.1 C的垃圾回收</h3><blockquote><p>malloc和free函数提供了手动分配和释放内存的方法。不过对于很多问题，需要考虑使用C的手动内存管理，比如性能、达到好的引用局部性、线程问题，以及优雅地清理内存。</p><p>有些非标准的技术可以用来解决部分问题，这些技术的关键特性在于自动释放内存。内存不再使用之后会被收集起来以备后续使用，释放的内存称为垃圾，因此，垃圾回收就是指这个过程</p></blockquote><h3 id="2-5-2-资源获取即初始化-RAII"><a href="#2-5-2-资源获取即初始化-RAII" class="headerlink" title="2.5.2 资源获取即初始化(RAII)"></a>2.5.2 资源获取即初始化(RAII)</h3><blockquote><p>由Bjarne Stroustrup发明，用于解决C++资源分配和释放。即使有异常发生，这种技术也能保证资源的初始化和后续的释放。分配的资源最终总是会得到释放</p></blockquote><h3 id="2-5-3-使用异常处理函数"><a href="#2-5-3-使用异常处理函数" class="headerlink" title="2.5.3 使用异常处理函数"></a>2.5.3 使用异常处理函数</h3><blockquote><p>尽管异常处理不属于标准C，但如果可以使用它且不考虑移植问题，它会很有用</p></blockquote><h1 id="第三章-指针和函数"><a href="#第三章-指针和函数" class="headerlink" title="第三章 指针和函数"></a>第三章 指针和函数</h1><h2 id="3-1-程序的栈和堆"><a href="#3-1-程序的栈和堆" class="headerlink" title="3.1 程序的栈和堆"></a>3.1 程序的栈和堆</h2><h3 id="3-1-1-程序栈"><a href="#3-1-1-程序栈" class="headerlink" title="3.1.1 程序栈"></a>3.1.1 程序栈</h3><blockquote><p>程序栈是支持函数执行的内存区域，通常和堆共享。也就是说，它们共享同一块内存区域。程序栈通常占据这块区域的下部，而堆用的则是上部。</p><p>程序栈存放<strong>栈帧</strong>（stack frame），栈帧有时候也称为<strong>活跃记录</strong>（activation record）或<strong>活跃帧</strong>（activation frame）。栈帧存放函数参数和局部变量。</p></blockquote><ul><li>调用函数时，函数的栈帧被推到栈上，栈向上“长出”一个栈帧。当函数终止时，其栈帧从程序栈上弹出。栈帧所使用的内存不会被清理，但最终可能会被推到程序栈上的另一个栈帧覆盖</li><li>动态分配的内存来自堆，堆向下“生长”。随着内存的分配和释放，堆中会布满碎片。尽管堆是向下生长的，但这只是个大体方向，实际上内存可能在堆上的任意位置分配</li></ul><h3 id="3-1-2-栈帧的组织"><a href="#3-1-2-栈帧的组织" class="headerlink" title="3.1.2 栈帧的组织"></a>3.1.2 栈帧的组织</h3><ul><li>返回地址：函数完成后要返回的程序内部地址</li><li>局部数据存储：为局部变量分配的内存</li><li>参数存储：为函数参数分配的内存</li><li>栈指针和基指针：运行时系统用来管理栈的指针</li></ul><blockquote><p>栈指针通常指向栈顶部。基指针（帧指针）通常存在并指向栈帧内部的地址，比如返回地址，用来协助访问栈帧内部的元素。这两个指针都不是C指针，它们是运行时系统管理程序栈的地址。如果运行时系统用C实现，这些指针倒真是C指针</p></blockquote><h2 id="3-2-通过指针传递和返回数据"><a href="#3-2-通过指针传递和返回数据" class="headerlink" title="3.2 通过指针传递和返回数据"></a>3.2 通过指针传递和返回数据</h2><h3 id="3-2-1-使用指针传递数据"><a href="#3-2-1-使用指针传递数据" class="headerlink" title="3.2.1 使用指针传递数据"></a>3.2.1 使用指针传递数据</h3><blockquote><p>使用指针来传递数据的一个主要原因是函数可以修改数据</p></blockquote><h3 id="3-2-2-使用值传递数据"><a href="#3-2-2-使用值传递数据" class="headerlink" title="3.2.2 使用值传递数据"></a>3.2.2 使用值传递数据</h3><h3 id="3-2-3-传递指向常量的指针"><a href="#3-2-3-传递指向常量的指针" class="headerlink" title="3.2.3 传递指向常量的指针"></a>3.2.3 传递指向常量的指针</h3><blockquote><p>传递指向常量的指针是C中常用的技术，效率很高，因为我们只传了数据的地址，能避免某些情况下复制大量内存。不过，如果只是传递指针，数据就能被修改。如果不希望数据被修改，就要传递指向常量的指针。</p></blockquote><h3 id="3-2-4-返回指针"><a href="#3-2-4-返回指针" class="headerlink" title="3.2.4 返回指针"></a>3.2.4 返回指针</h3><blockquote><p>返回指针很容易，只要返回的类型是某种数据类型的指针即可。从函数返回对象时经常用到以下两种技术：</p><ul><li>使用malloc在函数内部分配内存并返回其地址。调用者负责释放返回的内存。</li><li>传递一个对象给函数并让函数修改它。这样分配和释放对象的内存都是调用者的责任。</li></ul></blockquote><p>从函数返回指针时可能存在几个潜在的问题：</p><ul><li>返回未初始化的指针</li><li>返回指向无效地址的指针</li><li>返回局部变量的指针</li><li>返回指针但是没有释放内存</li></ul><h3 id="3-2-5-局部数据指针"><a href="#3-2-5-局部数据指针" class="headerlink" title="3.2.5 局部数据指针"></a>3.2.5 局部数据指针</h3><blockquote><p>比如说在函数中定义局部变量数据并返回该地址，此时返回的数据地址无效，因为函数的栈帧从占中弹出了</p></blockquote><h3 id="3-2-6-传递空指针"><a href="#3-2-6-传递空指针" class="headerlink" title="3.2.6 传递空指针"></a>3.2.6 传递空指针</h3><blockquote><p>使用if(arr!==NULL)来判断arr指针是否是空指针</p></blockquote><h3 id="3-2-7-传递指针的指针"><a href="#3-2-7-传递指针的指针" class="headerlink" title="3.2.7 传递指针的指针"></a>3.2.7 传递指针的指针</h3><blockquote><p>将指针传递给函数时，传递的是值。如果我们想修改原指针而不是指针的副本，就需要传递指针的指针</p></blockquote><h2 id="3-3-函数指针"><a href="#3-3-函数指针" class="headerlink" title="3.3 函数指针"></a>3.3 函数指针</h2><blockquote><p>函数指针是持有函数地址的指针，使用函数指针时要小心，因为C不会检查参数传递是否正确</p></blockquote><h3 id="3-3-1-声明函数指针"><a href="#3-3-1-声明函数指针" class="headerlink" title="3.3.1 声明函数指针"></a>3.3.1 声明函数指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*foo)();</span><br></pre></td></tr></table></figure><h3 id="3-3-2-使用函数指针"><a href="#3-3-2-使用函数指针" class="headerlink" title="3.3.2 使用函数指针"></a>3.3.2 使用函数指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num*num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fptr=square;</span><br><span class="line"><span class="comment">//ftpr=&amp;square;//作用同上，在这种上下文环境中编译器会忽略取地址操作符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5 square is %d\n&quot;</span>,fptr(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><blockquote><p>为函数指针声明类型定义比较方便，类型定义看起来有点奇怪，通常类型定义的名字是声明的最后一个元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*funcptr)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">...</span><br><span class="line">funcptr fptr2;</span><br><span class="line">fptr2=square;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;8 square is %d\n&quot;</span>,fptr2(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-3-传递函数指针"><a href="#3-3-3-传递函数指针" class="headerlink" title="3.3.3 传递函数指针"></a>3.3.3 传递函数指针</h3><blockquote><p>传递函数指针很简单，只要把函数指针声明作为函数参数即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fptrOperation)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compute</span><span class="params">(fptrOperation operation, <span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> operation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,compute(add,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,compute(sub,<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-4-返回函数指针"><a href="#3-3-4-返回函数指针" class="headerlink" title="3.3.4 返回函数指针"></a>3.3.4 返回函数指针</h3><blockquote><p>返回函数指针需要把函数返回类型声明为函数指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fptrOperation <span class="title function_">select</span><span class="params">(<span class="type">char</span> opcode)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> add;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> subtract;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(<span class="type">char</span> opcode, <span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    fptrOperation operation = select(opcode);</span><br><span class="line">    <span class="keyword">return</span> operation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,evaluate(<span class="string">&#x27;+&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,evaluate(<span class="string">&#x27;-&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-5-使用函数指针数组"><a href="#3-3-5-使用函数指针数组" class="headerlink" title="3.3.5 使用函数指针数组"></a>3.3.5 使用函数指针数组</h3><blockquote><p>函数指针数组可以基于某些条件选择要执行的函数，声明这种数组很简单，只要把函数指针声明为数组的类型即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*operation)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">operation operations[<span class="number">128</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">---</span><br><span class="line"><span class="type">int</span> (*operations[<span class="number">128</span>])(<span class="type">int</span>, <span class="type">int</span>)=&#123;<span class="literal">NULL</span>&#125;;<span class="comment">//作用同上</span></span><br></pre></td></tr></table></figure><h3 id="3-3-6-比较函数指针"><a href="#3-3-6-比较函数指针" class="headerlink" title="3.3.6 比较函数指针"></a>3.3.6 比较函数指针</h3><blockquote><p>使用相等和不等操作符来比较函数指针</p></blockquote><h3 id="3-3-7-转换函数指针"><a href="#3-3-7-转换函数指针" class="headerlink" title="3.3.7 转换函数指针"></a>3.3.7 转换函数指针</h3><blockquote><p>我们可以将指向某个函数的指针转换为其他类型的指针，不过要谨慎使用，因为运行时系统不会验证函数指针所用的参数是否正确。也可以把一种函数指针转换为另一种再转换回来，得到的结果和原指针相同，但函数指针的长度不一定相等</p><p>无法保证函数指针和数据指针相互转换后正常工作</p><p>void<em>指针不一定能用在函数指针上，不过在交换函数指针时通常会见到`typedef void (</em>fptrBase)()`的”基本”函数指针类型(基本指针)，用做占位符，用来交换函数指针的值</p></blockquote><h1 id="第四章-指针和数组"><a href="#第四章-指针和数组" class="headerlink" title="第四章 指针和数组"></a>第四章 指针和数组</h1><blockquote><p>数组和指针表示法紧密关联，在合适的上下文中可以互换</p></blockquote><h2 id="4-1-数组概述"><a href="#4-1-数组概述" class="headerlink" title="4.1 数组概述"></a>4.1 数组概述</h2><blockquote><p>数组是能用索引访问的同质元素连续集合。这里所说的连续是指数组的元素在内存中是相邻的，中间不存在空隙，而同质是指元素都是同一类型的。数组声明用的是方括号集合，可以拥有多个维度。</p></blockquote><h3 id="4-1-1-一维数组"><a href="#4-1-1-一维数组" class="headerlink" title="4.1.1 一维数组"></a>4.1.1 一维数组</h3><blockquote><p>一维数组是线性结构，使用一个索引访问成员；数组索引从0开始到声明的长度减1结束</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">vector</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="4-1-2-二维数组"><a href="#4-1-2-二维数组" class="headerlink" title="4.1.2 二维数组"></a>4.1.2 二维数组</h3><blockquote><p>二维数组使用行和列来标识数组元素，这类数组需要映射为内存中的一维地址空间。在C中这是通过行–列顺序实现的。先将数组的第一行放进内存，接着是第二行、第三行，直到最后一行。</p><p>我们可以将二维数组当做数组的数组，也就是说，如果只用一个下标访问数组，得到的是对应行的指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>多维数组具有两个及两个以上维度。对于多维数组，需要多组括号来定义数组的类型和长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr3d[<span class="number">3</span>][<span class="number">2</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;,&#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-指针表示法和数组"><a href="#4-2-指针表示法和数组" class="headerlink" title="4.2 指针表示法和数组"></a>4.2 指针表示法和数组</h2><blockquote><p>指针在处理数组时很有用，我们可以用指针指向已有的数组，也可以从堆上分配内存然后把这块内存当做一个数组使用。数组表示法和指针表示法在某种意义上可以互换。不过，它们并不完全相同</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">vector</span>[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *pv=<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure><blockquote><p>pv变量是指向数组第一个元素而不是指向数组本身的指针。给pv赋值是把数组的第一个元素的地址赋给pv。</p><p>vector、&amp;vector[0]、pv三者的值相同，都表示数组第一个元素的地址，而&amp;vector表示数组的地址(整个数组的指针)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pv[i]</span><br><span class="line">*(pv+i)</span><br><span class="line"><span class="comment">//上面两者等价</span></span><br></pre></td></tr></table></figure><blockquote><p>pv指针包含一个内存块的地址，方括号表示法会取出pv中包含的地址，用指针算术运算把索引i加上，然后解引新地址返回其内容</p></blockquote><ul><li>数组和指针的差别</li></ul><blockquote><ul><li><p>vector[i]生成的代码和<em>(vector+i)生成的不一样，vector[i]表示法生成的机器码从位置vector开始，移动i个位置，取出内容。而</em>(vector+i)表示法生成的机器码则是从vector开始，在地址上增加i，然后取出这个地址中的内容</p></li><li><p>sizeof操作符对数组和同一个数组的指针操作也是不同的。对vector调用sizeof操作符会返回20，就是这个数组分配的字节数。对pv调用sizeof操作符会返回4，就是指针的长度</p></li><li><p>pv是一个左值，左值表示赋值操作符左边的符号。左值必须能修改。像vector这样的数组名字不是左值，它不能被修改。我们不能改变数组所持有的地址，但可以给指针赋一个新值从而引用不同的内存段</p></li></ul></blockquote><h2 id="4-3-使用malloc创建一维数组"><a href="#4-3-使用malloc创建一维数组" class="headerlink" title="4.3 使用malloc创建一维数组"></a>4.3 使用malloc创建一维数组</h2><blockquote><p>如果从堆上分配内存并把地址赋给一个指针，那就肯定可以对指针使用数组下标并把这块内存当成一个数组，不过用完记得释放内存</p></blockquote><h2 id="4-4-使用realloc调整数组长度"><a href="#4-4-使用realloc调整数组长度" class="headerlink" title="4.4 使用realloc调整数组长度"></a>4.4 使用realloc调整数组长度</h2><blockquote><p>用malloc创建的已有数组的长度可以通过realloc函数来调整。C99标准支持变长数组，有些情况下这种解决方案可能比使用realloc函数更好。如果没有使用C99标准，那就只能用realloc。此外，变长数组只能在函数内部声明，如果数组需要的生命周期比函数长，那也只使用realloc</p></blockquote><h2 id="4-5-传递一维数组"><a href="#4-5-传递一维数组" class="headerlink" title="4.5 传递一维数组"></a>4.5 传递一维数组</h2><blockquote><p>将一维数组作为参数传递给函数实际是通过值来传递数组的地址，这样信息传递就更高效，因为我们不需要传递整个数组，从而也就不需要在栈上分配内存。通常，这也意味着要传递数组长度，否则在函数看来，我们只有数组的地址而不知道其长度</p><p>可以使用两种表示法在函数声明中声明数组：数组表示法和指针表示法</p></blockquote><h3 id="4-5-1-使用数组表示法"><a href="#4-5-1-使用数组表示法" class="headerlink" title="4.5.1 使用数组表示法"></a>4.5.1 使用数组表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">displayArray</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,*(arr+i)); 作用同上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-使用指针表示法"><a href="#4-5-2-使用指针表示法" class="headerlink" title="4.5.2 使用指针表示法"></a>4.5.2 使用指针表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">displayArray</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,*(arr+i)); 作用同上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-使用指针的一维数组"><a href="#4-6-使用指针的一维数组" class="headerlink" title="4.6 使用指针的一维数组"></a>4.6 使用指针的一维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//表示地址</span></span><br><span class="line">*arr[i] = i;<span class="comment">//解引指针，得到该地址的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是等价的指针表示法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(arr+i)=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">**(arr+i)=i;</span><br></pre></td></tr></table></figure><blockquote><p>子表达式(arr+i)表示数组的第i个元素的地址，用子表达式*(arr+i)修改这个地址的内容(该内容其实也是地址)。在第一条语句中我们将已分配的内存赋给这个位置。对(arr+i)子表达式做两次解引（如第二条语句所示），会返回所分配内存的位置，然后我们把i赋给它</p></blockquote><h2 id="4-7-指针和多维数组"><a href="#4-7-指针和多维数组" class="headerlink" title="4.7 指针和多维数组"></a>4.7 指针和多维数组</h2><blockquote><p>可以将多维数组的一部分看做子数组。比如说，二维数组的每一行都可以当做一维数组。这种行为会对我们用指针处理多维数组有所影响</p></blockquote><p>二维数组表示法：</p><blockquote><p><code>arr[i][j]</code>的地址为<code>address of arr+(i*size of row)+(j*size of element)</code></p></blockquote><h2 id="4-8-传递多维数组"><a href="#4-8-传递多维数组" class="headerlink" title="4.8 传递多维数组"></a>4.8 传递多维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display2DArray</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>],<span class="type">int</span> rows)</span>;</span><br><span class="line">---</span><br><span class="line"><span class="type">void</span> <span class="title function_">display2DArray</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>],<span class="type">int</span> rows)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这两种写法都指明了数组的列数，这很有必要，因为编译器需要知道每行有几个元素。如果没有传递这个信息，编译器就无法计算想<code>arr[0][3]</code>这样的表达式</p><p>在第一种写法中，表达式<code>arr[]</code>是数组指针的一个隐式声明，而第二种写法中的<code>(*arr)</code>表达式则是指针的一个显式声明</p></blockquote><h2 id="4-9-动态分配二维数组"><a href="#4-9-动态分配二维数组" class="headerlink" title="4.9 动态分配二维数组"></a>4.9 动态分配二维数组</h2><blockquote><p>为二维数组动态分配内存涉及几个问题：（1）数组元素是否需要连续；（2）数组是否规则</p><p>通常声明的二维数组所分配的内存是连续的，不过，当我们用malloc这样的函数创建二维数组时，在内存分配上会有几种选择。由于我们可以将二维数组当做数组的数组，因而“内层”的数组没有理由一定要是连续的。如果对这种数组使用下标，数组的不连续对程序员是透明的。<strong>注意</strong>：连续性还会影响复制内存等其他操作，内存不连续就可能需要多次复制。</p></blockquote><h3 id="4-9-1-分配可能不连续的内存"><a href="#4-9-1-分配可能不连续的内存" class="headerlink" title="4.9.1 分配可能不连续的内存"></a>4.9.1 分配可能不连续的内存</h3><blockquote><p>下面的代码演示了如何创建一个内存可能不连续的二维数组。首先分配“外层”数组，然后分别用malloc语句为每一行分配，因此内存不一定连续，实际分配情况取决于堆管理器和堆的状态，也有可能是连续的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> columns = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **) <span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">matrix[i] = (<span class="type">int</span> *) <span class="built_in">malloc</span>(columns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-2-分配连续内存"><a href="#4-9-2-分配连续内存" class="headerlink" title="4.9.2 分配连续内存"></a>4.9.2 分配连续内存</h3><blockquote><p>第一种技术，第一个malloc分配了一个整数指针的数组，一个元素用来存储一行的指针，在for循环中，我们将第二个malloc所分配的内存的一部分赋值给第一个数组的每个元素</p><p>从技术上讲，第一个数组的内存可以和数组“体”的内存分开，为数组“体”分配的内存是连续的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> columns = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **) <span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">matrix[<span class="number">0</span>] = (<span class="type">int</span> *) <span class="built_in">malloc</span>(rows *columns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">matrix[i] = matrix[<span class="number">0</span>] + i *columns;</span><br></pre></td></tr></table></figure><blockquote><p>第二种技术，数组所需的所有内存是一次性分配的，后面的代码用到这个数组时不能使用下标，必须手动计算索引，每个元素被初始化为其索引的积。不能使用数组下标是因为我们丢失了允许编译器使用下标所需的“形态”信息</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *matrix = (<span class="type">int</span> *)<span class="built_in">malloc</span>(rows *columns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">    *(matrix + (i*columns) + j) = i*j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-不规则数组和指针"><a href="#4-10-不规则数组和指针" class="headerlink" title="4.10 不规则数组和指针"></a>4.10 不规则数组和指针</h2><blockquote><p>不规则数组是每一行的列数不一样的二维数组</p></blockquote><ul><li>复合字面量创建二维数组</li></ul><blockquote><p>复合字面量是一种C构造，前面看起来像类型转换操作，后面跟着花括号括起来的初始化列表</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">const</span> <span class="type">int</span>)&#123;<span class="number">100</span>&#125;</span><br><span class="line">(<span class="type">int</span>[<span class="number">3</span>])&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">---</span><br><span class="line"><span class="type">int</span> (*(arr[]))=&#123;</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这个数组有3行3列，将数组元素用数字0到8按行–列顺序初始化</p><p>下面使用3个复合字面量声明不规则数组(复合字面量在创建不规则数组时很有用)：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*(arr2[]))=&#123;</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="第五章-指针和字符串"><a href="#第五章-指针和字符串" class="headerlink" title="第五章 指针和字符串"></a>第五章 指针和字符串</h1><h2 id="5-1-字符串基础"><a href="#5-1-字符串基础" class="headerlink" title="5.1 字符串基础"></a>5.1 字符串基础</h2><blockquote><p>字符串是以ASCII字符NUL(即\0)结尾的字符序列。字符串通常存储在数组或者从堆上分配的内存中。不过，并非所有的字符数组都是字符串，字符数组可能没有NUL字符。字符数组也用来表示布尔值等小的整数单元，以节省内存空间</p></blockquote><ul><li>C中有两种类型的字符串</li></ul><blockquote><ul><li><p><strong>单字节字符串</strong></p><p>  由char数据类型组成的序列。 </p></li><li><p><strong>宽字符串</strong></p><p>  由wchar_t数据类型组成的序列</p></li></ul><p>wchar_t数据类型用来表示宽字符，要么是16位宽，要么是32位宽。这两种字符串都以NUL结尾。可以在string.h中找到单字节字符串函数，而在wchar.h中找到宽字符串函数。创建宽字符主要用来支持非拉丁字符集，对于支持外语的应用程序很有用</p></blockquote><ul><li>字符串的长度是字符串中除了NUL字符之外的字符数。为字符串分配内存时，要记得为所有的字符再加上NUL字符分配足够的空间。NULL和NUL不同。NULL用来表示特殊的指针，通常定义为((void*)0)，而NUL是一个char，定义为\0，两者不能混用。字符常量是单引号引起来的字符序列。字符常量通常由一个字符组成，也可以包含多个字符，比如转义字符</li></ul><h3 id="5-1-1-字符串声明"><a href="#5-1-1-字符串声明" class="headerlink" title="5.1.1 字符串声明"></a>5.1.1 字符串声明</h3><blockquote><p>声明字符串的方式有三种：字面量、字符数组和字符指针。字符串字面量是用双引号引起来的字符序列，常用来进行初始化。不要把字符串字面量和单引号引起来的字符搞混——后者是字符字面量。</p></blockquote><ul><li>字符数组声明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> header[<span class="number">32</span>];</span><br><span class="line"><span class="comment">//实际只能放31个字符，以NUL结尾</span></span><br></pre></td></tr></table></figure><ul><li>字符指针声明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *header;</span><br><span class="line"><span class="comment">//未指明字符串长度和位置(未初始化)</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-字符串字面量池"><a href="#5-1-2-字符串字面量池" class="headerlink" title="5.1.2 字符串字面量池"></a>5.1.2 字符串字面量池</h3><blockquote><ul><li><p>定义字面量时通常会将其分配在字面量池中，这个内存区域保存了组成字符串的字符序列。多次用到同一个字面量时，字面量池中通常只有一份副本。这样会减少应用程序占用的内存。通常认为字面量是不可变的，因此只有一份副本不会有什么问题。不过，认定只有一份副本或者字面量不可变不是一种好做法，大部分编译器有关闭字面量池的选项，一旦关闭，字面量可能生成多个副本，每个副本拥有自己的地址</p></li><li><p>字符串字面量一般分配在只读内存中，所以是不可变的。字符串字面量在哪里使用，或者它是全局、静态或局部的都无关紧要，从这个角度讲，字符串字面量不存在作用域的概念。</p></li></ul></blockquote><ul><li>字符串字面量不是常量的情况</li></ul><blockquote><p>大部分编译器中将字符串字面量看做常量，无法修改字符串。</p></blockquote><h3 id="5-1-3-字符串初始化"><a href="#5-1-3-字符串初始化" class="headerlink" title="5.1.3 字符串初始化"></a>5.1.3 字符串初始化</h3><blockquote><p>初始化字符串采用的方法取决于变量是被声明为字符数组还是字符指针，字符串所用的内存要么是数组要么是指针指向的一块内存。我们可以用字符串字面量或者一系列字符初始化字符串，或者从别的地方（比如说标准输入）得到字符</p></blockquote><h4 id="1-初始化char数组"><a href="#1-初始化char数组" class="headerlink" title="1.初始化char数组"></a>1.初始化char数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cahr header[]=<span class="string">&quot;Meadia Player&quot;</span>;<span class="comment">//初始化操作符初始化char数组</span></span><br><span class="line">---</span><br><span class="line"><span class="type">char</span> header[<span class="number">13</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(header,<span class="string">&quot;Meadia Player&quot;</span>);<span class="comment">//使用strcpy()函数初始化char数组</span></span><br></pre></td></tr></table></figure><h4 id="2-初始化char指针"><a href="#2-初始化char指针" class="headerlink" title="2.初始化char指针"></a>2.初始化char指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cahr *header=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Media Player&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(header,<span class="string">&quot;Media Player&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>在使用malloc()函数确定字符串长度时：</p><ul><li>记得算上终结符NUL(即\0)</li><li>不能使用sizeof操作符，而采用strlen()函数确定已有字符串长度</li></ul><p>试图用字符字面量来初始化char指针不会起作用。因为字符字面量是int类型，这其实是尝试把整数赋给字符指针。这样经常会造成应用程序在解引指针时终止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *prefix=<span class="string">&#x27;+&#x27;</span>;<span class="comment">//不合法</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="type">char</span> *prefix=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>);</span><br><span class="line">*prefix=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">*(prefix+<span class="number">1</span>)=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-从标准输入初始化字符串"><a href="#3-从标准输入初始化字符串" class="headerlink" title="3.从标准输入初始化字符串"></a>3.从标准输入初始化字符串</h4><blockquote><p>使用标准输入等外部源初始化字符串</p></blockquote><h4 id="4-字符串位置小结"><a href="#4-字符串位置小结" class="headerlink" title="4.字符串位置小结"></a>4.字符串位置小结</h4><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221126143436.png" alt=""></p><h2 id="5-2-标准字符串操作"><a href="#5-2-标准字符串操作" class="headerlink" title="5.2 标准字符串操作"></a>5.2 标准字符串操作</h2><h3 id="5-2-1-比较字符串"><a href="#5-2-1-比较字符串" class="headerlink" title="5.2.1 比较字符串"></a>5.2.1 比较字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">负数：按字典序(字母序)s1&lt;s2</span><br><span class="line">    <span class="number">0</span>：s1=s2</span><br><span class="line">   正数：按字典序(字母序)s1&gt;s2</span><br></pre></td></tr></table></figure><blockquote><p>要比较的两个字符串都以指向char常量的指针的形式传递，这让我们可以放心地使用这个函数，而不用担心传入的字符串被修改</p></blockquote><h3 id="5-2-2-赋值字符串"><a href="#5-2-2-赋值字符串" class="headerlink" title="5.2.2 赋值字符串"></a>5.2.2 赋值字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char *s1,const char *s2);</span><br></pre></td></tr></table></figure><blockquote><p>两个指针可以引用同一个字符串。两个指针引用同一个地址称为<strong>别名</strong>。尽管通常情况下这不是问题，但要知道，把一个指针赋值给另一个指针不会复制字符串，只是复制了字符串的地址</p></blockquote><h3 id="5-2-3-拼接字符串"><a href="#5-2-3-拼接字符串" class="headerlink" title="5.2.3 拼接字符串"></a>5.2.3 拼接字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *s1,const char *s2);</span><br></pre></td></tr></table></figure><blockquote><p>此函数把第二个字符串拼接到第一个的结尾，第二个字符串是以常量char指针的形式传递的。函数不会分配内存，这意味着第一个字符串必须足够长，能容纳拼接后的结果，否则函数可能会越界写入，导致不可预期的行为。函数的返回值的地址跟第一个参数的地址一样</p></blockquote><h2 id="5-3-传递字符串"><a href="#5-3-传递字符串" class="headerlink" title="5.3 传递字符串"></a>5.3 传递字符串</h2><h3 id="5-3-1-传递简单字符串"><a href="#5-3-1-传递简单字符串" class="headerlink" title="5.3.1 传递简单字符串"></a>5.3.1 传递简单字符串</h3><blockquote><p>取决于不同的字符串声明方式，有几种方法可以把字符串的地址传递给函数</p></blockquote><h3 id="5-3-2-传递字符常量的指针"><a href="#5-3-2-传递字符常量的指针" class="headerlink" title="5.3.2 传递字符常量的指针"></a>5.3.2 传递字符常量的指针</h3><blockquote><p>以字符常量指针的形式传递字符串指针是很常见也很有用的技术，这样可以用指针传递字符串，同时也能防止传递的字符串被修改</p></blockquote><h3 id="5-3-3-传递需要初始化的字符串"><a href="#5-3-3-传递需要初始化的字符串" class="headerlink" title="5.3.3 传递需要初始化的字符串"></a>5.3.3 传递需要初始化的字符串</h3><blockquote><ul><li>传递空缓冲区让函数填充后返回</li><li>函数动态分配缓冲区并返回</li></ul></blockquote><h3 id="5-3-4-给应用程序传递参数"><a href="#5-3-4-给应用程序传递参数" class="headerlink" title="5.3.4 给应用程序传递参数"></a>5.3.4 给应用程序传递参数</h3><blockquote><p>C用传统的argc和argv参数支持命令行参数。第一个参数argc，是一个指定传递的参数数量的整数。系统至少会传递一个参数，这个参数是可执行文件的名字。第二个参数argv，通常被看做字符串指针的一维数组，每个指针引用一个命令行参数</p></blockquote><h2 id="5-4-返回字符串"><a href="#5-4-返回字符串" class="headerlink" title="5.4 返回字符串"></a>5.4 返回字符串</h2><blockquote><p>函数返回字符串时，它返回的实际是字符串的地址。这里应该关注的主要问题是如何返回合法的地址，要做到这一点，可以返回以下三种对象之一的引用：</p><ul><li><p>字面量；</p></li><li><p>动态分配的内存；</p></li><li><p>本地字符串变量。</p></li></ul></blockquote><h3 id="5-4-1-返回字面量的地址"><a href="#5-4-1-返回字面量的地址" class="headerlink" title="5.4.1 返回字面量的地址"></a>5.4.1 返回字面量的地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello world!!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-返回动态分配内存的地址"><a href="#5-4-2-返回动态分配内存的地址" class="headerlink" title="5.4.2 返回动态分配内存的地址"></a>5.4.2 返回动态分配内存的地址</h3><blockquote><p>如果需要从函数返回字符串，可以在堆上分配字符串内存并返回其地址</p></blockquote><ul><li>返回局部字符串地址</li></ul><blockquote><p>返回局部字符串的地址可能会有问题，如果内存被别的栈帧覆写就会损坏，应该避免使用这种方法</p></blockquote><h2 id="5-5-函数指针和字符串"><a href="#5-5-函数指针和字符串" class="headerlink" title="5.5 函数指针和字符串"></a>5.5 函数指针和字符串</h2><blockquote><p>通过将函数传递给另一个函数对字符串进行灵活操作</p></blockquote><h1 id="第六章-指针和结构体"><a href="#第六章-指针和结构体" class="headerlink" title="第六章 指针和结构体"></a>第六章 指针和结构体</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><blockquote><p>声明C结构体的方式有多种，这里只介绍其中两种。</p><p>第一种使用struct关键字声明结构体。第二种使用类型定义结构体</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">person</span>&#123;</span></span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">person</span>&#123;</span></span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">&#125;Person;</span><br><span class="line">Person person;<span class="comment">//person实例声明</span></span><br><span class="line">person.name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Emily&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(person.name,<span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line">---</span><br><span class="line">Person *ptrPerson;</span><br><span class="line">ptrPerson=(Person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Person));</span><br><span class="line">ptrPerson-&gt;name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Emily&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ptrPerson-&gt;name,<span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">ptrPerson-&gt;age = <span class="number">23</span>;</span><br></pre></td></tr></table></figure><ul><li>为结构体分配内存</li></ul><blockquote><p>为结构体分配内存时，分配的内存大小至少是各个字段的长度和。不过，实际长度通常会大于这个和，因为结构体的各字段之间可能会有填充。某些数据类型需要对齐到特定边界就会产生填充。比如说，短整数通常对齐到能被2整除的地址上，而整数对齐到能被4整除的地址上</p><p>这些额外内存的分配意味着几个问题：</p><ul><li><p>要谨慎使用指针算术运算；</p></li><li><p>结构体数组的元素之间可能存在额外的内存</p></li></ul></blockquote><h2 id="6-2-结构体释放问题"><a href="#6-2-结构体释放问题" class="headerlink" title="6.2 结构体释放问题"></a>6.2 结构体释放问题</h2><blockquote><p>在为结构体分配内存时，运行时系统不会自动为结构体内部的指针分配内存。类似地，当结构体消失时，运行时系统也不会自动释放结构体内部的指针指向的内存</p><p>当我们声明含有指针类型变量的结构体或对其动态分配内存时，相应的指针会包含垃圾数据，需要对其分配内存并把地址赋给每个指针，务必记得最后要手动释放该指针以及动态分配内存的结构体的指针</p></blockquote><h2 id="6-3-避免malloc-free开销"><a href="#6-3-避免malloc-free开销" class="headerlink" title="6.3 避免malloc/free开销"></a>6.3 避免malloc/free开销</h2><blockquote><p>重复分配然后释放结构体会产生一些开销，可能导致巨大的性能瓶颈。解决这个问题的一种办法是为分配的结构体单独维护一个表。当用户不再需要某个结构体实例时，将其返回结构体池中。当我们需要某个实例时，从结构体池中获取一个对象。如果池中没有可用的元素，我们就动态分配一个实例。这种方法高效地维护一个结构体池，能按需使用和重复使用内存</p></blockquote><h2 id="6-4-使用指针支持数据结构"><a href="#6-4-使用指针支持数据结构" class="headerlink" title="6.4 使用指针支持数据结构"></a>6.4 使用指针支持数据结构</h2><blockquote><p>指针可以为简单或复杂的数据结构提供更多的灵活性。这些灵活性可能来自动态内存分配，也可能来自切换指针引用的便利性。内存无需像数组那样是连续的，只要总的内存大小对就可以</p></blockquote><h3 id="6-4-1-单链表"><a href="#6-4-1-单链表" class="headerlink" title="6.4.1 单链表"></a>6.4.1 单链表</h3><blockquote><p>链表是由一系列互相连接的节点组成的数据结构。通常会有一个节点称为<strong>头节点</strong>，其他节点顺序跟在头节点后面，最后一个节点称为<strong>尾节点</strong>。我们可以用指针轻松实现节点之间的连接，动态按需分配每个节点</p><p>链表有好几种类型，最简单的是单链表，一个节点到下一个节点只有一个连接，连接从头节点开始，到尾节点结束。循环链表没有尾节点，链表的最后一个节点又指向头节点。双链表用了两个链表，一个向前连接，一个向后连接，我们可以在两个方向上查找节点，这类链表更灵活，但是也更难实现</p></blockquote><h3 id="6-4-2-使用指针支持队列"><a href="#6-4-2-使用指针支持队列" class="headerlink" title="6.4.2 使用指针支持队列"></a>6.4.2 使用指针支持队列</h3><blockquote><p>队列是一种线性数据结构，行为类似排队。它通常支持两种主要操作：入队和出队。入队操作把元素添加到队列中，出队操作从队列中删除元素。一般来说，第一个添加到队列中的元素也是第一个离开队列的元素，这种行为被称为先进先出（FIFO）</p></blockquote><h3 id="6-4-3-使用指针支持栈"><a href="#6-4-3-使用指针支持栈" class="headerlink" title="6.4.3 使用指针支持栈"></a>6.4.3 使用指针支持栈</h3><blockquote><p>栈数据结构也是一种链表。对于栈，元素被推入栈顶，然后被弹出。当多个元素被推入和弹出时，栈的行为是先进后出（FILO）。第一个推入栈的元素最后一个弹出</p></blockquote><h3 id="6-4-4-使用指针支持树"><a href="#6-4-4-使用指针支持树" class="headerlink" title="6.4.4 使用指针支持树"></a>6.4.4 使用指针支持树</h3><blockquote><p>树是很有用的数据结构，它的名字源于元素之间的关系。通常，子节点连接到父节点，从整体上看就像一颗倒过来的树，根节点表示这种数据结构的开始元素。</p><p>树可以有任意数量的子节点，不过，二叉树比较常见，它的每个节点能有0个、1个或是2个子节点。子节点要么是左子节点，要么是右子节点。没有子节点的节点称为叶子节点，就跟树叶一样</p></blockquote><h1 id="第七章-安全问题和指针误用"><a href="#第七章-安全问题和指针误用" class="headerlink" title="第七章 安全问题和指针误用"></a>第七章 安全问题和指针误用</h1><blockquote><p><strong>地址空间布局随机化</strong>（Address Space Layout Randomization，ASLR）过程会把应用程序的数据区域随机放置在内存中，这些数据区域包括代码、栈和堆。随机放置这些区域导致攻击者更难预测内存的位置，从而更难利用它们。有些类型的攻击（比如说return-to-libc攻击），会覆写栈的一部分，然后把控制转移到这个区域。这个区域经常是共享C库libc。如果栈和libc的位置是未知的，这类攻击的成功率就会降低。</p><p>如果代码位于内存的不可执行区域，<strong>数据执行保护</strong>（Data Execution Prevention，DEP）技术会阻止执行这些代码。在有些类型的攻击中，恶意代码会覆写内存的某个区域，然后将控制转移到这个区域。如果这个区域（比如栈或是堆）的代码不可执行，那么恶意代码就无法执行了。这种技术可以用硬件实现，也可以用软件实现</p></blockquote><h2 id="7-1-指针的声明和初始化"><a href="#7-1-指针的声明和初始化" class="headerlink" title="7.1 指针的声明和初始化"></a>7.1 指针的声明和初始化</h2><h3 id="7-1-1-不恰当的指针声明"><a href="#7-1-1-不恰当的指针声明" class="headerlink" title="7.1.1 不恰当的指针声明"></a>7.1.1 不恰当的指针声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr1, ptr2;<span class="comment">//ptr1为int指针变量，ptr2为int变量</span></span><br><span class="line"><span class="type">int</span> *ptr1, *ptr2;<span class="comment">//ptr1和ptr2都是int指针变量</span></span><br><span class="line"><span class="type">int</span> *ptr1;<span class="comment">//每个变量声明独占一行更好</span></span><br><span class="line"><span class="type">int</span> *ptr2;</span><br></pre></td></tr></table></figure><blockquote><p>用类型定义代替宏定义是另一个好习惯。类型定义允许编译器检查作用域规则，而宏定义不一定会</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PINT int*</span></span><br><span class="line">PINT ptr1,ptr2;</span><br></pre></td></tr></table></figure><blockquote><p>这里定义效果同上，ptr1为int指针变量，ptr2为int变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PINT;</span><br><span class="line">PINT ptr1,ptr2;</span><br></pre></td></tr></table></figure><blockquote><p>这里ptr1和ptr2都是int指针变量</p></blockquote><h3 id="7-1-2-使用指针前未初始化"><a href="#7-1-2-使用指针前未初始化" class="headerlink" title="7.1.2 使用指针前未初始化"></a>7.1.2 使用指针前未初始化</h3><blockquote><p>在初始化指针之前就使用指针会导致运行时错误，有时候将这种指针称为<strong>野指针</strong></p></blockquote><h3 id="7-1-3-处理未初始化指针"><a href="#7-1-3-处理未初始化指针" class="headerlink" title="7.1.3 处理未初始化指针"></a>7.1.3 处理未初始化指针</h3><blockquote><p>以下三种方法用来处理未初始化指针</p><ul><li>总是使用NULL来初始化指针</li><li>使用assert函数<ul><li>如果assert()函数参数为真，那么什么都不会发生，如果表达式为假，程序会终止</li></ul></li><li>使用第三方工具</li></ul></blockquote><h2 id="7-2-指针的使用问题"><a href="#7-2-指针的使用问题" class="headerlink" title="7.2 指针的使用问题"></a>7.2 指针的使用问题</h2><blockquote><p>很多安全问题聚焦的是缓冲区溢出的概念，以下几种情况可能导致缓冲区溢出：</p><ul><li><p>访问数组元素时没有检查索引值；</p></li><li><p>对数组指针做指针算术运算时不够小心；</p></li><li><p>用gets这样的函数从标准输入读取字符串；</p></li><li><p>误用strcpy和strcat这样的函数</p></li></ul><p>如果缓冲区溢出发生在栈帧的元素上，就可能把栈帧的返回地址部分覆写为对同一时间创建的恶意代码的调用。函数返回时会将控制转移到恶意函数，该函数可以执行任何操作，只受限于当前用户的特权等级</p></blockquote><h3 id="7-2-1-测试NULL"><a href="#7-2-1-测试NULL" class="headerlink" title="7.2.1 测试NULL"></a>7.2.1 测试NULL</h3><blockquote><p>用malloc这类函数时一定要检查返回值，否则可能会导致程序非正常终止</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//malloc分配内存失败</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//进行后续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-错误使用解引操作"><a href="#7-2-2-错误使用解引操作" class="headerlink" title="7.2.2 错误使用解引操作"></a>7.2.2 错误使用解引操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">int *pi=&amp;num;</span><br><span class="line">---</span><br><span class="line">int num;</span><br><span class="line">int *pi;</span><br><span class="line">pi=&amp;num;</span><br><span class="line">---</span><br><span class="line">int num;</span><br><span class="line">int *pi;</span><br><span class="line">*pi=&amp;num;//错误，不能把地址赋值给int型变量</span><br></pre></td></tr></table></figure><h3 id="7-2-3-迷途指针"><a href="#7-2-3-迷途指针" class="headerlink" title="7.2.3 迷途指针"></a>7.2.3 迷途指针</h3><blockquote><p>释放指针后却仍然在引用原来的内存，就会产生迷途指针，这其内容可能已经改变。对这块内存进行写操作可能会损坏内存，而读操作则可能返回无效数据，这两种情况都可能导致程序终止</p></blockquote><h3 id="7-2-4-越过数组边界访问内存"><a href="#7-2-4-越过数组边界访问内存" class="headerlink" title="7.2.4 越过数组边界访问内存"></a>7.2.4 越过数组边界访问内存</h3><blockquote><p>没有什么可以阻止程序访问为数组分配空间以外的内存；使用下标计算的地址不会检查索引值</p></blockquote><h3 id="7-2-5-错误计算数组长度"><a href="#7-2-5-错误计算数组长度" class="headerlink" title="7.2.5 错误计算数组长度"></a>7.2.5 错误计算数组长度</h3><blockquote><p>将数组传递给函数时，一定要同时传递数组长度。这个信息帮助函数避免越过数组边界</p></blockquote><h3 id="7-2-6-错误使用sizeof操作符"><a href="#7-2-6-错误使用sizeof操作符" class="headerlink" title="7.2.6 错误使用sizeof操作符"></a>7.2.6 错误使用sizeof操作符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int buffer[20];</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(buffer));//80字节</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(buffer)/sizeof(int));20个</span><br></pre></td></tr></table></figure><h3 id="7-2-7-匹配指针类型"><a href="#7-2-7-匹配指针类型" class="headerlink" title="7.2.7 匹配指针类型"></a>7.2.7 匹配指针类型</h3><blockquote><p>最好使用合适的指针类型来存储数据！</p></blockquote><h3 id="7-2-8-有界指针"><a href="#7-2-8-有界指针" class="headerlink" title="7.2.8 有界指针"></a>7.2.8 有界指针</h3><blockquote><p><strong>有界指针</strong>是指指针的使用被限制在有效的区域内。C没有对这类指针提供直接支持，但可以显示确保这个限制得以执行。</p><ul><li>创建指针检验函数</li><li>使用ANSI-C和C++的边界模型检查工具CBMC</li></ul><p>C++中的智能指针提供了一种模仿指针同时支持边界检查的方法，不幸的是，C没有智能指针</p></blockquote><h3 id="7-2-9-字符串的安全问题"><a href="#7-2-9-字符串的安全问题" class="headerlink" title="7.2.9 字符串的安全问题"></a>7.2.9 字符串的安全问题</h3><blockquote><p>字符串相关的安全问题一般发生在越过字符串末尾写入的情况</p><p>如果使用strcpy和strcat这类字符串函数，稍不留神就会引发缓冲区溢出。strncpy和strncat函数可以对这种操作提供一些支持，它们的size_t参数指定要复制的字符的最大数量。不过，如果字符数量计算不正确，替代函数也容易出错</p></blockquote><ul><li>C11中（Annex K）加入了strcat_s和strcpy_s函数，如果发生缓冲区溢出，它们会返回错误，目前只有Microsoft Visual C++支持</li><li>还有scanf_s和wscanf_s函数可以用来防止缓冲区溢出</li></ul><blockquote><p>gets函数从标准输入读取一个字符串，并把字符保存在目标缓冲区中，它可能会越过缓冲区的声明长度写入。如果字符串太长的话，就会发生缓冲区溢出。</p></blockquote><h3 id="7-2-10-指针算术运算和结构体"><a href="#7-2-10-指针算术运算和结构体" class="headerlink" title="7.2.10 指针算术运算和结构体"></a>7.2.10 指针算术运算和结构体</h3><blockquote><p>我们应该只对数组使用指针算术运算，因为数组肯定分配在连续的内存块上，指针算术运算可以得到有效的偏移量。不过，不应该将它们用在结构体内，因为结构体的字段可能分配在不连续的内存区域，因为存在内存对齐的情况</p><p>即使结构体内的内存是连续的，用指针算术运算来访问结构体的字段也不是好做法</p></blockquote><h3 id="7-2-11-函数指针的问题"><a href="#7-2-11-函数指针的问题" class="headerlink" title="7.2.11 函数指针的问题"></a>7.2.11 函数指针的问题</h3><blockquote><p>函数和函数指针用来控制程序的执行顺序，但是它们可能会被误用，导致不可预期的行为</p><p>如果函数和函数指针的签名不同，不要把函数赋给函数指针，这样会导致未定义的行为</p><p>函数指针可以执行不同的函数，这取决于分配给它的地址</p></blockquote><h2 id="7-3-内存释放问题"><a href="#7-3-内存释放问题" class="headerlink" title="7.3 内存释放问题"></a>7.3 内存释放问题</h2><h3 id="7-3-1-重复释放"><a href="#7-3-1-重复释放" class="headerlink" title="7.3.1 重复释放"></a>7.3.1 重复释放</h3><blockquote><p>将同一块内存释放两次称为重复释放</p><p>避免这类问题的简单办法是释放指针后总是将其置为NULL，大部分堆管理器都会忽略后续对空指针的释放</p></blockquote><h3 id="7-3-2-清除敏感数据"><a href="#7-3-2-清除敏感数据" class="headerlink" title="7.3.2 清除敏感数据"></a>7.3.2 清除敏感数据</h3><blockquote><p>一旦不再需要内存中的敏感数据，马上进行覆写掉是个好主意。当应用程序终止后，大部分操作系统都不会把用到的内存清零或是执行别的操作。系统可能会将之前用过的空间分配给别的程序，那么它就能访问内存中的内容。覆写敏感数据后别的应用程序就难以从之前持有这部分数据的内存中获取有用的信息</p></blockquote><h2 id="7-4-使用静态分析工具"><a href="#7-4-使用静态分析工具" class="headerlink" title="7.4 使用静态分析工具"></a>7.4 使用静态分析工具</h2><blockquote><p>有很多静态分析工具可以检查指针的误用，此外，大部分编译器都有选项来监测本章提到的很多问题。比如说，GCC编译器的-Wall选项可以启用编译器警告</p></blockquote><h1 id="第八章-其他重要内容"><a href="#第八章-其他重要内容" class="headerlink" title="第八章 其他重要内容"></a>第八章 其他重要内容</h1><blockquote><p>本章将研究以下几个很指针相关的主题</p><ul><li>指针的类型转换；</li><li>访问硬件设备；</li><li>别名和强别名；</li><li>使用restrict关键字；</li><li>线程；</li><li>面向对象技术</li></ul><p>关于线程，我们对两个方面感兴趣：一是用指针在线程之间共享数据这个基本问题，二是如何用指针支持回调函数。一个操作可能会调用某函数来执行任务，如果实际被调用的函数发生了改变，我们就称之为回调函数。我们可以使用回调函数在线程之间通信</p><p>本章会讲到两种在C中支持面向对象类型的方法：第一种是用不透明指针，这种技术对用户隐藏了数据结构的实现细节；第二种技术说明如何在C中实现多态类型。</p></blockquote><h2 id="8-1-转换指针"><a href="#8-1-转换指针" class="headerlink" title="8.1 转换指针"></a>8.1 转换指针</h2><blockquote><p>类型转换是一种基本操作，跟指针结合使用时很有用。转换指针对我们大有帮助，原因包括：</p><ul><li>访问有特殊目的的地址；</li><li>分配一个地址来表示端口；</li><li>判断机器的字节序</li></ul><p>机器的字节序一般是指数据类型内部的字节顺序。两种常见的字节序是小字节序和大字节序。小字节序是指将低位字节存储在低地址中，而大字节序是指将高位字节存储在低地址中</p></blockquote><h3 id="8-1-1-访问特殊用途的地址"><a href="#8-1-1-访问特殊用途的地址" class="headerlink" title="8.1.1 访问特殊用途的地址"></a>8.1.1 访问特殊用途的地址</h3><blockquote><p>访问特殊用途的地址的需求一般发生在嵌入式系统上，嵌入式系统对应用程序的介入很少</p></blockquote><h3 id="8-1-2-访问端口"><a href="#8-1-2-访问端口" class="headerlink" title="8.1.2 访问端口"></a>8.1.2 访问端口</h3><blockquote><p>端口既是硬件概念，也是软件概念。服务器用软件端口指明它们要接收发给这台机器的某类消息。硬件端口通常是一个连接到外部设备的物理输入输出系统组件。程序通过读写硬件端口可以处理信息和命令</p><p>机器用十六进制地址表示端口，将数据作为无符号整数处理。volatile关键字修饰符表示可以在程序以外改变变量。比如说，外部设备可能会向端口写入数据，且可以独立于计算机的处理器执行这个写操作。出于优化目的，编译器有时候会临时使用缓存或是寄存器来持有内存中的值，如果外部的操作修改了这个内存位置，改动并不能反映到缓存或寄存器中。</p><p>用volatile关键字可以阻止运行时系统使用寄存器暂存端口值，每次访问端口都需要系统读写端口，而不是从寄存器中读取一个可能已经过期的值。我们不应该把所有变量都声明为volatile，因为这样会阻碍编译器进行所有类型的优化，用非volatile变量访问volatile内存不是个好主意，这么做会导致未定义的行为</p><p>之后应用程序可以通过解引端口指针来读写端口</p></blockquote><h3 id="8-1-3-使用DMA访问内存"><a href="#8-1-3-使用DMA访问内存" class="headerlink" title="8.1.3 使用DMA访问内存"></a>8.1.3 使用DMA访问内存</h3><blockquote><p>直接内存访问（Direct Memory Access，DMA）是一种辅助系统在内存和某些设备间传输数据的底层操作，它不属于ANSI C规范，但是操作系统通常提供对这种操作的支持。DMA操作一般与CPU并行进行，这样可以将CPU解放出来执行其他任务，从而得到更好的性能。</p><p>程序员先调用DMA函数，然后等待操作完成。通常，程序员会提供一个回调函数，当操作完成后，操作系统会调用回调函数，回调函数由函数指针指定</p></blockquote><h3 id="8-1-4-判断机器的字节序"><a href="#8-1-4-判断机器的字节序" class="headerlink" title="8.1.4 判断机器的字节序"></a>8.1.4 判断机器的字节序</h3><blockquote><p>我们可以使用类型转换操作来判断架构的字节序。<strong>字节序</strong>是指内存单元中字节的顺序，字节序一般分为<strong>小字节序</strong>和<strong>大字节序</strong></p></blockquote><h2 id="8-2-别名、强别名和restrict关键字"><a href="#8-2-别名、强别名和restrict关键字" class="headerlink" title="8.2 别名、强别名和restrict关键字"></a>8.2 别名、强别名和restrict关键字</h2><blockquote><p>如果两个指针引用同一内存地址，则其中一个指针是另一个指针的别名</p><p>当编译器为指针生成代码时，除非特别指定，它必须假设可能会存在别名。使用别名会对编译器生成代码有所限制，如果两个指针引用同一位置，那么任何一个都可能修改这个位置。当编译器生成读写这个位置的代码时，它就不能通过把值放入寄存器来优化性能。对于每次引用，它只能执行机器级别的加载和保存操作。频繁的加载/保存会很低效，在某些情况下，编译器还必须关心操作执行的顺序</p><p><strong>强别名</strong>是另一种别名，它不允许一种类型的指针成为另一种类型的指针的别名。强别名规则对符号或修饰符不起作用</p><p>不过，有些情况下，对同样的数据采用不同的表现形式也是有用的，为了避免别名问题，可以采用这几种技术：</p><ul><li>使用联合体</li><li>关闭强别名</li><li>使用char指针</li></ul><p>编译器总是假定char指针是任意对象的潜在别名，所以，大部分情况下可以安全地使用。不过，把其他数据类型的指针转换成char指针，再把char指针转换成其他数据类型的指针，则会导致未定义的行为，应该避免这么做</p></blockquote><h3 id="8-2-1-使用联合体以多种方式表示值"><a href="#8-2-1-使用联合体以多种方式表示值" class="headerlink" title="8.2.1 使用联合体以多种方式表示值"></a>8.2.1 使用联合体以多种方式表示值</h3><blockquote><p>C是类型语言，在声明变量时就得为其指定类型。可以存在不同类型的多个变量，有时候，可能需要把一种类型转换成另一种类型，这一般是通过类型转换实现的，不过也可以使用联合体。<strong>类型双关</strong>就是指这种绕开类型系统的技术。但如果转换涉及指针，可能会产生严重问题</p></blockquote><h3 id="8-2-2-强别名"><a href="#8-2-2-强别名" class="headerlink" title="8.2.2 强别名"></a>8.2.2 强别名</h3><blockquote><p>编译器不会强制使用强别名，它只会产生警告。编译器假设两个或更多不同类型的指针永远不会引用同一个对象，这也包括除名字外其他都相同的结构体的指针。有了强别名，编译器可以做某些类型的优化</p></blockquote><h3 id="8-2-3-使用restrict关键字"><a href="#8-2-3-使用restrict关键字" class="headerlink" title="8.2.3 使用restrict关键字"></a>8.2.3 使用restrict关键字</h3><blockquote><p>C编译器默认假设指针有别名，用restrict关键字可以在声明指针时告诉编译器这个指针没有别名，这样就允许编译器产生更高效的代码。很多情况下这是通过缓存指针实现的，不过要记住这只是个建议，编译器也可以选择不优化代码。如果用了别名，那么执行代码会导致未定义行为，编译器不会因为破坏强别名假设而提供任何警告信息</p></blockquote><h2 id="8-3-线程和指针"><a href="#8-3-线程和指针" class="headerlink" title="8.3 线程和指针"></a>8.3 线程和指针</h2><blockquote><p>线程之间共享数据会引发一些问题。常见的问题是数据损坏。线程可以写入对象，但可能时不时地被挂起，导致对象处于不一致的状态。之后另一个线程可能会在第一个线程继续写入之前读取对象，那么第二个线程就会使用无效的或损坏的数据</p></blockquote><h3 id="8-3-1-线程间共享指针"><a href="#8-3-1-线程间共享指针" class="headerlink" title="8.3.1 线程间共享指针"></a>8.3.1 线程间共享指针</h3><blockquote><p>两个或更多线程共享数据可能损坏数据。</p></blockquote><h3 id="8-3-2-使用函数指针支持回调"><a href="#8-3-2-使用函数指针支持回调" class="headerlink" title="8.3.2 使用函数指针支持回调"></a>8.3.2 使用函数指针支持回调</h3><blockquote><p>是如果一个线程的事件导致另一个线程的函数调用，就称为回调。将回调函数的指针传递给线程，而函数的某个事件会引发对回调函数的调用，这种方法在GUI应用程序中处理用户线程事件很有用</p></blockquote><h2 id="8-4-面向对象技术"><a href="#8-4-面向对象技术" class="headerlink" title="8.4 面向对象技术"></a>8.4 面向对象技术</h2><blockquote><p>C不支持面向对象编程，不过，借助不透明指针，我们也可以使用C封装数据以及支持某种程度的多态行为。我们可以隐藏数据结构的实现和支持函数，用户没有必要知道数据结构的实现细节，减少这些实现细节就可以降低应用程序的复杂度</p><p>多态行为可以帮助提高应用程序的可维护性。多态函数的行为取决于它执行的目标对象，这意味着我们可以更容易地为应用程序添加功能</p></blockquote><h3 id="8-4-1-创建和使用不透明指针"><a href="#8-4-1-创建和使用不透明指针" class="headerlink" title="8.4.1 创建和使用不透明指针"></a>8.4.1 创建和使用不透明指针</h3><blockquote><p>不透明指针用来在C中实现数据封装。一种方法是在头文件中声明不包含任何实现细节的结构体，然后在实现文件中定义与数据结构的特定实现配合使用的函数。数据结构的用户可以看到声明和函数原型，但是实现会被隐藏（在.c/.obj文件中）。</p></blockquote><h3 id="8-4-2-C中的多态"><a href="#8-4-2-C中的多态" class="headerlink" title="8.4.2 C中的多态"></a>8.4.2 C中的多态</h3><blockquote><p>C++这类面向对象语言的多态是建立在基类及派生类之间继承关系的基础上的。C不支持继承，所以我们得模拟结构体之间的继承</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C:数组指针与指针数组</title>
      <link href="/2022/11/13/C-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
      <url>/2022/11/13/C-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h1><h3 id="1-数组指针"><a href="#1-数组指针" class="headerlink" title="1.数组指针"></a>1.数组指针</h3><blockquote><p>即数组的指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;<span class="comment">//int型数组</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>];<span class="comment">//数组指针,指向包含三个int型数组的指针</span></span><br><span class="line"><span class="comment">//优先级: ()&gt;[]&gt;*</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;数组a的起始地址:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line"> &lt;&lt; <span class="string">&quot;数组b的起始地址:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">-----------</span><br><span class="line">数组a的起始地址:<span class="number">0x61fdfc</span> </span><br><span class="line">数组b的起始地址:<span class="number">0x61fdf0</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到数组a和数组b位于栈空间上，a的起始地址大于b</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;sizeof(p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;sizeof(*p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(*p) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">------------</span><br><span class="line"><span class="built_in">sizeof</span>(a)=<span class="number">12</span></span><br><span class="line"><span class="built_in">sizeof</span>(p)=<span class="number">8</span></span><br><span class="line"><span class="built_in">sizeof</span>(*p)=<span class="number">12</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cxxabi.h&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(a).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">*p type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">a type:<span class="type">int</span> [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>p</code>表示指向包含三个<code>int</code>型变量数组的<strong>指针</strong>，其存放的是==地址==，因此其占用空间大小根据机器是<code>32</code>位还是<code>64</code>位有所不同，我电脑是<code>64</code>位的，因此其占用空间为<code>8</code>字节。</p><p><code>*p</code>可以认为表示的是包含三个<code>int</code>型变量的<strong>数组</strong>，因此其占用空间为<code>3*4=12</code>字节，表示的就是整型数组<code>a</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;数组a地址:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;a[0]地址:&quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;a[1]地址:&quot;</span> &lt;&lt; &amp;a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;a[2]地址:&quot;</span> &lt;&lt; &amp;a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p =&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*p + 1 =&quot;</span> &lt;&lt; *p + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*p + 2 =&quot;</span> &lt;&lt; *p + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*p)=&quot;</span> &lt;&lt; *(*p) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*p + 1)=&quot;</span> &lt;&lt; *(*p + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*p + 2)=&quot;</span> &lt;&lt; *(*p + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------下面储存地址与数组无法对应-----------*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p =&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p + 1 =&quot;</span> &lt;&lt; p + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p + 1 =&quot;</span> &lt;&lt; p + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p =&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(p + 1)=&quot;</span> &lt;&lt; *(p + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(p + 2)=&quot;</span> &lt;&lt; *(p + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;**p =&quot;</span> &lt;&lt; **p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;**(p + 1)=&quot;</span> &lt;&lt; **(p + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;**(p + 2)=&quot;</span> &lt;&lt; **(p + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0]=&quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p[1]=&quot;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p[2]=&quot;</span> &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------结果----------------</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>)=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">数组a地址:<span class="number">0x61fdf0</span></span><br><span class="line">a[<span class="number">0</span>]地址:<span class="number">0x61fdf0</span></span><br><span class="line">a[<span class="number">1</span>]地址:<span class="number">0x61fdf4</span></span><br><span class="line">a[<span class="number">2</span>]地址:<span class="number">0x61fdf8</span></span><br><span class="line">*p =<span class="number">0x61fdf0</span></span><br><span class="line">*p + <span class="number">1</span> =<span class="number">0x61fdf4</span></span><br><span class="line">*p + <span class="number">2</span> =<span class="number">0x61fdf8</span></span><br><span class="line">*(*p)=<span class="number">4</span></span><br><span class="line">*(*p + <span class="number">1</span>)=<span class="number">5</span></span><br><span class="line">*(*p + <span class="number">2</span>)=<span class="number">6</span></span><br><span class="line"><span class="comment">/*--------下面储存地址与数组无法对应-----------*/</span></span><br><span class="line">p =<span class="number">0x61fdf0</span></span><br><span class="line">p + <span class="number">1</span> =<span class="number">0x61fdfc</span></span><br><span class="line">p + <span class="number">1</span> =<span class="number">0x61fe08</span></span><br><span class="line">*p =<span class="number">0x61fdf0</span></span><br><span class="line">*(p + <span class="number">1</span>)=<span class="number">0x61fdfc</span></span><br><span class="line">*(p + <span class="number">2</span>)=<span class="number">0x61fe08</span></span><br><span class="line">**p =<span class="number">4</span></span><br><span class="line">**(p + <span class="number">1</span>)=<span class="number">0</span></span><br><span class="line">**(p + <span class="number">2</span>)=<span class="number">6422000</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">0x61fdf0</span></span><br><span class="line">p[<span class="number">1</span>]=<span class="number">0x61fdfc</span></span><br><span class="line">p[<span class="number">2</span>]=<span class="number">0x61fe08</span></span><br></pre></td></tr></table></figure><blockquote><p><em>个人理解</em>：</p><ul><li><p><code>p</code>指向数组<code>a</code>的地址(首地址)即<code>a[0]</code>也即<code>4</code>的地址，<code>p+1</code>指向数组<code>c</code>的地址(首地址)即将该指针往后移动<code>length</code>字节，<code>length</code>为<code>p</code>指向数组的所有元素的字节数；这里我先定义数组<code>c</code>，再定义数组<code>a</code>使得<code>p+1</code>指向数组<code>c</code>(理论上可用<code>p+1</code>指针访问数组<code>c</code>，但实践中不能这样访问)</p></li><li><p><code>p</code>指向数组<code>a</code>的地址(<code>p</code>可以理解为指向二维数组的指针，但这里实际上指向一维数组)，<code>*p</code>指向数组<code>a</code>第一个元素的地址，<code>*p+1</code>指向数组<code>a</code>第二个元素的地址，<code>**p</code>则表示提领<code>*p</code>地址的元素值。</p><ul><li><p>对于二维数组<code>arr</code>来说，<code>p</code>指向数组<code>arr[0]</code>即<code>&#123;1,6,9,4&#125;</code>的地址，<code>p+1</code>指向数组<code>arr[1]</code>即<code>&#123;5,6,7,8&#125;</code>的地址，以此类推。</p></li><li><p><code>*p</code>表示长度为4的整型数组，直接输出<code>*p</code>即相当于输出其地址，使用<code>**p</code>提领该<code>*p</code>地址的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">p=arr;</span><br><span class="line">cout &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;arr[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">                            </span><br><span class="line">------------</span><br><span class="line"><span class="number">0x7ffc3814ec30</span> <span class="number">0x7ffc3814ec40</span> <span class="number">0x7ffc3814ec50</span></span><br><span class="line"><span class="number">0x7ffc3814ec30</span> <span class="number">0x7ffc3814ec40</span> <span class="number">0x7ffc3814ec50</span></span><br><span class="line">------------</span><br><span class="line">arr type:<span class="type">int</span> [<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line">arr[<span class="number">0</span>] type:<span class="type">int</span> [<span class="number">4</span>]</span><br><span class="line">&amp;arr[<span class="number">0</span>] type:<span class="built_in">int</span> (*) [<span class="number">4</span>]</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">4</span>]</span><br><span class="line">*p type:<span class="type">int</span> [<span class="number">4</span>]</span><br><span class="line">**p type:<span class="type">int</span></span><br></pre></td></tr></table></figure><ul><li>对于<code>arr[0]</code>和<code>&amp;arr[0]</code>来说，其类似于<code>*p</code>和<code>p</code>，因此直接输出两者值一样</li></ul></li></ul></li><li>由于<code>*p+n</code>可以代表数组<code>a</code>的元素的地址，n从0开始，因此使用<code>*p+1</code>和<code>*p+2</code>依次访问<code>a[1]</code>和<code>a[2]</code>的地址，使用<code>*(*p+1)即a[1]</code>和<code>*(*p+2)即a[2]</code>访问对应的数据。若此时<code>p</code>指向二维数组<code>arr</code>，则<code>p+1</code>指向数组<code>arr</code>第二行的首地址即<code>arr[1]</code>也即<code>&amp;arr[1]</code>，<code>*(p+1)</code>表示该数组第二行第一个元素地址，<code>*(p+1)+1</code>表示该数组第二行第二个元素地址，依次类推。</li></ul></blockquote><h5 id="对于二维整型数组array-i-j-来说，定义数组指针int-p-j-来指向该数组array即p-array，则有如下结论："><a href="#对于二维整型数组array-i-j-来说，定义数组指针int-p-j-来指向该数组array即p-array，则有如下结论：" class="headerlink" title="对于二维整型数组array[i][j]来说，定义数组指针int (*p)[j]来指向该数组array即p=array，则有如下结论："></a>对于二维整型数组<code>array[i][j]</code>来说，定义数组指针<code>int (*p)[j]</code>来指向该数组<code>array</code>即<code>p=array</code>，则有如下结论：</h5><ul><li><code>p</code>指向该数组第一行，<code>p+1</code>指向数组第二行，…，<code>p+k</code>指向数组第<code>k+1</code>行，依此类推；</li><li><code>*p</code>指向该数组第一行第一列元素，<code>*p+1</code>指向该数组第一行第二列元素，…，<code>*(p+k)+m</code>指向该数组第<code>k+1</code>行第<code>m+1</code>列元素</li><li><code>*p</code>表示该数组第一行第一列的元素即<code>array[0][0]</code>，<code>*(*p+1)</code>指向该数组第一行第二列的元素即<code>array[0][1]</code>，…，<code>*(*(p+k)+m)</code>表示该数组第<code>k+1</code>行第<code>m+1</code>列的元素即<code>array[k][m]</code></li></ul><h4 id="数组指针指向一-二维数组"><a href="#数组指针指向一-二维数组" class="headerlink" title="数组指针指向一/二维数组"></a>数组指针指向一/二维数组</h4><ul><li>一维数组赋值给数组指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">p=&amp;a;<span class="comment">//正确</span></span><br><span class="line">p=a;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">a type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">&amp;a type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>错误原因</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:<span class="number">66</span>:<span class="number">6</span>: error: cannot convert <span class="string">&#x27;int [3]&#x27;</span> to <span class="string">&#x27;int (*)[3]&#x27;</span> in assignment</span><br><span class="line">p = a;</span><br><span class="line">^</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>这是因为<code>&amp;a</code> 是指整个数组的首地址，而<code>a</code>是指数组首元素的首地址，虽然二者值相同的，但表示的意义不同。这里<code>p</code>是数组指针，指向整个数组。<code>p=&amp;a</code>等号两边的数据类型完全一致，而<code>p=a</code>等号两边的数据类型不一致，因此会提示错误信息。</p><p>==补充：<code>a</code>表示数组名称，<code>&amp;a</code>表示整个数组的首地址，类型为<code>int (*) [3]</code>，<code>a+1</code>表示数组的第二个元素地址，类型为<code>int*</code>，<code>&amp;a[0]</code>表示数组首元素地址，类型为<code>int*</code>，<code>a[0]</code>表示数组首元素值，类型为<code>int</code>==</p></blockquote></blockquote><ul><li>二维数组赋值给数组指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">p = arr;<span class="comment">//正确</span></span><br><span class="line">p = &amp;arr;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">arr type:<span class="type">int</span> [<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line">&amp;arr type:<span class="built_in">int</span> (*) [<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><p>错误原因</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array2.cpp:<span class="number">10</span>:<span class="number">6</span>: error: cannot convert ‘<span class="built_in">int</span> (*)[<span class="number">3</span>][<span class="number">4</span>]’ to ‘<span class="built_in">int</span> (*)[<span class="number">4</span>]’ in assignment</span><br><span class="line">   <span class="number">10</span> |  p = &amp;arr;</span><br><span class="line">      |      ^~~~</span><br><span class="line">      |      |</span><br><span class="line">      |      <span class="built_in">int</span> (*)[<span class="number">3</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>这里错误的原因同一维数组</p></blockquote></blockquote><h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h3><ul><li>存放一维数组元素的地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">4</span>];<span class="comment">//定义数组指针</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// p[0] = &amp;a[0];</span></span><br><span class="line"><span class="comment">// p[1] = &amp;a[1];</span></span><br><span class="line"><span class="comment">// p[2] = &amp;a[2];</span></span><br><span class="line"><span class="comment">// p[3] = &amp;a[3];</span></span><br><span class="line"><span class="comment">//等价于下面语句</span></span><br><span class="line">*p = &amp;a[<span class="number">0</span>];<span class="comment">//指针数组赋值</span></span><br><span class="line">*(p + <span class="number">1</span>) = &amp;a[<span class="number">1</span>];</span><br><span class="line">*(p + <span class="number">2</span>) = &amp;a[<span class="number">2</span>];</span><br><span class="line">*(p + <span class="number">3</span>) = &amp;a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><blockquote><p>这里给指针数组赋值不能只写<code>*p=&amp;a[0]</code>，否则后面利用它来访问数组的时候会出问题，因为没有把数组<code>a</code>的其他元素地址赋值给指针数组<code>p</code>的其他元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[0]=&quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[1]=&quot;</span> &lt;&lt; &amp;a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[2]=&quot;</span> &lt;&lt; &amp;a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[3]=&quot;</span> &lt;&lt; &amp;a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[0]=&quot;</span> &lt;&lt; &amp;p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[1]=&quot;</span> &lt;&lt; &amp;p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[2]=&quot;</span> &lt;&lt; &amp;p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[3]=&quot;</span> &lt;&lt; &amp;p[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0]=&quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[1]=&quot;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[2]=&quot;</span> &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[3]=&quot;</span> &lt;&lt; p[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+1)=&quot;</span> &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+2)=&quot;</span> &lt;&lt; *(p+<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+3)=&quot;</span> &lt;&lt; *(p+<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//-------other-----</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+1=&quot;</span> &lt;&lt; p+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+2=&quot;</span> &lt;&lt; p+<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+3=&quot;</span> &lt;&lt; p+<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line"><span class="comment">//p type:int* [4]</span></span><br><span class="line"><span class="comment">//*p type:int*</span></span><br><span class="line"><span class="comment">//sizeof(p)=32</span></span><br><span class="line"><span class="comment">//sizeof(*p)=8</span></span><br><span class="line">&amp;a[<span class="number">0</span>]=<span class="number">0x61fdd0</span></span><br><span class="line">&amp;a[<span class="number">1</span>]=<span class="number">0x61fdd4</span></span><br><span class="line">&amp;a[<span class="number">2</span>]=<span class="number">0x61fdd8</span></span><br><span class="line">&amp;a[<span class="number">3</span>]=<span class="number">0x61fddc</span></span><br><span class="line"></span><br><span class="line">&amp;p[<span class="number">0</span>]=<span class="number">0x61fde0</span></span><br><span class="line">&amp;p[<span class="number">1</span>]=<span class="number">0x61fde8</span></span><br><span class="line">&amp;p[<span class="number">2</span>]=<span class="number">0x61fdf0</span></span><br><span class="line">&amp;p[<span class="number">3</span>]=<span class="number">0x61fdf8</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">0x61fdd0</span></span><br><span class="line">p[<span class="number">1</span>]=<span class="number">0x61fdd4</span></span><br><span class="line">p[<span class="number">2</span>]=<span class="number">0x61fdd8</span></span><br><span class="line">p[<span class="number">3</span>]=<span class="number">0x61fddc</span></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line">*p=<span class="number">0x61fdd0</span></span><br><span class="line">*(p+<span class="number">1</span>)=<span class="number">0x61fdd4</span></span><br><span class="line">*(p+<span class="number">2</span>)=<span class="number">0x61fdd8</span></span><br><span class="line">*(p+<span class="number">3</span>)=<span class="number">0x61fddc</span></span><br><span class="line"><span class="comment">//---other-----</span></span><br><span class="line">p=<span class="number">0x61fde0</span></span><br><span class="line">p+<span class="number">1</span>=<span class="number">0x61fde8</span></span><br><span class="line">p+<span class="number">2</span>=<span class="number">0x61fdf0</span></span><br><span class="line">p+<span class="number">3</span>=<span class="number">0x61fdf8</span></span><br></pre></td></tr></table></figure><blockquote><p>这里<code>p</code>是指针数组，类型为<code>int* [4]</code>，其中存放的是一维数组<code>a</code>的各个元素的地址，<code>*p</code>是指针数组中的指针，类型为<code>int*</code>，其存放的是一维数组<code>a</code>中一个元素的地址。</p><p>对于指针数组<code>p</code>，<code>&amp;p[0]、&amp;p[1]、&amp;p[2]、&amp;p[3]</code>是指针数组<code>p</code>自身的地址，用于存放数组<code>a</code>的地址；<code>p[0]、p[1]、p[2]、p[3]</code>存放的是数组<code>a</code>的<code>&#123;1,2,3,4&#125;</code>对应元素的地址。</p><p>使用指针数组<code>p</code>来访问数组<code>a</code>时，<code>p[i]</code>和<code>*(p+i)</code>都是取数组<code>a</code>某个元素的地址，<code>*p[i]</code>和<code>*(*p+i)</code>都是取数组<code>a</code>某个元素的值。</p></blockquote><ul><li>存放二维数组元素的地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// p[0] = b[0];</span></span><br><span class="line"><span class="comment">// p[1] = b[1];</span></span><br><span class="line"><span class="comment">// p[2] = b[2];</span></span><br><span class="line"><span class="comment">// p[3] = b[3];</span></span><br><span class="line"><span class="comment">//等价于下面语句</span></span><br><span class="line">*p = b[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = b[<span class="number">1</span>];</span><br><span class="line">*(p + <span class="number">2</span>) = b[<span class="number">2</span>];</span><br><span class="line">*(p + <span class="number">3</span>) = b[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &amp;b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b+<span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b+<span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b+<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;b[1] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;b[<span class="number">1</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b[1] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(b[<span class="number">1</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b+1 type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(b+<span class="number">1</span>).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;**p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(**p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(p[<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="number">0x61fdd0</span> <span class="number">0x61fdd8</span> <span class="number">0x61fde0</span> <span class="number">0x61fde8</span></span><br><span class="line"><span class="number">0x61fdd0</span> <span class="number">0x61fdd8</span> <span class="number">0x61fde0</span> <span class="number">0x61fde8</span></span><br><span class="line"><span class="number">0x61fdd0</span> <span class="number">0x61fdd8</span> <span class="number">0x61fde0</span> <span class="number">0x61fde8</span></span><br><span class="line">&amp;b[<span class="number">1</span>] type:<span class="built_in">int</span> (*) [<span class="number">2</span>]</span><br><span class="line">b[<span class="number">1</span>] type:<span class="type">int</span> [<span class="number">2</span>]</span><br><span class="line">b+<span class="number">1</span> type:<span class="built_in">int</span> (*) [<span class="number">2</span>]</span><br><span class="line">p type:<span class="type">int</span>* [<span class="number">4</span>]</span><br><span class="line">*p type:<span class="type">int</span>*</span><br><span class="line">**p type:<span class="type">int</span></span><br><span class="line">p[<span class="number">0</span>] type:<span class="type">int</span>*</span><br></pre></td></tr></table></figure><blockquote><p>对于二维数组<code>b</code>，<code>b+1、b[1]、&amp;b[1]</code>的值都相同，但是其表示的意义不同；<code>b+i</code>和<code>&amp;b[i]</code>表示二维数组第<code>i+1</code>行数组(这里是一维数组)的首地址，<code>b[i]</code>表示二维数组第<code>i+1</code>行数组(一维数组)的第一个元素的首地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[0]=&quot;</span> &lt;&lt; &amp;p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[1]=&quot;</span> &lt;&lt; &amp;p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[2]=&quot;</span> &lt;&lt; &amp;p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[3]=&quot;</span> &lt;&lt; &amp;p[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+1=&quot;</span> &lt;&lt; p+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+2=&quot;</span> &lt;&lt; p+<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+3=&quot;</span> &lt;&lt; p+<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+1)=&quot;</span> &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+2)=&quot;</span> &lt;&lt; *(p+<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+3)=&quot;</span> &lt;&lt; *(p+<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*p)=&quot;</span> &lt;&lt; *(*p) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*p+1)=&quot;</span> &lt;&lt; *(*p + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*(p+1))=&quot;</span> &lt;&lt; *(*(p + <span class="number">1</span>)) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*(p+1)+1)=&quot;</span> &lt;&lt; *(*(p + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*(p+2))=&quot;</span> &lt;&lt; *(*(p + <span class="number">2</span>)) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*(p+2)+1)=&quot;</span> &lt;&lt; *(*(p + <span class="number">2</span>) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*(p+3))=&quot;</span> &lt;&lt; *(*(p + <span class="number">3</span>)) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*(p+3)+1)=&quot;</span> &lt;&lt; *(*(p + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">&amp;p[<span class="number">0</span>]=<span class="number">0x61fe00</span></span><br><span class="line">&amp;p[<span class="number">1</span>]=<span class="number">0x61fe08</span></span><br><span class="line">&amp;p[<span class="number">2</span>]=<span class="number">0x61fe10</span></span><br><span class="line">&amp;p[<span class="number">3</span>]=<span class="number">0x61fe18</span></span><br><span class="line">p=<span class="number">0x61fe00</span></span><br><span class="line">p+<span class="number">1</span>=<span class="number">0x61fe08</span></span><br><span class="line">p+<span class="number">2</span>=<span class="number">0x61fe10</span></span><br><span class="line">p+<span class="number">3</span>=<span class="number">0x61fe18</span></span><br><span class="line">*p=<span class="number">0x61fde0</span></span><br><span class="line">*(p+<span class="number">1</span>)=<span class="number">0x61fde8</span></span><br><span class="line">*(p+<span class="number">2</span>)=<span class="number">0x61fdf0</span></span><br><span class="line">*(p+<span class="number">3</span>)=<span class="number">0x61fdf8</span></span><br><span class="line">*(*p)=<span class="number">1</span> *(*p+<span class="number">1</span>)=<span class="number">3</span></span><br><span class="line">*(*(p+<span class="number">1</span>))=<span class="number">2</span> *(*(p+<span class="number">1</span>)+<span class="number">1</span>)=<span class="number">4</span></span><br><span class="line">*(*(p+<span class="number">2</span>))=<span class="number">5</span> *(*(p+<span class="number">2</span>)+<span class="number">1</span>)=<span class="number">7</span></span><br><span class="line">*(*(p+<span class="number">3</span>))=<span class="number">6</span> *(*(p+<span class="number">3</span>)+<span class="number">1</span>)=<span class="number">8</span></span><br></pre></td></tr></table></figure><blockquote><p>这里和数组指针访问二维数组基本一致</p><p>值得注意的是，用数组指针和指针数组同时指向二维数组时，其引用和使用数组名引用都是一样的</p><p>表示数组中<code>i</code>行<code>j</code>列的一个元素，下面的表示都是等价的：</p><p><code>*(*(p+i)+j)、*(p[i]+j)、(*(p+i))[j]和p[i][j]</code></p></blockquote><h3 id="3-二维数组相关"><a href="#3-二维数组相关" class="headerlink" title="3.二维数组相关"></a>3.二维数组相关</h3><blockquote><p>总结指针在数组中的一些应用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">100</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(array).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array[0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(array[<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;array[0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;array[<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;array[0][0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;array[<span class="number">0</span>][<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array+1 type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(array+<span class="number">1</span>).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*array type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*array).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*array) type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;(*array)).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&amp;(*array) type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*&amp;(*array)).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line">array type:<span class="type">int</span> [<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">array[<span class="number">0</span>] type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">&amp;array[<span class="number">0</span>] type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">&amp;array[<span class="number">0</span>][<span class="number">0</span>] type:<span class="type">int</span>*</span><br><span class="line">array+<span class="number">1</span> type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">*array type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">&amp;(*array) type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">*&amp;(*array) type:<span class="type">int</span> [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>从上面的输出可以看出，<code>array</code>是数组名，同时也可以说成是指向<code>array[0][0]</code>地址的指针，此时，<code>array</code>/<code>array[0]</code>/<code>&amp;array[0]</code>/<code>&amp;array[0][0]</code>的值是一样的，都是指向数组最开始的地址，但它们表示的含义是不同的。</p><p>从类型结果来看，<code>array</code>/<code>array+1</code>/<code>array+2</code>分别是该数组每一行整个一维数组的地址，等同于<code>&amp;array[0]</code>/<code>&amp;array[1]</code>/<code>&amp;array[2]</code>；<code>*array</code>/<code>*(array+1)</code>/<code>*(array+2)</code>分别是该数组每一行的首地址，等同于<code>array[0]</code>/<code>array[1]</code>/<code>array[2]</code>； </p><p>==相当于C语言直接将相邻的方括号<code>[]</code>使用<code>*</code>来表示，比如说a[1]和1[a]，最后展开后是<code>*(a+1)</code>和<code>*(1+a)</code>，本质上都是相同的==；</p><p>还有值得注意的就是，<code>&amp;</code>和<code>*</code>的操作是互逆的，这里<code>&amp;</code>是取地址操作符，这里<code>*</code>是指针运算符，也能说是取内容运算符，相当于找到该指针指向变量的值。</p></blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/mick_hu/article/details/100931034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166806157116782388032815%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166806157116782388032815&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100931034-null-null.142^v63^control,201^v3^control_2,213^v2^t3_control2&amp;utm_term=%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">数组指针和指针数组</a></p><p><a href="https://www.cnblogs.com/mq0036/p/3382732.html">数组指针和指针数组的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux:创建用户和修改权限</title>
      <link href="/2022/11/09/Linux-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%92%8C%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/"/>
      <url>/2022/11/09/Linux-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%92%8C%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建用户"><a href="#一、创建用户" class="headerlink" title="一、创建用户"></a>一、创建用户</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser [USER]</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>[USER]</code>为用户名</p></li><li><p>新的<code>UNIX</code>密码是该用户密码，然后其他信息输入根据需要选择是否输入(当然一路回车也可)</p></li><li><p>执行完上述命令后即可创建好用户(自动在<code>/home</code>目录下创建同名文件夹)，此时默认用户权限为<code>755</code>即<code>(drwxr-xr-x)</code></p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194607.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194632.png" alt=""></p><hr><blockquote><p><code>useradd</code>和<code>adduser</code>的区别</p></blockquote><ul><li><code>useradd</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加用户：sudo useradd -m 用户名 </span><br><span class="line">设置密码：sudo passwd 用户名</span><br><span class="line">删除用户：sudo userdel  -r  用户名</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>useradd</code>时，如果后面不添加任何参数选项，如<code>sudo useradd test</code>创建出来的用户将是默认“三无”用户：一无<code>Home Directory</code>，二无密码，三无系统<code>Shell</code>，因此利用这个用户登录系统，是登录不了的</p><p>使用<code>useradd -m +用户名</code>的方式创建，它会在<code>/home</code>目录下创建同名文件夹，然后利用<code>passwd + 用户名</code>为指定的用户名设置密码</p></blockquote><ul><li><code>adduser</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser 用户名</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>adduser</code>时，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。</p><p><code>adduser</code>会提示设置密码，<code>useradd</code>不会</p><p><code>adduser</code>会创建用户目录，<code>useradd</code>不会</p><p><code>adduser</code>会询问全名，房间号码，电话号码等用户信息，<code>useradd</code>不会</p></blockquote><h1 id="二、修改权限"><a href="#二、修改权限" class="headerlink" title="二、修改权限"></a>二、修改权限</h1><p><img src="https://img-blog.csdnimg.cn/20210129232516224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1NDE1NQ==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> 777 user</span><br><span class="line">$ sudo <span class="built_in">chmod</span> 755 user</span><br></pre></td></tr></table></figure><blockquote><p>一般给权限<code>755</code>就可以了，最好别给<code>777</code>，不然就和<code>root</code>用户没什么区别了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194648.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194703.png" alt=""></p><p>参考链接:</p><ul><li><a href="https://blog.csdn.net/xiaofengdada/article/details/122294475">linux用户和用户组详解(一）</a></li><li><a href="https://www.cnblogs.com/FengZeng666/p/13047659.html">useradd和adduser的区别与使用方法</a></li><li><a href="https://blog.csdn.net/weixin_42054155/article/details/113408572">chmod777到底是什么意思</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习笔记</title>
      <link href="/2022/09/04/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/04/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB学习笔记"><a href="#MATLAB学习笔记" class="headerlink" title="MATLAB学习笔记"></a>MATLAB学习笔记</h1><blockquote><p><strong>注：本篇学习笔记来自<a href="https://weread.qq.com/web/bookDetail/6a132d2059faf26a1107cdc">《MATLAB从基础到精通》</a>，书中采用MATLAB 7.0，因此后面相关函数在新版本MATLAB中可能需要做些修改才能运行。</strong></p></blockquote><h2 id="第一章-MATLAB常用数据类型："><a href="#第一章-MATLAB常用数据类型：" class="headerlink" title="第一章 MATLAB常用数据类型："></a><strong>第一章 MATLAB常用数据类型：</strong></h2><blockquote><p>整型、浮点型、逻辑类型、结构体、元胞数组及字符串等</p><p>MATLAB数据类型在使用中与其他编程语言相比，有一个突出的特点，即不用对变量的数据类型进行定义，MATLAB软件会自动依据变量被赋值的情况，生成相应数据类型的数据。(和JavaScript有点像)</p></blockquote><h3 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;whos<span class="comment">%查看工作空间变量</span></span><br><span class="line">&gt;&gt;isinteger(value)<span class="comment">%判断变量value数据类型是否是整型</span></span><br></pre></td></tr></table></figure><ul><li><code>intmin()</code>和<code>intmax()</code>函数可用于确定整型数据类型的数据范围(最大值和最小值)，其中<code>intmin()</code>函数用于求数据类型的下限，<code>intmax()</code>函数用于求数据类型的上限。</li></ul><h3 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single()/double()函数：单精度/双精度浮点型(<span class="number">32</span>/<span class="number">64</span>位)</span><br><span class="line">&gt;&gt; isfloat(value)<span class="comment">%判断变量value数据类型是否是浮点型(是返回&quot;1&quot;，否则返回&quot;0&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><code>realmin (&#39;single&#39;)</code>和<code>realmin(&#39;double&#39;)</code>函数，分别返回数据类型单精度浮点型和双精度浮点型的最小值，<code>realmax(&#39;single&#39;)</code>和<code>realmax(&#39;double&#39;)</code>分别返回其相应的最大值</li></ul><h3 id="3-逻辑类型"><a href="#3-逻辑类型" class="headerlink" title="3.逻辑类型"></a>3.逻辑类型</h3><ul><li><p>逻辑类型仅包括两个值：“0”和“1”，分别代表逻辑“假”和“真”。</p></li><li><p>逻辑类型主要用于关系和逻辑运算，在使用过程中通过查找、条件语句的逻辑判断，可以判断条件是否为真。</p></li></ul><blockquote><ul><li>查找矩阵中符合条件的数据：大于5则返回”1”，否则返回”0”</li><li>逻辑非运算，矩阵中元素是0返回”1”，否则返回”0”</li></ul></blockquote><h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h3><blockquote><p>字符串生成：主要通过直接赋值法、已有字符串的连接和其他数据类型的转换</p><p>一维字符串</p><ul><li><p>直接赋值法</p></li><li><p>连接法：<code>strcat()</code>函数/连接符”[]”</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;str2=strcat(str1,<span class="string">&quot;str&quot;</span>)</span><br><span class="line">&gt;&gt;str3=[str1,str2]</span><br></pre></td></tr></table></figure></li></ul><p>二维字符串</p><ul><li>二维字符串的生成方法与一维类似，不过使用连接符“[ ]”连接时，二维字符串要求每行的字符有相同的列数，如果每行列数不同会报错，此时可以通过填空补足</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;str2=char(<span class="string">&#x27;ABC&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>)<span class="comment">% char()创建二维字符串，列数不同字符行，末尾自动留空</span></span><br><span class="line">&gt;&gt;str3=strvcat(str1,str2)<span class="comment">%垂直连接字符串</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="4-1-字符串操作函数"><a href="#4-1-字符串操作函数" class="headerlink" title="4.1 字符串操作函数"></a>4.1 字符串操作函数</h5><ul><li>字符串判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ischar(s):判断s数据类型是否为字符串</span><br><span class="line">isletter(s):判断s中每个字符元素是否为字母</span><br><span class="line">isspace(s):判断s中每个字符元素是否为空格</span><br></pre></td></tr></table></figure><ul><li>字符串访问</li></ul><p>通过下标法来实现的，即根据字符元素在字符串中的位置来访问，其中位置的确定包括行列坐标和线性索引坐标两种方式。在MTALAB中字符数组是按列存储的。</p><ul><li>字符串查找和替换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strfind(str,s):在字符串str中查找字符s</span><br><span class="line">findstr(s1,s2):在长字符串中查找短字符串</span><br><span class="line">strrep(s1,s2,s3):在字符串s1中查找字符串s2并将其替换为字符串s3</span><br><span class="line">i = strmatch(s1,s2):在字符串s1中匹配查找与字符串s2起始一致的字符行，返回行号</span><br><span class="line">i = strmatch(s1,s2,’exact’):在字符串s1中匹配查找与字符串s2完全一致的字符行，返回行号</span><br></pre></td></tr></table></figure><ul><li>字符串比较</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k=strcmp(s1,s2):比较字符串s1和s2是否相同</span><br><span class="line">k=strncmp(s1,s2,n):比较字符串s1和s2前n个字符是否相同</span><br><span class="line">k=strcmpi(s1,s2):比较字符串s1和s2是否相同，不区分字符串字母的大小写</span><br></pre></td></tr></table></figure><ul><li>字符串大小写转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=lower(s):将字符串s中的大写英文字母全部转换为小写</span><br><span class="line">str=upper(s):将字符串s中的小写英文字母全部转换为大写</span><br></pre></td></tr></table></figure><ul><li>字符串执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval()函数可用于字符串表达式的执行，函数的具体用法如下:</span><br><span class="line">eval(expression):用于在命令行执行expression中的字符串表达式</span><br><span class="line">[a1,a2,a3,...]=eval(‘function(b1,b2,b3,...)’):其中&quot;function(b1,b2,b3,...)&quot;为待执行的字符串表达式，&quot;a1,a2,a3,...&quot;为字符串表达式的输出结果</span><br></pre></td></tr></table></figure><ul><li>字符串空格操作相关函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str=strtok(s):查找字符串第一个空格前的字符，返回到字符串str中</span><br><span class="line">str=deblank(s):去除字符串s末尾的空格，返回去除空格的字符串str</span><br><span class="line">str=strtrim(s):删除字符串s头尾的空格，返回去除空格的字符串str</span><br><span class="line">blanks(n):生成含n个空格的字符串</span><br></pre></td></tr></table></figure><h3 id="5-元胞数组"><a href="#5-元胞数组" class="headerlink" title="5.元胞数组"></a>5.元胞数组</h3><blockquote><p>元胞数组是由可以包括任何数据类型的元胞组成的数组</p></blockquote><h5 id="5-1元胞数组创建"><a href="#5-1元胞数组创建" class="headerlink" title="5.1元胞数组创建"></a>5.1元胞数组创建</h5><ul><li>直接赋值法:直接在命令行中给元胞数组的每个元素赋值，或者使用大括号“{ }”创建元胞数组</li><li>函数法:使用<code>cell()</code>函数创建(先对元胞内存空间预分配，再对元胞中的元素进行赋值)</li></ul><h5 id="5-2元胞数组访问"><a href="#5-2元胞数组访问" class="headerlink" title="5.2元胞数组访问"></a>5.2元胞数组访问</h5><ul><li>大括号访问元胞数组:可对其数据执行操作</li><li>小括号访问元胞数组:不可对其数据执行操作</li></ul><h5 id="5-3元胞数组显示"><a href="#5-3元胞数组显示" class="headerlink" title="5.3元胞数组显示"></a>5.3元胞数组显示</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">celldisp(s):用于显示元胞数组s中的具体内容</span><br><span class="line">celldisp(s,name):以字符串name为元胞名，显示元胞数组s中的具体内容</span><br><span class="line">cellplot(s):以图形化的方式显示元胞数组s</span><br><span class="line">cellplot(s,&#x27;legend&#x27;):以图形化的方式显示元胞数组s，同时显示不同数据类型的颜色图例标注</span><br></pre></td></tr></table></figure><h5 id="5-4元胞数组删除"><a href="#5-4元胞数组删除" class="headerlink" title="5.4元胞数组删除"></a>5.4元胞数组删除</h5><blockquote><p>元胞数组的删除主要是通过把需要删除的元胞赋值为空来实现。通过大括号和小括号访问元胞并将其置空，可以分别删除元胞数组的内容或整体</p></blockquote><h3 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6.结构体"></a>6.结构体</h3><blockquote><p>结构体数据类型可以把不同数据类型的变量放到同一个变量名下，通过不同“域”的概念对结构体中的不同数据进行赋值、操作。结构体中的数据存储在相应的“域”中</p></blockquote><h5 id="6-1结构体生成"><a href="#6-1结构体生成" class="headerlink" title="6.1结构体生成"></a>6.1结构体生成</h5><ul><li>命令行直接赋值法:直接把不同类型的数据赋值给结构体变量不同的域中</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结构与域之间用点号“.”连接，不同域中可保存不同数据类型的变量</span><br><span class="line">&gt;&gt;ss.str=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&gt;&gt;ss.num=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">&gt;&gt;ss</span><br><span class="line">ss=</span><br><span class="line">str:<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">num:[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li>函数法:<code>struct()</code>函数创建结构体变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=struct(&#x27;field1&#x27;,values1,&#x27;field2&#x27;,value2,...)% “&#x27;field1&#x27;”和“&#x27;field2&#x27;”为域名，“values1”和“values2”为域中的值</span><br></pre></td></tr></table></figure><h5 id="6-2结构体操作"><a href="#6-2结构体操作" class="headerlink" title="6.2结构体操作"></a>6.2结构体操作</h5><ul><li>结构体元素访问</li><li>结构体显示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fieldnames()函数显示结构体的域名</span><br><span class="line">getfield()函数显示结构体各域中的具体内容</span><br></pre></td></tr></table></figure><ul><li>结构体删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = rmfield(ss,&#x27;field&#x27;):用于删除结构体中的域“field”</span><br><span class="line">s = rmfield(ss,FIELDS):用于同时删除结构体中的多个域，FIELDS为需要删除的多个域的域名的字符串</span><br></pre></td></tr></table></figure><h3 id="7-不同数据类型转化"><a href="#7-不同数据类型转化" class="headerlink" title="7.不同数据类型转化"></a>7.不同数据类型转化</h3><ul><li>数组与字符串转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = num2str(A):把数值型数据数组A转换为字符型数据，默认情况下转换的数据精度为5位有效数字</span><br><span class="line">str = num2str(A,precision):按照指定的数据精度转换数组A到字符串类型数据str，precision为字符串中数据的有效位数</span><br><span class="line">str = num2str(A,format):按照指定的数据格式转换数组A到字符串类型数据str。format的书写格式为%m1.m2g/f/e，其中m1指定总共显示的有效数字位数，m2代表小数点后的有效数字位数，“g”格式代表用指数或定点标记，“e”格式代表用指数标记，“f”格式代表用定点标记，与函数sprinf()的输出显示设置相同</span><br><span class="line">x = str2num(&#x27;str&#x27;):字符串转化为数组</span><br></pre></td></tr></table></figure><blockquote><p>int2str()函数和str2int()函数可以完成整型数据与字符串的转换，即取整数据与字符串的转换。mat2str()函数和str2mat()函数可以实现矩阵与字符串的转换，其用法类似于num2str()函数和str2num()函数，但不可以用于高维数组</p></blockquote><ul><li>不同进制数据转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dec2hex(x)和hex2dec(x):用于十六进制数和十进制数之间的相互转换</span><br><span class="line">dec2bin(x)和bin2dec(x):用于二进制数和十进制数之间的相互转换</span><br><span class="line">str=dec2base(d,base)和d=base2dec(&#x27;strn&#x27;,base):用于任意进制的数与十进制数之间的转换</span><br></pre></td></tr></table></figure><ul><li>元胞数组与数值类型转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = num2cell(A):转换数组A到元胞数组c</span><br><span class="line">c = num2cell(A,dims):按照指定的维数转换数组A到元胞数组c</span><br></pre></td></tr></table></figure><blockquote><p>char()函数和cellstr()函数用于元胞数组和字符串之间的转换；</p><p>cell2struct()函数和struct2cell()函数可用于元胞数组和结构体的转换</p></blockquote><h2 id="第二章-矩阵和数组"><a href="#第二章-矩阵和数组" class="headerlink" title="第二章 矩阵和数组"></a><strong>第二章 矩阵和数组</strong></h2><h3 id="1-矩阵和数组的概念"><a href="#1-矩阵和数组的概念" class="headerlink" title="1.矩阵和数组的概念"></a>1.矩阵和数组的概念</h3><p>数组为具有相同数据类型的数据组合，矩阵的概念主要应用于数学中，在MATLAB中矩阵一般即指二维数组，但是矩阵与数组在部分运算上又是有很大区别的</p><h3 id="2-矩阵和数组创建"><a href="#2-矩阵和数组创建" class="headerlink" title="2.矩阵和数组创建"></a>2.矩阵和数组创建</h3><ul><li>直接输入法</li></ul><blockquote><p>同一行中的数据使用空格或者逗号分隔</p><p>分号表示每一行数据输入结束</p><p>所有数据都包含在方括号“[ ]”中</p></blockquote><ul><li>函数法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zeros()函数:全零矩阵生成。一般用于初始变量创建时预留内存空间，在后面的计算中再为矩阵元素赋具体的值</span><br><span class="line">eye()函数:单位矩阵生成。用法与全零矩阵生成方法类似，但是eye()函数不支持二维以上矩阵的生成</span><br><span class="line">ones()函数:全1矩阵生成，用法同zeros()函数</span><br><span class="line">rand()函数:随机矩阵生成。只用于生成0～1的平均分布的随机数，不包括0和1</span><br><span class="line">randn()函数:用于生成均值为0，方差为1的正态分布的随机数，其他用法同rand()函数</span><br><span class="line">randperm(n)函数:用于生成1:n随机分布的n个正整数</span><br><span class="line">compan()函数:生成伴随矩阵，只适用于向量</span><br><span class="line">magic()函数:生成魔方矩阵，矩阵每行、每列及两条对角线上元素和都相等</span><br><span class="line">diag()函数:生成对角矩阵，即只有对角线上有非零元素的矩阵</span><br><span class="line">triu()/tril函数:上/下三角矩阵，即对角线以下/上元素全为0的矩阵</span><br></pre></td></tr></table></figure><ul><li>外部导入法</li></ul><p>通过数据导入平台或者文件输入函数，把txt、excel、mat等文件中存储的数据导入MATLAB工作空间内，并以矩阵的形式存储数据</p><h3 id="3-矩阵和数组基本操作"><a href="#3-矩阵和数组基本操作" class="headerlink" title="3.矩阵和数组基本操作"></a>3.矩阵和数组基本操作</h3><h5 id="3-1-基本信息获取"><a href="#3-1-基本信息获取" class="headerlink" title="3.1 基本信息获取"></a>3.1 基本信息获取</h5><ul><li>数据显示: <code>disp(x)</code>函数在命令行窗口输出矩阵x，不显示矩阵名(语句后不加分号也能显示)</li><li>矩阵判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isempty(A):判断矩阵是否为空，若为空返回1，否则返回0</span><br><span class="line">空矩阵是指没有任何元素的矩阵，一般的使用过程中，对空矩阵执行操作会出错，因而在对矩阵进行一些操作前需要判断矩阵是否为空</span><br><span class="line">isequal(A,B):判断矩阵A、B的数值是否相等，仅当A、B矩阵所有元素都相等时返回1，否则返回0</span><br><span class="line">isfloat(A):判断矩阵A的数据类型是否为浮点型，如果是则返回1，否则返回0</span><br><span class="line">isinteger(A):判断矩阵A的数据类型是否为整数型，如果是则返回1，否则返回0</span><br></pre></td></tr></table></figure><ul><li>大小信息获取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size(X):用于获取矩阵X的行数和列数</span><br><span class="line">length(X):用于获取矩阵X的长度，即矩阵行数或列数中的较大值</span><br><span class="line">numel(X):用于获取矩阵X中元素个数总和</span><br><span class="line">ndims(X):用于获取矩阵X的维数</span><br></pre></td></tr></table></figure><h5 id="3-2-元素访问"><a href="#3-2-元素访问" class="headerlink" title="3.2 元素访问"></a>3.2 元素访问</h5><ul><li>单个元素访问</li></ul><blockquote><p>矩阵和数组是由行和列组成的，例如矩阵A中A(i,j)对应于矩阵的第i行、第j列的元素，可以通过数据行列形式访问指定行列下标的元素。同时MATLAB提供矩阵单下标的数据访问方式，这主要是因为基于矩阵的列存储数据的，第i行、j列的数据对应单下标即为(j-1)*m+i，其中m为矩阵的行数。在访问到需要的单个元素，即可进一步对访问到的单个元素进行编辑操作</p></blockquote><ul><li>多个元素访问</li></ul><blockquote><p>通过矩阵的下标或者根据矩阵中元素的线性索引值来访问</p></blockquote><ul><li>行列元素访问</li></ul><blockquote><p>行列元素的访问通过冒号运算符来实现，对于行数据访问，“：”代表所有列的数据，对于列数据访问，“：”代表所有行数据，即A(i,:)访问矩阵的第i行的所有数据。A(:,j)访问矩阵的第j列的所有数据</p></blockquote><ul><li>全部元素访问</li></ul><blockquote><p>矩阵全部元素访问主要还是基于下标和单下标访问机制，只是在访问的时候以符号“：”代替所有元素</p></blockquote><ul><li>对角线元素访问</li></ul><blockquote><p>对角线元素的访问主要通过diag()函数来实现，该函数可用于生成对角矩阵，同时也可用于访问指定对角线上的元素，但不可利用此函数修改矩阵对角线上的值</p></blockquote><ul><li>end在矩阵元素访问中的使用</li></ul><blockquote><p>end在矩阵中代表最后一个元素，可以是一行的最后、一列的最后或者整个矩阵最后的一个元素，同时结合冒号的使用，可以访问从某个元素开始到最后的元素。使用end访问矩阵中的数据，可以不需要矩阵具体的大小</p></blockquote><ul><li><code>Find()</code>函数在矩阵元素访问中的访问</li></ul><blockquote><p>查找访问矩阵中满足一定条件的元素</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">indices=find(X):查找矩阵X中的非零元素，返回矩阵X中非零元素的线性索引</span><br><span class="line">indices=find(X,k):查找矩阵X中的非零元素，返回矩阵X中前k个非零元素的线性索引</span><br><span class="line">indices=find(X,k,’last’):查找矩阵X中的非零元素，返回矩阵X中后k个非零元素的线性索引</span><br><span class="line">[row,col]=find(X):查找矩阵X中的非零元素，返回矩阵X中非零元素的行列下标</span><br><span class="line">[row,col]=find(X,k):查找矩阵X中的非零元素，返回矩阵X中前k个非零元素的行列下标</span><br><span class="line">[row,col]=find(X,k,’last’):查找矩阵X中的非零元素，返回矩阵X中后k个非零元素的行列下标</span><br></pre></td></tr></table></figure><h3 id="4-矩阵及数组简单运算"><a href="#4-矩阵及数组简单运算" class="headerlink" title="4.矩阵及数组简单运算"></a>4.矩阵及数组简单运算</h3><h5 id="4-1-基本函数"><a href="#4-1-基本函数" class="headerlink" title="4.1 基本函数"></a>4.1 基本函数</h5><ul><li>连接函数</li></ul><blockquote><p>矩阵的连接包括水平方向左右连接和垂直方向上下连接，水平连接的矩阵需要具有相同的行数，垂直连接的矩阵需要具有相同的列数。而矩阵连接可以通过中括号“[]”或连接函数实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[A;B] :用于垂直方向连接具有相同列数的矩阵A和B</span><br><span class="line">[A B]或[A,B]:用于水平方向连接具有相同行数的矩阵A和B</span><br><span class="line">cat(dim,A,B):在指定维数上连接矩阵A和B，其中cat(1,A,B)相当于[A;B]，cat(2,A,B)相当于[A,B]和[A B]</span><br><span class="line">horzcat(A,B):用于水平方向连接矩阵A和B</span><br><span class="line">vertcat(A,B):用于垂直方向连接矩阵A和B</span><br></pre></td></tr></table></figure><ul><li>翻转函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fliplr(A):用于矩阵A的左右翻转，不适用于二维以上矩阵或数组</span><br><span class="line">flipud(A):用于矩阵A的上下翻转，不适用于二维以上矩阵或数组</span><br><span class="line">rot90(A):用于矩阵A逆时针90度翻转，rot90(A,k)可按逆时针方向90*k度旋转矩阵A</span><br><span class="line">transpose(A):用于返回转置后的矩阵A，同A&#x27;</span><br></pre></td></tr></table></figure><ul><li>改变矩阵大小</li></ul><blockquote><p>矩阵的大小即矩阵的行列数。在MATLAB 7.0中矩阵大小的改变可以通过添加、删除、拼接元素的方法来实现，同时可以通过函数重现排列、复制矩阵，达到改变矩阵大小的目的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = reshape(A,m,n):用于重新排列矩阵A，返回大小为m×n的矩阵B，矩阵A的元素个数需要等于m×n</span><br><span class="line">B = reshape(A,m,n,p,...):用于重新排列矩阵A，返回大小为m×n×p…的矩阵B，矩阵A的元素个数需要等于m×n×p…，用于高维数组的重排</span><br><span class="line">B = reshape(A,...,[],...):重排矩阵A，其中一维的大小可以使用默认值</span><br><span class="line">B = reshape(A,size):根据size函数得出的矩阵大小值重排矩阵</span><br></pre></td></tr></table></figure><blockquote><p>MATLAB 7.0提供了repmat()函数复制矩阵。矩阵的复制在矩阵运算中具有较大的用处，因为一般的矩阵加、减等运算要求矩阵具有相同的大小。而如果遇到一个矩阵每列（行）需要都加上或减去一个数值时，即矩阵与向量的操作，不同大小的矩阵无法相加减。如果通过循环，基于矩阵中每列（行）相加减，算法的效率不高，特别是当需要计算的矩阵很大时，对算法运行时间影响很大，而函数repmat()通过复制矩阵，可以向量生成与需要加、减的矩阵相同的矩阵，进行矩阵间的运算，算法效率较高</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = repmat(A,m,n):以A为重复单元，把A看做整体，返回m×n个A组成的矩阵B</span><br><span class="line">B = repmat(A,n):以A为重复单元，把A看做整体，返回n×n个A组成的矩阵B</span><br></pre></td></tr></table></figure><ul><li>其他常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B=unique(A):去除矩阵A中的重复元素，返回无重复元素的A到新变量B，B以向量形式存在，并按从小到大的顺序排列A中无重复的元素</span><br><span class="line">[B, m, n]=unique(A):去除A中重复元素，返回无重复元素的A到新向量B，m为B在A中的线性索引值，即b=A(m)，n为A在B中的索引值，即A=b(n)</span><br><span class="line">B=unique(A,&#x27;rows&#x27;):去除矩阵A中的重复行，返回新矩阵B，其中矩阵B中行的排列是按照第一列元素从小到大排列，如果第一列元素相同，则依次比较后面的列</span><br><span class="line">[B, m, n]=unique(A,&#x27;rows&#x27;):去除矩阵A中的重复行，返回新矩阵B，m为矩阵B在A中对应的行索引，即B=A(m,:)，n为矩阵A在B中对应的行索引，即A=B(n,:)</span><br><span class="line"></span><br><span class="line">indces=sub2ind(size, i, j):用于把矩阵的行列下标转换为线性索引下标，其中size为需要转换的矩阵的维数，i和j分别为需要转换的行、列下标值，indices返回大小为size的矩阵i行j列对应的线性索引值</span><br><span class="line">[i,j] = ind2sub(size, indces):用于将矩阵的线性索引下标转换为行列下标，其中size为需要转换的矩阵的维数，indices为需要转换的线性索引下标值，函数返回的i和j分别为indices对应的行、列下标值</span><br></pre></td></tr></table></figure><h5 id="4-2-加减运算"><a href="#4-2-加减运算" class="headerlink" title="4.2 加减运算"></a>4.2 加减运算</h5><blockquote><p>矩阵的加减运算要求相加减的矩阵有相同的维数，即相同的行列数，与线性代数中的运算法则是相同的</p></blockquote><h5 id="4-3-乘法运算"><a href="#4-3-乘法运算" class="headerlink" title="4.3 乘法运算"></a>4.3 乘法运算</h5><blockquote><p>矩阵与数组在乘法运算中有所区别，矩阵的乘法是线性代数中常用的运算，要求被乘矩阵的列数等于相乘矩阵的行数。而数组的乘法是点乘运算，即数组具有相同下标的元素相乘，运算时在一般乘法运算的“*”前加上“.”，需要两数组具有相同的维数</p><p>C=A*B:用于矩阵的乘法，要求矩阵A的列数等于矩阵B的行数</p><p>C=A.*B:用于数组的乘法，要求矩阵A和B具有相同的大小</p><p>注意，如果A和B中有一个为标量，则不需要遵守上述规则，标量与矩阵中每个元素相乘</p></blockquote><h5 id="4-4-除法运算"><a href="#4-4-除法运算" class="headerlink" title="4.4 除法运算"></a>4.4 除法运算</h5><blockquote><p>矩阵的除法与数组的除法有一定差异，其中矩阵的除法对应与线性代数中的逆运算相关，而数组的除法则是点除，是数组中相同下标元素的相除。同时除法运算又分为左除和右除</p></blockquote><ul><li>矩阵的除法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A\B:矩阵的左除，如果A为方阵，即n*n阶矩阵，可用于计算方程Ax=B的解，等效于inv(A)*B</span><br><span class="line">B/A:矩阵的右除，用于计算方程xA=B的解，等效于B*inv(A)</span><br></pre></td></tr></table></figure><ul><li>数组的除法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A./B:数组的左除，即A(i,j)/B(i,j)</span><br><span class="line">A.\B:数组的右除，即B(i,j)/A(i,j)</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果A是标量，数组的左除A./B即A除以矩阵数组B的每一个元素，右除A.\B即矩阵数组B的每个元素除以标量A；如果B是标量，则数组的左除A./B即矩阵数组A的每个元素除以B，右除A.\B即标量B除以矩阵数组A的每一个元素</p></blockquote><h5 id="4-5-乘方运算"><a href="#4-5-乘方运算" class="headerlink" title="4.5 乘方运算"></a>4.5 乘方运算</h5><blockquote><p>矩阵与数组在乘方运算中也有不同，矩阵的乘方相当于多个矩阵相乘，而数组的乘方即数组中每个元素的乘方运算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">矩阵的乘方运算:C=A^B。其中，A需为方阵，即矩阵的行列数相等，B为标量。A^B的运算即相当于B个矩阵A相乘</span><br><span class="line">数组的乘方运算:C=A.^B。其中，当A、B都为数组时，需大小相等；C(i,j)的计算结果即为A(i,j)的B(i,j)次方；如果A为标量，A.^B的运算即相当于分别对元素A做B(i,j)次方；如果B为标量，A.^B的运算即相当于对数组A中的每个元素做B阶乘方运算</span><br></pre></td></tr></table></figure><h3 id="5-矩阵的特殊运算"><a href="#5-矩阵的特殊运算" class="headerlink" title="5.矩阵的特殊运算"></a>5.矩阵的特殊运算</h3><ul><li>行列式运算</li></ul><blockquote><p>函数det用于计算矩阵的行列式。如果矩阵为方阵，则其存在行列式，可通过函数det计算出矩阵的行列式值，此值为一标量</p></blockquote><ul><li>逆运算</li></ul><blockquote><p>在线性代数中，若矩阵A是方阵，且为非奇异阵，即行列式值不为0，存在矩阵x使Ax=I和xA=I，x称为矩阵A的逆矩阵，记做A-1。在MATLAB中用函数inv()来计算矩阵的逆运算</p></blockquote><ul><li>秩运算</li></ul><blockquote><p>矩阵中线性无关的行数与列数称为矩阵的秩。在MATLAB 7.0中，函数rank()用于求矩阵的秩</p></blockquote><ul><li>特征值运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e=eig(x):其中e是由特征值组成的列向量，x是输入的方矩阵</span><br><span class="line">[v,d]=eig(x):方阵x的全部特征值，构成对角阵d，其对角线即为特征值，v是一个与x相同大小的矩阵，每一列是矩阵x的一个特征值所对应的特征向量</span><br></pre></td></tr></table></figure><h3 id="6-数组特殊运算"><a href="#6-数组特殊运算" class="headerlink" title="6.数组特殊运算"></a>6.数组特殊运算</h3><blockquote><p>在MATLAB中，数组的特殊运算主要包括关系运算、逻辑运算和集合运算，与一般的矩阵运算不同的是，这些运算都是基于数组中每个元素进行的</p></blockquote><h5 id="6-1-关系运算"><a href="#6-1-关系运算" class="headerlink" title="6.1 关系运算"></a>6.1 关系运算</h5><blockquote><p>MATLAB中的关系运算主要用于判断数组的大小关系，关系成立返回“1”，关系不成立则返回“0”。MATLAB中提供的关系符有大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=），等于（==），不等于（～=）。</p><p>其中，关系运算用于比较的两个对象如果都是数组，则要求数组大小相同，因为关系运算是判断两个数组相应位置上元素的大小关系；而如果比较的对象中有一个为标量，即标量与数组中每个元素进行比较。通过数组的关系运算可以方便地判断数组中元素的大小关系，同时数组与标量的关系运算也比较常用，结合查找函数find可以查找到符合一定条件的数组元素对应的位置信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组大于运算:C=A&gt;BC=(A&gt;B)C=gt(A,B)</span><br><span class="line">数组大于等于运算:C=A&gt;=BC=(A&gt;=B)C=ge(A,B)</span><br><span class="line">数组小于运算:C=A&lt;BC=(A&lt;B)C=lt(A,B)</span><br><span class="line">数组小于等于运算:C=A&lt;=BC=(A&lt;=B)C=le(A,B)</span><br><span class="line">数组等于运算:C=A==BC=(A==B)C=eq(A,B)</span><br><span class="line">数组不等于运算:C=A~=BC=(A~=B)C=ne(A,B)</span><br></pre></td></tr></table></figure><h5 id="6-2-逻辑运算"><a href="#6-2-逻辑运算" class="headerlink" title="6.2 逻辑运算"></a>6.2 逻辑运算</h5><blockquote><p>MATLAB中提供的逻辑运算主要有与运算（&amp;）、或运算（|）、非运算（~）、异或运算（xor）、快速逻辑与运算（&amp;&amp;）、快速逻辑或运算（||）和逻辑函数all、any</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">与运算(&amp;):C=A&amp;B，当数组A、B相应位置上的元素都为非零元素，即返回1，否则返回0</span><br><span class="line">或运算(|):C=A|B，当数组A、B相应位置上的元素至少一个为非零元素，即返回1，否则返回0</span><br><span class="line">非运算(~):C=~A，当数组A相应位置上的元素都为非零元素，即返回0，否则返回1</span><br><span class="line">异或运算(xor):C=xor(A,B)，当数组A、B相应位置上的元素一个为非零元素，一个为零，即返回1，否则返回0</span><br><span class="line">快速逻辑与运算(&amp;&amp;):C=A&amp;&amp;B，其中，A、B需为逻辑变量或标量，当A、B都为真或为标量时不为0，即返回1，否则返回0。在进行快速逻辑与运算的时候，如果A已发现是零，则不去判断B是否为零，直接返回结果“0”；但是如果A为1，即仍然要判断B是否为零</span><br><span class="line">快速逻辑或运算(||):C=A||B，A、B需为逻辑变量或标量，当A、B存在一个为真或一个标量不为0，即返回1，否则返回0。快速逻辑或运算当A判断结果为非零后，无须继续判断B，即返回结果“1”；如果A为零，则需进一步判断B是否为非零</span><br><span class="line"> all(x):判断数组x中的元素是否都为非零元素，是则返回“1”，否则返回“0”。当x为数组时，默认对列数据进行判断，即判断数组中各列元素是否都为非零元素。而如果需要判断行元素是否都为非零元素即指定判断的维数，all(x,dim)，其中dim=2用于行数据判断</span><br><span class="line"> any(x):判断数组x中的元素是否存在任何一个元素为非零元素，是则返回“1”，否则返回“0”。当x为数组时，默认对列数据进行判断，即判断数组中各列元素是否都为非零元素。而如果需要判断行元素是否存在非零元素即指定判断的维数，any(x,dim)，其中dim=2用于行数据判断</span><br></pre></td></tr></table></figure><h3 id="7-向量及其运算"><a href="#7-向量及其运算" class="headerlink" title="7.向量及其运算"></a>7.向量及其运算</h3><h5 id="7-1-向量的生成"><a href="#7-1-向量的生成" class="headerlink" title="7.1 向量的生成"></a>7.1 向量的生成</h5><blockquote><p>只有一行或一列元素的数组或矩阵即为向量，向量可以看成一维的数组或矩阵。向量可分为行向量和列向量</p></blockquote><ul><li>使用冒号法生成向量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用冒号法生成向量主要用于生成具有等间隔的向量，其格式为：x0:xstep:xend。其中，x0为向量的初始值，xstep为步长，xend为终止值</span><br></pre></td></tr></table></figure><ul><li>函数法生成向量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linspace(a,b,n):a和b是生成向量的初值和终值，n是向量中元素的个数。当n默认时，默认生成a～b范围内的100个元素</span><br><span class="line">logspace(a,b,n):10a和10b是生成向量的初值和终值，n是向量中元素的个数。当n默认时，默认生成10a～10b范围内的50个元素</span><br></pre></td></tr></table></figure><h5 id="7-2-向量的运算"><a href="#7-2-向量的运算" class="headerlink" title="7.2 向量的运算"></a>7.2 向量的运算</h5><ul><li><p>常用函数</p><ul><li>判断是否为向量: <code>isvector(x)</code>函数</li><li>向量内积: <code>dot(A,B)</code>函数</li><li>向量外积: <code>cross(A,B)</code>函数</li></ul></li><li><p>集合运算</p><ul><li>交集: <code>intersect(A,B)</code>函数</li><li>并集: <code>union(A,B)</code>函数</li><li>差集: <code>setdiff(A,B)</code>函数</li><li>异或: <code>setxor(A,B)</code>函数、</li></ul></li></ul><h3 id="8-高维数组操作"><a href="#8-高维数组操作" class="headerlink" title="8.高维数组操作"></a>8.高维数组操作</h3><blockquote><p>除上面的矩阵、数组、向量外，MATLAB还支持高维数组的使用，高维数组即二维以上的数组。不过一般情况下高维数组多用于存储数组，特别在图像处理中，对于一幅图像数据，多存储为高维数组</p></blockquote><h5 id="8-1-高维数组创建"><a href="#8-1-高维数组创建" class="headerlink" title="8.1 高维数组创建"></a>8.1 高维数组创建</h5><ul><li>直接输入法</li></ul><blockquote><p>通过给相应下标的数组元素赋值实现。<strong>==三维数组在原来矩阵的行、列基础上，增加了页作为第三维数组的表示==</strong></p></blockquote><ul><li>函数法</li></ul><blockquote><p>使用zeros、ones、rand、repmat、reshape、cat等函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flipdim(A,dim)函数:实现高维数组的翻转操作</span><br><span class="line">A为需要翻转的数组，dim为翻转的基准维数，当dim为3时即对高维数组按页翻转</span><br></pre></td></tr></table></figure><h1 id="其余注意点"><a href="#其余注意点" class="headerlink" title="其余注意点"></a>其余注意点</h1><blockquote><p>Cell模式是MATLAB的一大特色，通过Cell模式的使用可以让用户在调试某一段代码块的时候，方便地重复运行，同时也向用户提供了代码块的思想。不同的功能可以设计成不同的代码块，分块执行代码，便于程序的执行、查错。</p><p>一段代码以%%标记后加一个空格即为代码块生成了Cell模式，光标移动到Cell模式中时，背景将变为浅黄色。按“Ctrl+Enter”组合键或者选择“Cell”→“Evaluate Current Cell”命令控制执行当前Cell模块下的代码。同时Cell模式的开启与关闭分别通过菜单项Enable Cell Mode和Disable Cell Mode控制</p><p>MATLAB提供了nargin()函数和nargout())函数输入/输出参数</p><p>为测试程序执行的快慢，可以采用tic和toc函数计算代码运行时间</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入控制语句: input命令</span><br><span class="line">键盘输入语句: keyboard命令</span><br><span class="line">暂停语句: pause命令</span><br><span class="line">指令显示控制语句: echo命令</span><br><span class="line">返回语句: return命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATLAB提供的可具有警告提示功能的语句主要有warning语句、error语句、errordlg语句，其调用格式如下:</span><br><span class="line">warning(&#x27;message&#x27;):&quot;message&quot;中为程序出错的提示信息，出错警告后，程序继续执行</span><br><span class="line">error(&#x27;message&#x27;):&quot;message&quot;中为程序出错的提示信息，出错警告后，程序将终止运行</span><br><span class="line">errordlg(&#x27;errorstring&#x27;):&quot;errorstring&quot;中为程序出错的提示信息，显示在警告对话框中，出错警告后，单击&quot;ok&quot;按钮，结束弹出式出错提示框，但代码仍会执行完毕</span><br><span class="line">errordlg(&#x27;errorstring&#x27;,&#x27;dlgname&#x27;):弹出警告对话框，&#x27;dlgname&#x27;为对话框中的标题</span><br></pre></td></tr></table></figure><h2 id="第三章-图形处理"><a href="#第三章-图形处理" class="headerlink" title="第三章 图形处理"></a><strong>第三章 图形处理</strong></h2><h3 id="1-基本绘图处理"><a href="#1-基本绘图处理" class="headerlink" title="1.基本绘图处理"></a>1.基本绘图处理</h3><h5 id="1-1-常用函数"><a href="#1-1-常用函数" class="headerlink" title="1.1 常用函数"></a>1.1 常用函数</h5><ul><li><code>plot()</code>函数:二维图形绘制</li><li><code>plotyy()</code>函数:双y轴图形绘制(适用于两组数据的数据范围相差较大但又希望放在同一图形中比较分析)</li><li><code>loglog()</code>函数:对数坐标图形绘制(x,y轴均为对数的坐标系)</li><li><code>semilogx()/semilogy()</code>函数:半对数坐标图形绘制</li><li><code>fplot()</code>函数:符号函数绘制</li></ul><blockquote><p>根据函数的表达式自动调整自变量的范围，无须给函数赋值，直接生成能反映函数变化规律的图形，在函数变化快的区域，采用小的间隔，否则采用大的坐标间，使绘制的图形计算量与时间最小，而又能尽可能精确反映图形的变化。fplot()函数一般在对横坐标取值间隔没有明确要求，仅查看函数的大致变化规律的情况下使用</p></blockquote><ul><li><code>ezplot()</code>函数:符号函数绘制</li></ul><blockquote><p>与fplot函数的功能基本类似，可以方便地绘制表达式或函数的图形。不同的是该函数的表达式显示在图形的上方，同时对坐标轴可不加任何限制做图</p></blockquote><ul><li><code>grid</code>函数:图形栅格控制</li><li><code>hold</code>函数:图形保持控制    <code>ishold</code>函数测试图形的保持状态,返回值“1”表示图形处于叠加状态，“0”表示图形处于覆盖状态</li><li><code>ginput()</code>函数:读点函数(交互式的从MATLAB绘制的图形中读取点坐标)</li><li><code>zoom</code>函数:图形缩放</li><li><code>saves()</code>函数:按照指定格式保存图形</li><li><code>print()</code>函数:图形打印(打印图形窗口的图形，必须紧跟在<code>plot()</code>函数后使用)</li></ul><h5 id="1-2-MATLAB图形窗口"><a href="#1-2-MATLAB图形窗口" class="headerlink" title="1.2 MATLAB图形窗口"></a>1.2 MATLAB图形窗口</h5><ul><li>图形窗口创建:<code>figure()</code>函数</li><li>图形句柄:<code>h=figure</code>,返回新创建的图形窗口句柄到变量h中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h = gcf:其中变量h返回当前图形窗口的句柄</span><br><span class="line">h = gca:其中变量h返回当前坐标轴对象的句柄</span><br><span class="line">h = gco:其中变量h返回当前对象的句柄</span><br><span class="line">h=findobj:返回根对象与其所有子对象的句柄值</span><br><span class="line"></span><br><span class="line">get(h)函数用于获取指定句柄下的图形对象的属性</span><br><span class="line">set(h)函数用于设置指定句柄下的图形对象的属性</span><br></pre></td></tr></table></figure><ul><li>图形窗口常用操作命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clf:清除当前图形窗口的图形</span><br><span class="line">cla:清除当前图形窗口坐标轴内的图形，保留坐标轴</span><br><span class="line">delete()函数用于删除文件或图形对象，将永久性地删除文件，文件不进入回收站</span><br><span class="line">close()函数用于关闭指定的图形窗口</span><br><span class="line">reset()函数用于重置图形窗口的属性，使其恢复为默认值</span><br></pre></td></tr></table></figure><h5 id="1-3-坐标控制"><a href="#1-3-坐标控制" class="headerlink" title="1.3 坐标控制"></a>1.3 坐标控制</h5><ul><li>坐标轴范围设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axis([Xmin,Xmax,Ymin,Ymax]):设置坐标轴的范围，指定当前坐标轴x轴和y轴的范围，其中Xmin为x轴范围下限，Xmax为x轴范围上限，Ymin为y轴范围下限，Ymax为y轴范围上限</span><br><span class="line">axis([xmin xmax ymin ymax zmin zmax cmin cmax]):设置坐标轴x轴、y轴和z轴的范围，以及坐标轴的颜色显示范围</span><br><span class="line">xlim([xmin xmax]):仅设置x轴范围</span><br><span class="line">ylim([ymin ymax]):仅设置y轴范围</span><br><span class="line">zlim([zmin zmax]):仅设置z轴范围</span><br><span class="line">axis tight:按紧凑方式显示坐标轴范围，即坐标轴范围为绘图数据范围</span><br></pre></td></tr></table></figure><ul><li>坐标轴刻度设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(gca,&#x27;XTick&#x27;,[XTickmin:XTickstep:XTickmax]):设置数字刻度的显示范围和精度，与图形做图数据范围相对应</span><br><span class="line">set(gca,&#x27;XTickLabel&#x27;,[XTickLabelmin:XTickLabelstep:XTickLabelmax]):设置坐标轴刻度线下的数值显示，默认状态下为做图数据相应坐标轴数据范围和刻度</span><br><span class="line">set(gca,&#x27;XTickLabel&#x27;,string):设置文本坐标轴刻度。坐标系横纵坐标轴刻度的比例往往是根据数据自动设置的，比例有时可能不一样，通过执行语句axis equal可以获得等比例的坐标轴刻度</span><br></pre></td></tr></table></figure><ul><li>坐标轴字体设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FontName属性:字体的类型属性，包括常用的字体类型</span><br><span class="line">FontSize属性:字体的大小属性</span><br><span class="line">FontUnits属性:字体的单位属性</span><br><span class="line">FontWeight属性:字体样式属性，包括normal(正常)、bold(加粗)、light(倾斜)、demi(黑体)</span><br></pre></td></tr></table></figure><ul><li>坐标轴边框设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XDir属性:控制X轴方向属性，默认状态下属性值为&quot;normal(正常)&quot;，可选属性值有&quot;reverse(逆转)&quot;</span><br><span class="line">XColor属性:设置X轴边框的颜色属性</span><br><span class="line">LineStyleOrder属性:设置坐标轴边框的线条类型属性</span><br><span class="line">LineWidth属性:设置坐标轴边框的线条颜色属性</span><br></pre></td></tr></table></figure><ul><li>坐标轴显示控制</li></ul><blockquote><p>axis on和axis off控制，默认状态下开启</p></blockquote><h5 id="1-4-图形标注"><a href="#1-4-图形标注" class="headerlink" title="1.4 图形标注"></a>1.4 图形标注</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title()函数用于给当前图形坐标轴的正上方添加标题</span><br><span class="line">xlabel()/ylabel()函数给x轴和y轴坐标轴设置</span><br><span class="line">text()函数用于文本标注gtext()函数用于交互式文本标注</span><br><span class="line">legend()函数用于添加图例标注</span><br></pre></td></tr></table></figure><h5 id="1-5-窗口分割"><a href="#1-5-窗口分割" class="headerlink" title="1.5 窗口分割"></a>1.5 窗口分割</h5><blockquote><p>subplot()函数用于图形窗口的分割，即在同一个图形窗口可以同时显示多个坐标轴的图形。此函数可以用于设置多图形的同时显示，便于观察比对。</p><p>subplot()函数的使用原理为首先把图形窗口分为多个区域，然后依次在各区域绘制图形，其调用格式如下。</p><p>subplot(m,n,p):函数把图形窗口分为m×n个绘图子区，在第p个绘图子区绘制图形，绘图子区的编号按行方向编号。</p></blockquote><h3 id="2-特殊二维图形"><a href="#2-特殊二维图形" class="headerlink" title="2.特殊二维图形"></a>2.特殊二维图形</h3><blockquote><p>MATLAB为用户提供的特殊二维图形包括条形图、面积图、饼图、散点图、柱状图、罗盘图、羽毛图、矢量图、杆型图、阶梯图、极坐标图、等势图等</p></blockquote><h5 id="2-1-条形图"><a href="#2-1-条形图" class="headerlink" title="2.1 条形图"></a>2.1 条形图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar()函数:绘制垂直条形图</span><br><span class="line">barh()函数:绘制水平条形图</span><br></pre></td></tr></table></figure><h5 id="2-2-直方图"><a href="#2-2-直方图" class="headerlink" title="2.2 直方图"></a>2.2 直方图</h5><blockquote><p>直方图和条形图区别：</p><p>（1）直方图是用矩阵的面积表示各组数据的多少，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，其高度与宽度均有实际意义。条形图是用条形的长度表示各数据的多少，其宽度则是固定的，可任意设置，无实际意义；</p><p>（2）直方图的各矩形由于分组数据的连续性，一般情况下是连续排列的，而条形图在条形没有设置过大的情况下是分开排列的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hist()函数:绘制直方图</span><br><span class="line">rose()函数:在极坐标内绘制直方图</span><br></pre></td></tr></table></figure><h5 id="2-3-面积图"><a href="#2-3-面积图" class="headerlink" title="2.3 面积图"></a>2.3 面积图</h5><blockquote><p>面积图将数据点显示为一组由线连接的点，并填充线下方的所有区域</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area()函数:绘制面积图</span><br></pre></td></tr></table></figure><h5 id="2-4-饼图"><a href="#2-4-饼图" class="headerlink" title="2.4 饼图"></a>2.4 饼图</h5><blockquote><p>饼图是一个被划分为多个扇区的圆形图表，每个扇区代表一个数据项，描述各数据项占数据总和的比例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pie()函数:绘制二维饼图</span><br><span class="line">pie3()函数:绘制三维饼图</span><br></pre></td></tr></table></figure><h5 id="2-5-散点图"><a href="#2-5-散点图" class="headerlink" title="2.5 散点图"></a>2.5 散点图</h5><blockquote><p>散点图将数据序列显示为一组点。在回归分析中较为常用，反映了因变量随自变量而变化的趋势，便于观察两者关系</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scatter()函数:绘制散点图</span><br></pre></td></tr></table></figure><h5 id="2-6-排列图"><a href="#2-6-排列图" class="headerlink" title="2.6 排列图"></a>2.6 排列图</h5><blockquote><p>排列图又称累托（Pareto）图，用于寻找主要问题或主要原因所使用的图。它是由两个纵坐标、一个横坐标、几个按高低顺序依次排列的条形和一条累计百分比的折线组成。其中，左纵坐标表示频数，右纵坐标表示频率，横坐标表示各因素，按各因素高低从左到右显示，折线表示累积的频率。通过排列图可以较好的分析各因素的重要性</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pareto()函数:绘制排列图</span><br></pre></td></tr></table></figure><h5 id="2-7-罗盘图"><a href="#2-7-罗盘图" class="headerlink" title="2.7 罗盘图"></a>2.7 罗盘图</h5><blockquote><p>罗盘图绘制于一个圆盘中，从原点出发的箭头，箭头在圆盘中的角度用于表示数据的角度，箭头的长短用于表示数据的大小</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compass()函数:绘制罗盘图</span><br></pre></td></tr></table></figure><h5 id="2-8-羽毛图"><a href="#2-8-羽毛图" class="headerlink" title="2.8 羽毛图"></a>2.8 羽毛图</h5><blockquote><p>羽毛图是以箭头的形式绘制矢量数据，与罗盘图不同的是数据绘制于直角坐标系中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feather()函数:绘制羽毛图</span><br></pre></td></tr></table></figure><h5 id="2-9-矢量图"><a href="#2-9-矢量图" class="headerlink" title="2.9 矢量图"></a>2.9 矢量图</h5><blockquote><p>矢量图通常和其他图形一起使用，用于显示数据的方向</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiver()函数:绘制矢量图</span><br></pre></td></tr></table></figure><h5 id="2-10-杆型图"><a href="#2-10-杆型图" class="headerlink" title="2.10 杆型图"></a>2.10 杆型图</h5><blockquote><p>杆型图主要用来表示离散数据的变化规律，以离散的圆点表示每个数据点，并用线段把数据点和坐标轴连接起来，形如杆型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stem()函数:绘制杆型图</span><br></pre></td></tr></table></figure><h5 id="2-11-阶梯图"><a href="#2-11-阶梯图" class="headerlink" title="2.11 阶梯图"></a>2.11 阶梯图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stairs()函数:绘制阶梯图</span><br></pre></td></tr></table></figure><h5 id="2-12-极坐标图"><a href="#2-12-极坐标图" class="headerlink" title="2.12 极坐标图"></a>2.12 极坐标图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polar()函数:绘制极坐标图,在笛卡儿坐标系平面上绘制该函数，且画出极坐标形式的栅格</span><br></pre></td></tr></table></figure><h5 id="2-13-等值线图"><a href="#2-13-等值线图" class="headerlink" title="2.13 等值线图"></a>2.13 等值线图</h5><blockquote><p>等值线图可用于绘制地理数据中的等高图、气象数据中的等势图等。等值线图在二维图形中把第三维中相同大小的数据连接为等值线，一定程度上可以表示第三维的信息，同时，等值线图相比三维图更容易观察数据之间的关系，被广泛地应用于各个领域</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contour()函数:绘制二维等值线图</span><br><span class="line">contourf()函数:绘制带填充的二维等值线图</span><br><span class="line">clabel()函数:在等值线图上添加数据标签</span><br></pre></td></tr></table></figure><h5 id="2-14-曲线误差添加"><a href="#2-14-曲线误差添加" class="headerlink" title="2.14 曲线误差添加"></a>2.14 曲线误差添加</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errorbar()函数:绘制曲线误差</span><br></pre></td></tr></table></figure><h3 id="3-三维图形"><a href="#3-三维图形" class="headerlink" title="3.三维图形"></a>3.三维图形</h3><h5 id="3-1-三维图形绘制"><a href="#3-1-三维图形绘制" class="headerlink" title="3.1 三维图形绘制"></a>3.1 三维图形绘制</h5><blockquote><p>三维网格图形是指在三维空间内连接相邻数据点，形成网格。在MATLAB中绘制三维网格图的函数主要有mesh()、meshc()和meshz()，另外函数ezmesh()、ezmeshc()、ezmeshz()可根据函数表达式直接绘制相应的三维网格图</p><p>由于网格线是不透明的，绘制的三维网格图有时只能显示前面的图形部分，而后面的部分可能被网格线遮住了，没有显示出来。MATLAB中提供了命令hidden用于观察图形后面隐藏的网格</p><p>三维表面图也可以用来表示三维空间内数据的变化规律，与之前讲述的三维网格图的不同之处在于对网格的区域填充了不同的色彩。在MATLAB中绘制三维表面图的函数主要有surf()、surfc()和surfl()</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plot3()函数:绘制三维曲线</span><br><span class="line">meshgrid()函数:生成网格数据</span><br><span class="line">mesh()函数:绘制三维网格图</span><br><span class="line">meshc()函数:绘制带有等值线的三维网格图,不支持对图形网格线或等高线指定属性设置</span><br><span class="line">meshz()函数:绘制带有图形底边的三维网格图,不支持对图形网格线指定属性的设置</span><br><span class="line">contour3()函数:绘制三维等值线图,即在三维栅格图形上进一步添加等值线(类似于二维等值线图绘制函数contour())</span><br><span class="line">slice()函数:绘制三维切片图,三维切片图可形象地称为“四维图”，可以在三维空间内表达第四维的信息，用颜色来标识第四维数据的大小</span><br><span class="line">waterfall()函数:瀑布图</span><br><span class="line">cylinder()函数:生成关于z轴旋转对称的柱面体,结合surf()或mesh()生成柱面体的三维曲面图</span><br><span class="line">sphere()函数:在直角坐标系内绘制球形图</span><br><span class="line">ellipsoid()函数:生成绘制椭圆球体图的坐标数据,结合surf()或mesh()绘制三维椭球体图</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据可视化笔记</title>
      <link href="/2022/07/11/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/11/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>图表基本组成</li></ul><p>画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等</p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220711162907853.png" alt=""></p><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><blockquote><p>用于数据可视化、绘制各种图表</p></blockquote><ul><li><code>matplotlib</code>三步法绘制图表</li></ul><blockquote><ul><li>引入<code>matplotlib</code>模块</li><li>使用其提供的<code>plot</code>等方法绘制图表</li><li>运行程序</li></ul></blockquote><h3 id="图表常用设置"><a href="#图表常用设置" class="headerlink" title="图表常用设置"></a>图表常用设置</h3><ul><li>基本绘图函数</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.plot(x,y,format_string,**kwargs)</span><br></pre></td></tr></table></figure><blockquote><ul><li>x/y：x/y轴数据</li><li>format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式</li><li>kwargs：键值参数，相当于一个字典</li></ul></blockquote></blockquote><ul><li>线条颜色设置</li></ul><blockquote><p><code>color</code>参数设置线条颜色</p><blockquote><ul><li>通用颜色</li><li>其他颜色</li></ul></blockquote></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">设置值</th><th style="text-align:center">说明</th><th style="text-align:center">设置值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">蓝色</td><td style="text-align:center">y</td><td style="text-align:center">黄色</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">绿色</td><td style="text-align:center">k</td><td style="text-align:center">黑色</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">红色</td><td style="text-align:center">w</td><td style="text-align:center">白色</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">蓝绿色</td><td style="text-align:center">#FF00FF</td><td style="text-align:center">紫色</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">洋红色</td><td style="text-align:center">0.5</td><td style="text-align:center">灰度值字符串</td></tr></tbody></table></div><ul><li>线条样式设置</li></ul><blockquote><p><code>linestyle</code>参数设置线条样式</p><blockquote><ul><li>线条样式<ul><li>实线：’-‘</li><li>双划线：’—‘</li><li>点划线：’-.’</li><li>虚线：’:’</li></ul></li><li>标记样式<ul><li><code>marker</code>参数设置</li><li><code>markerfacecolor</code>可以修改标记的颜色，简写为<code>mfc</code></li></ul></li></ul></blockquote></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">设置值</th><th style="text-align:center">说明</th><th style="text-align:center">设置值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">点标记</td><td style="text-align:center">1</td><td style="text-align:center">下花三角标记</td></tr><tr><td style="text-align:center">,</td><td style="text-align:center">像素标记</td><td style="text-align:center">2</td><td style="text-align:center">上花三角标记</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">实心圆标记</td><td style="text-align:center">3</td><td style="text-align:center">左花三角标记</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">倒三角标记</td><td style="text-align:center">4</td><td style="text-align:center">右花三角标记</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">上三角标记</td><td style="text-align:center">s</td><td style="text-align:center">实心正方形标记</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">右三角标记</td><td style="text-align:center">p</td><td style="text-align:center">实心五角形标记</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">左三角标记</td><td style="text-align:center">*</td><td style="text-align:center">星形标记</td></tr></tbody></table></div><ul><li>画布设置</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.figure(num=None,figure=None,dpi=None,facecolor=None,edgecolor=None,frameon=True)</span><br></pre></td></tr></table></figure><blockquote><ul><li>num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布</li><li>figsize：指定画布的宽和高，单位为英寸</li><li>dpi：指定绘图对象的分辩率，即每英寸包含多少个像素，默认值为80。像素越大，画布越<br>  大</li><li>facecolor：背景颜色</li><li>edgecolor：边框颜色</li><li>frameon：是否显示边框，默认值为True，绘制边框，如果为False，则不绘制边框</li></ul></blockquote></blockquote><ul><li>坐标轴设置</li></ul><blockquote><ul><li>设置坐标轴标题：xlabel/ylabel函数</li><li>设置坐标轴刻度：xticks/yticks函数</li><li>设置坐标轴范围：xlim/ylim函数</li><li>设置网格线：grid()函数 参数与plot函数相差不大</li></ul><blockquote><p>处理中文显示：matplotlib.pyplot.rcParams[‘font.sans-serif’]=[‘SimHei’]</p></blockquote></blockquote><ul><li>标签/标题/图例设置</li></ul><blockquote><ul><li>添加文本标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.text(x,y,s,**kwargs)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">通用绘图参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">fontsize</td><td style="text-align:center">字体大小</td></tr><tr><td style="text-align:center">ha</td><td style="text-align:center">水平对齐方式</td></tr><tr><td style="text-align:center">va</td><td style="text-align:center">垂直对齐方式</td></tr></tbody></table></div><ul><li>设置标题和图例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.title()</span><br><span class="line">matplotlib.pyplot.legend(loc=&#x27;best&#x27;)</span><br></pre></td></tr></table></figure></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">描述</th><th style="text-align:center">位置</th><th style="text-align:center">描述</th><th style="text-align:center">位置</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">best</td><td style="text-align:center">自适应</td><td style="text-align:center">upper right</td><td style="text-align:center">右上方</td><td style="text-align:center">upper left</td><td style="text-align:center">左上方</td></tr><tr><td style="text-align:center">lower right</td><td style="text-align:center">右下方</td><td style="text-align:center">lower left</td><td style="text-align:center">左下方</td><td style="text-align:center">right</td><td style="text-align:center">右侧</td></tr><tr><td style="text-align:center">center left</td><td style="text-align:center">左中间</td><td style="text-align:center">center right</td><td style="text-align:center">右中间</td><td style="text-align:center">upper center</td><td style="text-align:center">上中间</td></tr><tr><td style="text-align:center">center</td><td style="text-align:center">正中央</td><td style="text-align:center">lower center</td><td style="text-align:center">下中间</td><td style="text-align:center"></td></tr></tbody></table></div><blockquote><p>直接使用plt.legend(‘图例示例’)会显示不全，这时需修改为plt.legend((‘图例示例’,))</p></blockquote><ul><li>文本注释设置</li></ul><blockquote><ul><li>添加注释：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.annotate(s,xy,xytext,xycoords,arrowprops)</span><br></pre></td></tr></table></figure><ul><li>调整图表与画布边缘间距</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotli  b.pyplot.subplots_adjust(left,right,top,bottom)</span><br></pre></td></tr></table></figure><ul><li>坐标轴刻度线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.tick_params(bottom,left,right,top)</span><br><span class="line">matplotlib.pyplot.rcParams[&#x27;xtick.direction&#x27;]=&#x27;in&#x27;</span><br><span class="line">matplotlib.pyplot.rcParams[&#x27;ytick.direction&#x27;]=&#x27;out&#x27;</span><br></pre></td></tr></table></figure></blockquote><h3 id="常用图表绘制"><a href="#常用图表绘制" class="headerlink" title="常用图表绘制"></a>常用图表绘制</h3><ul><li>柱状图</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.bar(x,height,width,*,align=&#x27;center&#x27;,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><blockquote><ul><li>x：x轴数据</li><li>height/width：高度/宽度</li><li>align：对齐方式</li><li>kwargs：关键字参数</li></ul></blockquote></blockquote><ul><li>直方图</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.hist(x,bins)</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><blockquote><ul><li>x：数据集，最终直方图将对数据集进行统计</li><li>bins：统计数据的区间分布</li></ul></blockquote></blockquote><ul><li>饼形图</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.pie(x,labels,colors,labeldistance,autopct,startangle,radius,center,textprops)</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><blockquote><ul><li>x：每一块饼形图的比例</li><li>labels：每一块饼形图外侧显示的说明文字</li><li>colors：</li><li>labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1</li><li>autopct：设置饼图百分比，可以使用格式化字符串或format函数</li><li>startangle：起始绘制角度，默认是x轴正方向逆时针</li><li>radius：饼图半径，默认值为1</li><li>center：浮点类型的列表，可选参数，默认值为(0,0)表示图表中心位置</li><li>textprops：设置标签和比例文字的格式，字典类型</li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu云服务器搭建内网穿透服务</title>
      <link href="/2022/07/09/Ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/07/09/Ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是在Ubuntu 18.04云服务器上搭建FRP服务端，在windows上搭建客户端进行内网穿透。</p></blockquote><ul><li><code>FRP</code>的<code>GitHub</code>下载链接：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></li></ul><blockquote><p>根据需要下载对应的<code>FRP</code>压缩包</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220709102047128.png" alt=""></p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><ul><li>下载对应版本的<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>删除<code>frpc.ini</code>和<code>frpc</code>两个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> frp_0.43.0_linux_amd64</span><br><span class="line">$ sudo <span class="built_in">rm</span> frpc.ini</span><br><span class="line">$ sudo <span class="built_in">rm</span> frpc</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<code>frps.ini</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim frps.ini</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000# 监听端口</span><br><span class="line">dashboard_port=7500# 后台端口</span><br><span class="line">dashboard_user=root# 登录账户</span><br><span class="line">dashboard_pwd=root# 登录密码</span><br><span class="line">token = 1234354sdhfgksa1435hn56k546# 与客户端一致(鉴权)</span><br></pre></td></tr></table></figure><ul><li>设置开机自启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> frps.service</span><br></pre></td></tr></table></figure><ul><li>启动/重启/停止<code>frps</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start/restart/stop frps.service</span><br></pre></td></tr></table></figure><ul><li>打开浏览器输入<code>ip:7500</code>，输入账号密码，能进入<code>frp</code>后台则服务器端配置成功</li></ul><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>浏览器直接下载对应的<code>FRP</code>压缩包</li><li>解压<code>FRP</code>压缩包</li><li>删除<code>frps.ini</code>和<code>frps</code></li><li>修改配置文件<code>frpc.ini</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x# 服务器ip地址</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 1234354sdhfgksa1435hn56k546</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.test.lyj.com</span><br></pre></td></tr></table></figure><ul><li>命令行运行<code>frpc.exe</code></li></ul><blockquote><p>直接双击运行frpc.exe会提示如下内容：</p><p>This is a command line tool.</p><p>You need to open cmd.exe and run it from there.</p></blockquote><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>下载对应版本的<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>删除<code>frps.ini</code>和<code>frps</code>两个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> frp_0.43.0_linux_amd64</span><br><span class="line">$ sudo <span class="built_in">rm</span> frps.ini</span><br><span class="line">$ sudo <span class="built_in">rm</span> frps</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<code>frpc.ini</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim frpc.ini</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x# 服务器ip地址</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 1234354sdhfgksa1435hn56k546</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.test.lyj.com</span><br></pre></td></tr></table></figure><ul><li>设置开机自启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> frpc.service</span><br></pre></td></tr></table></figure><ul><li>启动/重启/停止<code>frps</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start/restart/stop frpc.service</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.freesion.com/article/4194977840/">UBUNTU18.04安装FRP的配置说明</a></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx和FTP搭建文件服务器</title>
      <link href="/2022/07/09/nginx%E5%92%8CFTP%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/07/09/nginx%E5%92%8CFTP%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install nginx</span><br></pre></td></tr></table></figure><ul><li>开机自启</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure><ul><li>启动/重启/停止/查看状态 <code>nginx</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start/restart/stop/status nginx.service</span><br></pre></td></tr></table></figure><ul><li>查看<code>nginx</code>版本</li></ul><blockquote><p>下面的三种方法均可查看<code>nginx</code>的版本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -v<span class="comment"># 显示简要信息</span></span><br><span class="line">$ nginx -V<span class="comment"># 显示详细信息</span></span><br><span class="line">$ curl -i localhost</span><br></pre></td></tr></table></figure><ul><li>启动<code>nginx</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><ul><li>直接<code>ip</code>访问确定<code>nginx</code>是否正常启动</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220709141626253.png" alt=""></p><blockquote><p>出现上图字样表示<code>nginx</code>正常运行</p></blockquote><h1 id="nginx代理FTP服务器"><a href="#nginx代理FTP服务器" class="headerlink" title="nginx代理FTP服务器"></a>nginx代理FTP服务器</h1><ul><li>配置<code>FTP</code>访问服务</li></ul><blockquote><p>参照之前这篇文章：</p><p><a href="https://thee24lyj.github.io/2022/07/08/ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E7%8E%AF%E5%A2%83/">ubuntu云服务器搭建FTP环境</a></p></blockquote><ul><li>修改<code>nginx</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>的<code>http</code>块中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">                listen 8080;# 监听端口,一定要在防火墙开放该端口</span><br><span class="line">                server_name localhost;# 映射名称,ip访</span><br><span class="line"></span><br><span class="line">                location / &#123;</span><br><span class="line">                        alias  /home/ftp/lyj/;  # FTP服务器文件夹</span><br><span class="line">                        autoindex on;   # 打开文件目录列表</span><br><span class="line">                        index lyj;      # 设置欢迎页</span><br><span class="line">                        autoindex_exact_size on;# 显示文件大小，单位字节</span><br><span class="line">                        autoindex_localtime on; # 显示时间</span><br><span class="line">                        charset utf-8,gbk;      # 设置编码格式防止中文乱码</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>重启<code>nginx</code>服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><ul><li>浏览器访问<code>ip:8080</code>即可访问<code>FTP</code>服务的文件夹</li></ul><p>参考：</p><p><a href="https://blog.csdn.net/weixin_42337937/article/details/88903999?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-88903999-blog-89414679.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-88903999-blog-89414679.pc_relevant_aa&amp;utm_relevant_index=1">Nginx代理FTP服务器</a></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu云服务器搭建FTP环境</title>
      <link href="/2022/07/08/ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/07/08/ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：这里采用<code>vsftpd</code>在<code>Ubuntu 18.04</code>云服务器上搭建<code>FTP</code>服务，支持匿名用户、本地用户和虚拟用户三种类型。</p></blockquote><h1 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install vsftpd</span><br></pre></td></tr></table></figure><ul><li>使用<code>ps -ef | grep ftp</code>命令查看是否开启了<code>FTP</code>服务进程，有如下进程表示开启成功。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220705142920121.png" alt=""></p><ul><li>设置开机自启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> vsftpd</span><br></pre></td></tr></table></figure><ul><li>查看<code>FTP</code>服务状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status vsftpd.service</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220705143933305.png" alt=""></p><ul><li>启动/重启/停止<code>FTP</code>服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start/restart/stop vsftpd.service</span><br></pre></td></tr></table></figure><h1 id="匿名用户访问配置"><a href="#匿名用户访问配置" class="headerlink" title="匿名用户访问配置"></a>匿名用户访问配置</h1><ul><li>创建FTP存放目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /home/ftp</span><br><span class="line">$ <span class="built_in">cd</span> /home/ftp</span><br><span class="line">$ <span class="built_in">mkdir</span> anonymous<span class="comment"># 匿名访问目录</span></span><br></pre></td></tr></table></figure><ul><li>备份<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/vsftpd.conf /etc/vsftpd.conf.bak</span><br></pre></td></tr></table></figure><ul><li>修改<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>需要修改内容如下(配置匿名用户只有读权限)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Allow anonymous FTP? (Disabled by default).</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">anon_root=/home/ftp/anonymous</span><br><span class="line">no_anon_password=YES</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><h1 id="本地用户访问配置"><a href="#本地用户访问配置" class="headerlink" title="本地用户访问配置"></a>本地用户访问配置</h1><ul><li>添加<code>FTP</code>用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> /home/ftp/lyj<span class="comment"># 创建FTP用户家目录</span></span><br><span class="line">$ sudo useradd -d /home/ftp/lyj -s /bin/bash ftpuser<span class="comment"># 添加FTP用户ftpuser</span></span><br><span class="line">$ sudo passwd ftpuser<span class="comment"># 添加密码</span></span><br><span class="line">$ sudo <span class="built_in">chown</span> ftpuser:ftpuser -R /home/ftp/lyj/<span class="comment"># 修改目录权限</span></span><br></pre></td></tr></table></figure><blockquote><p>查看<code>FTP</code>本地用户：<code>cat /etc/passwd | grep ftp</code></p><p>删除<code>FTP</code>用户：<code>sudo deluser --remove-home username</code></p></blockquote><ul><li>将新添加的<code>ftpuser</code>用户添加到<code>vsftpd.chroot_list</code>文件</li></ul><blockquote><p>这里是使<code>ftpuser</code>不被限制到主目录中，可以切换并访问其他目录的文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.chroot_list</span><br><span class="line"><span class="comment"># 直接添加ftpuser保存即可</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>需要修改内容如下(配置本地用户有读写权限)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Allow anonymous FTP? (Disabled by default).</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">anon_root=/home/ftp/anonymous</span><br><span class="line">no_anon_password=YES</span><br><span class="line">#</span><br><span class="line"># Uncomment this to allow local users to log in.</span><br><span class="line">local_enable=YES</span><br><span class="line">local_root=/home/ftp/lyj</span><br><span class="line">#</span><br><span class="line"># Uncomment this to enable any form of FTP write command.</span><br><span class="line">write_enable=YES</span><br><span class="line"></span><br><span class="line"># You may restrict local users to their home directories.  See the FAQ for</span><br><span class="line"># the possible risks in this before using chroot_local_user or</span><br><span class="line"># chroot_list_enable below.</span><br><span class="line"># 是否将所有用户限制在登录根目录内</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"># 是否锁定用户的chroot功能</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"># (default follows)</span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><h1 id="本地虚拟用户访问配置"><a href="#本地虚拟用户访问配置" class="headerlink" title="本地虚拟用户访问配置"></a>本地虚拟用户访问配置</h1><ul><li>创建本地无法登录的用户及其登录目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sueradd guest -d /var/ftp -s /bin/nologin</span><br><span class="line">sudo <span class="built_in">mkdir</span> /var/ftp/guest</span><br><span class="line">sudo <span class="built_in">chown</span> guest:guest -R /var/ftp</span><br></pre></td></tr></table></figure><ul><li>创建虚拟用户的文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /var/ftp/anonymous /var/ftp/admin /var/ftp/test</span><br></pre></td></tr></table></figure><ul><li>创建虚拟用户统一存放配置文件的文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /etc/vsftpd</span><br></pre></td></tr></table></figure><ul><li>创建用户数据库<code>ftpguests</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ftpguests</span><br><span class="line"><span class="comment"># 以下为添加内容,用户名及其密码独占一行</span></span><br><span class="line">admin</span><br><span class="line">admin_passwd</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">test_passwd</span><br></pre></td></tr></table></figure><ul><li>生成用户数据库<code>ftpguests.db</code></li></ul><blockquote><p>用到的工具为<code>db_load</code>，若没安装则执行<code>sudo apt install db-util</code>安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo db_load -T -t <span class="built_in">hash</span> -f ftpguests /etc/vsftpd/ftpguests.db</span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /etc/vsftpd/ftpguests.db</span><br></pre></td></tr></table></figure><ul><li>修改<code>pam</code>认证文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/pam.d/vsftpd /etc/pam.d/vsftpd.bak</span><br><span class="line">sudo vim /etc/pam.d/vsftpd</span><br></pre></td></tr></table></figure><p>在<strong>第一行</strong>添加如下内容：</p><blockquote><p>auth sufficient pam_userdb.so db=/etc/vsftpd/ftpguests<br>account sufficient pam_userdb.so db=/etc/vsftpd/ftpguests</p></blockquote><p>其中<code>sufficient</code>表示同时支持虚拟用户和本地用户</p><ul><li>建立虚拟用户的配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/admin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_root=/var/ftp</span><br><span class="line"># 具有读权限,查看文件夹/文件</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line"># 具有写权限,新建文件夹/文件</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line"># 具有修改权限,修改文件夹/文件</span><br><span class="line">anon_other_write_enable=YES</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_root=/var/ftp/test</span><br><span class="line"># 具有读权限,查看文件夹/文件</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line"># 具有写权限,新建文件夹/文件</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line"># 没有修改权限,不能修改文件夹/文件</span><br><span class="line">anon_other_write_enable=NO</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<code>/etc/vsftpd.conf</code></li></ul><blockquote><p>在上面本地用户访问配置基础上添加如下内容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启虚拟用户访问</span><br><span class="line">guest_enable=YES</span><br><span class="line"># 把虚拟用户映射到本地用户guest</span><br><span class="line">guest_usernaem=guest</span><br><span class="line"># 指定虚拟用户配置文件所在目录</span><br><span class="line">user_config_dir=/etc/vsftpd</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h3 id="1-使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题"><a href="#1-使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题" class="headerlink" title="1.使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题"></a>1.使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题</h3><ul><li>修改<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br><span class="line"></span><br><span class="line">#开启被动模式</span><br><span class="line">pasv_enable=YES</span><br><span class="line">#被动模式端口范围</span><br><span class="line">pasv_min_port=6000</span><br><span class="line">pasv_max_port=6010</span><br><span class="line">#需要加入外部ip，否则被动模式会失败</span><br><span class="line">pasv_address=云服务器外部ip地址</span><br><span class="line">pasv_addr_resolve=YES</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><blockquote><p>记得开放云服务器上对应的被动端口，否则无法访问。</p></blockquote><h3 id="2-限制本地用户在主目录后仍然能访问其他目录"><a href="#2-限制本地用户在主目录后仍然能访问其他目录" class="headerlink" title="2.限制本地用户在主目录后仍然能访问其他目录"></a>2.限制本地用户在主目录后仍然能访问其他目录</h3><blockquote><p>这里首先介绍一下<code>/etc/vsftpd.conf</code>配置文件中的三个相关参数，然后根据需要可以</p></blockquote><ul><li><code>chroot_local_user</code></li></ul><p>作用：是否将所有用户限制在主目录中，默认为NO表示不做限制，否则表示启用限制</p><ul><li><code>chroot_list_enable</code></li></ul><p>作用：是否启用限制用户的名单，默认为NO表示禁用，否则表示启用</p><ul><li><code>chroot_list_file</code></li></ul><p>作用：是否限制在主目录下用户名称的文件，对该文件中的用户是否限制则根据<code>chroot_local_user</code>和<code>chroot_list_enable</code>确定</p><div class="table-container"><table><thead><tr><th style="text-align:center">chroot_local_user=YES chroot_list_enable=YES</th><th style="text-align:center">所有用户均被限制在其主目录，chroot_list_file中的用户不受限制</th></tr></thead><tbody><tr><td style="text-align:center"><strong>chroot_local_user=YES chroot_list_enable=NO</strong></td><td style="text-align:center"><strong>所有用户均被限制在其主目录下</strong></td></tr><tr><td style="text-align:center"><strong>chroot_local_user=NO chroot_list_enable=YES</strong></td><td style="text-align:center"><strong>所有用户均不被限制， chroot_list_file中的用户受到限制</strong></td></tr><tr><td style="text-align:center"><strong>chroot_local_user=NO chroot_list_enable=NO</strong></td><td style="text-align:center"><strong>所有用户均不被限制在其主目录下</strong></td></tr></tbody></table></div><h3 id="3-报错500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot"><a href="#3-报错500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot" class="headerlink" title="3.报错500 OOPS: vsftpd: refusing to run with writable root inside chroot()"></a>3.报错500 OOPS: vsftpd: refusing to run with writable root inside chroot()</h3><ul><li>这是由于<code>vsftpd</code>从<code>2.3.5</code>之后增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限，如果检查发现还有写权限，就会报该错误。</li><li>网上有两种方法分别是：（1）<code>sudo chmod a-w /home/ftp/anonymous</code>(用户主目录) （2）在配置文件中添加<code>allow_writeable_choot=YES</code> ，但是我这里只有第一种方法可行，第二种没有效果，大家若遇到可以两种方法都尝试一下</li></ul><h3 id="4-其他错误"><a href="#4-其他错误" class="headerlink" title="4.其他错误"></a>4.其他错误</h3><ul><li><code>FileZilla</code>软件报错如下：</li></ul><blockquote><p>553 Could not create file.</p><p>错误:    严重文件传输错误</p></blockquote><p>一般可能是权限不够的问题，也有可能是磁盘空间已满的原因。</p><p>可以尝试修改文件权限(<code>777</code>)，或者修改文件所属用户</p><blockquote><p>550 Failed to change directory.</p><p>错误:    读取目录列表失败</p></blockquote><p>可能是权限问题，也可能是<code>SElinux</code>的<code>FTP</code>传输审核功能禁止切换目录，还可能是限制了用户对主目录的访问。</p><p>参考文章：</p><p><a href="https://www.toobug.cn/post/3629.html">Ubuntu下同时搭建支持匿名、本地、虚拟用户的ftp服务器</a></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX数学公式学习笔记</title>
      <link href="/2022/02/15/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/15/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：这篇文章是我学习<code>LaTeX</code>数学公式时根据<a href="https://www.bilibili.com/video/BV1no4y1U7At">数学公式怎么敲？LaTeX保姆级教程</a>讲解边看边写而成的学习笔记，留下作为记录.</p><blockquote><p>注意：这里由于网页不方便渲染<code>LaTeX</code>，因此我将<code>typora</code>中的<code>LaTeX</code>渲染效果变为图片，其下代码即该<code>LaTeX</code>代码.</p></blockquote></blockquote><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223637.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\delta</span>,<span class="keyword">\lambda</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Delta</span>,<span class="keyword">\Lambda</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\alpha</span>,<span class="keyword">\beta</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Alpha</span>,<span class="keyword">\Beta</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\phi</span>,,<span class="keyword">\varphi</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\epsilon</span>,<span class="keyword">\varepsilon</span><span class="keyword">\\</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220213162358.png" alt=""></p><h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><p><strong>英文字母只有在表示变量(或单一字符的函数名称)才使用斜体,其余情况使用罗马体(直立体)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223715.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a<span class="built_in">^</span>2,a<span class="built_in">_</span>1<span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;y+z&#125;,P<span class="built_in">_</span>&#123;ij&#125;<span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>i,x<span class="built_in">_</span>&#123;<span class="keyword">\rm</span> i&#125;,x<span class="built_in">_</span>&#123;<span class="keyword">\text</span> i&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\text</span>&#123;A B&#125;,<span class="keyword">\rm</span>&#123;A B&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\text</span> A B,<span class="keyword">\rm</span> A B<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\rm</span> A&#125; B<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\text</span>&#123;e&#125;,<span class="keyword">\text</span>&#123;i&#125;<span class="keyword">\\</span></span><br><span class="line">e,i</span><br></pre></td></tr></table></figure><blockquote><p>e:自然对数底数，为常数</p><p>i,j:叙述单位，常量</p></blockquote><h1 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223756.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125;,<span class="keyword">\frac</span> 1 2<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> 1&#123;x + y&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> &#123;<span class="keyword">\frac</span> 1 x + 1&#125;&#123;y + 1&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> &#123;<span class="keyword">\dfrac</span> 1 x + 1&#125;&#123;y + 1&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223822.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span> 2,<span class="keyword">\sqrt</span> &#123;x+y&#125;,<span class="keyword">\sqrt</span>[3] x</span><br></pre></td></tr></table></figure><blockquote><p>\frac (fraction,分数) \dfrac (display-style)</p><p>\sqrt (square root,平方根)</p></blockquote><h1 id="普通运算符"><a href="#普通运算符" class="headerlink" title="普通运算符"></a>普通运算符</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223848.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ -<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\times</span>,<span class="keyword">\cdot</span>,<span class="keyword">\div</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\pm</span>,<span class="keyword">\mp</span><span class="keyword">\\</span></span><br><span class="line">&gt;&lt;,<span class="keyword">\ge</span>,<span class="keyword">\le</span>,<span class="keyword">\gg</span>,<span class="keyword">\ll</span>,<span class="keyword">\ne</span>,<span class="keyword">\approx</span>,<span class="keyword">\equiv</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cap</span>,<span class="keyword">\cup</span>,<span class="keyword">\in</span>,<span class="keyword">\notin</span>,<span class="keyword">\subseteq</span>,<span class="keyword">\subsetneq</span>,<span class="keyword">\subsetneqq</span>,<span class="keyword">\varnothing</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\forall</span>,<span class="keyword">\exists</span>,<span class="keyword">\nexists</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\because</span>,<span class="keyword">\therefore</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathbb</span> R,<span class="keyword">\R</span>,<span class="keyword">\Q</span>,<span class="keyword">\N</span>,<span class="keyword">\Z</span><span class="built_in">_</span>+<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathcal</span> f,<span class="keyword">\mathscr</span> f<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathcal</span> F,<span class="keyword">\mathscr</span> F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223954.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\cdot</span>,<span class="keyword">\cdots</span>,<span class="keyword">\vdots</span>,<span class="keyword">\ddots</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\infty</span>,<span class="keyword">\partial</span>,<span class="keyword">\nabla</span>,<span class="keyword">\propto</span>,<span class="keyword">\degree</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224012.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sin</span> x,<span class="keyword">\sec</span> x,<span class="keyword">\cosh</span> x,<span class="keyword">\tan</span> x<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\log</span><span class="built_in">_</span>2 x,<span class="keyword">\ln</span> x,<span class="keyword">\lg</span> x<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> 0&#125; <span class="keyword">\frac</span> &#123;x&#125;&#123;<span class="keyword">\sin</span> x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> 0&#125; <span class="keyword">\frac</span> &#123;x&#125;&#123;<span class="keyword">\sin</span> x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\max</span> x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224033.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\text</span>&#123;MSE&#125;(x)</span><br></pre></td></tr></table></figure><blockquote><p>运算符名称超过一个字母时应用直立体</p></blockquote><h1 id="大型运算符"><a href="#大型运算符" class="headerlink" title="大型运算符"></a>大型运算符</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224050.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sum</span>,<span class="keyword">\prod</span><span class="keyword">\\</span><span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">\sum</span><span class="built_in">_</span>i,<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>N<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n x<span class="built_in">_</span>i&#125;&#123;<span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n x<span class="built_in">_</span>i&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224106.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\int</span>,<span class="keyword">\iint</span>,<span class="keyword">\iiint</span>,<span class="keyword">\oint</span>,<span class="keyword">\oiint</span>,<span class="keyword">\oiiint</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;-<span class="keyword">\infty</span>&#125;<span class="built_in">^</span>0 f(x)<span class="keyword">\,</span><span class="keyword">\text</span> d x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224121.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a<span class="keyword">\,</span>a<span class="keyword">\\</span></span><br><span class="line">a<span class="keyword">\ </span>a<span class="keyword">\\</span></span><br><span class="line">a<span class="keyword">\quad</span> a<span class="keyword">\\</span></span><br><span class="line">a<span class="keyword">\qquad</span> a</span><br></pre></td></tr></table></figure><h1 id="标注符号"><a href="#标注符号" class="headerlink" title="标注符号"></a>标注符号</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224141.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\vec</span> x,<span class="keyword">\overrightarrow</span> &#123;AB&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span> x,<span class="keyword">\overline</span> &#123;ABC&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220213170348.png" alt=""></p><h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224154.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\leftarrow</span>,<span class="keyword">\rightarrow</span>,<span class="keyword">\Rightarrow</span>,<span class="keyword">\Leftarrow</span>,<span class="keyword">\Leftrightarrow</span>,<span class="keyword">\longleftarrow</span>,<span class="keyword">\longrightarrow</span>,<span class="keyword">\Longrightarrow</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220213170617.png" alt=""></p><h1 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224214.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">([])<span class="keyword">\&#123;</span> <span class="keyword">\&#125;</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lceil</span>,<span class="keyword">\rceil</span>,<span class="keyword">\lfloor</span>,<span class="keyword">\rfloor</span>,||<span class="keyword">\\</span></span><br><span class="line">(0,<span class="keyword">\frac</span> 1 a)<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\left</span>(0,<span class="keyword">\frac</span> 1 a<span class="keyword">\right</span>)<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> &#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> x&#125;|<span class="built_in">_</span>&#123;x=0&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\left</span>.<span class="keyword">\frac</span> &#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> x&#125;<span class="keyword">\right</span>|<span class="built_in">_</span>&#123;x=0&#125;</span><br></pre></td></tr></table></figure><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224232.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line">a=b+c+d<span class="keyword">\\</span></span><br><span class="line">=e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224246.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a<span class="built_in">&amp;</span>=b+c+d<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>=e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line">a<span class="built_in">&amp;</span>=b+c+d<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>=e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure><h1 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224300.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(x)=</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\sin</span> x,<span class="built_in">&amp;</span>-<span class="keyword">\pi</span><span class="keyword">\le</span> x <span class="keyword">\le</span> <span class="keyword">\pi</span><span class="keyword">\\</span><span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>0,<span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;others&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224339.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224354.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224406.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224416.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224428.png" alt=""></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\bf</span> A,<span class="keyword">\bf</span> B<span class="built_in">^</span>&#123;<span class="keyword">\rm</span> T&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathbf</span> A,<span class="keyword">\mathbf</span> B<span class="built_in">^</span>&#123;<span class="keyword">\rm</span> T&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bf</span> B<span class="built_in">^</span>&#123;<span class="keyword">\text</span> T&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU配置CUDA和cuDNN</title>
      <link href="/2022/02/09/GPU%E9%85%8D%E7%BD%AECUDA%E5%92%8CcuDNN/"/>
      <url>/2022/02/09/GPU%E9%85%8D%E7%BD%AECUDA%E5%92%8CcuDNN/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：最近需要使用电脑的GPU进行并行计算，由于以前也配置过GPU的深度学习环境，但是并没有自己总结如何配置GPU的CUDA和CUDNN，因此趁着这次写了这篇文章，留作记录。</p></blockquote><h1 id="一、清理NVIDIA的CUDA和CUDNN"><a href="#一、清理NVIDIA的CUDA和CUDNN" class="headerlink" title="一、清理NVIDIA的CUDA和CUDNN"></a>一、清理NVIDIA的CUDA和CUDNN</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164204090.png" alt=""></p><ul><li>从未配置过GPU深度学习环境的话直接跳过</li><li>如果以前配置过对应的<code>GPU</code>深度学习环境，需要重新配置的话，计算机中<strong>至多</strong>保留上面的应用程序，卸载完成后记得用火绒等软件清理无用的注册表</li></ul><h1 id="二、安装CUDA-Toolkit"><a href="#二、安装CUDA-Toolkit" class="headerlink" title="二、安装CUDA Toolkit"></a>二、安装CUDA Toolkit</h1><h3 id="1、CUDA版本说明"><a href="#1、CUDA版本说明" class="headerlink" title="1、CUDA版本说明"></a>1、CUDA版本说明</h3><ul><li>使用命令<code>nvidia-smi</code>和<code>nvcc -V</code>均能查看安装的<code>CUDA</code>版本，但不同的是<code>nvidia-smi</code>查看的是显卡驱动程序安装的<code>CUDA</code>版本，<code>nvcc -V</code>是由<code>CUDA Toolkit</code>安装的<code>CUDA</code>版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122175005396.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122175022225.png" alt=""></p><blockquote><p>像使用GPU进行深度学习通常是指<code>nvcc -V</code>的<code>CUDA</code>版本</p></blockquote><ul><li>关于CUDA的不同版本可以参考文章<a href="https://blog.csdn.net/jslove1997/article/details/113737934">cuda 的driver API 和 runtime API</a>，个人认为写得比较详细</li></ul><h3 id="2、下载CUDA-Toolkit安装包"><a href="#2、下载CUDA-Toolkit安装包" class="headerlink" title="2、下载CUDA Toolkit安装包"></a>2、下载CUDA Toolkit安装包</h3><ul><li><a href="https://developer.nvidia.com/cuda-downloads">CUDA ToolKit下载官网地址</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164640340.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164925694.png" alt=""></p><ul><li>根据需要下载对应版本的<code>CUDA Toolkit</code>安装包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165145110.png" alt=""></p><h3 id="3、-安装CUDA-11-0"><a href="#3、-安装CUDA-11-0" class="headerlink" title="3、 安装CUDA 11.0"></a>3、 安装CUDA 11.0</h3><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164825897.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165309511.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165426651.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165537851.png" alt=""></p><blockquote><p>注意：我的电脑上已经安装了最新版本的驱动程序，所以才显示该警告，可不用理会。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165620985.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165638383.png" alt=""></p><blockquote><p>注意：精简是安装全部CUDA组件而非最小的组件</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165805807.png" alt=""></p><blockquote><p>注意：只选择CUDA组件且不选Visual Studio Integration，其他组件均不选</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165934489.png" alt=""></p><blockquote><p>注意：CUDA安装位置可根据需要放于不同位置，这里我直接使用默认位置。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165958542.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170336236.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170347346.png" alt=""></p><h3 id="4、CUDA安装完成"><a href="#4、CUDA安装完成" class="headerlink" title="4、CUDA安装完成"></a>4、CUDA安装完成</h3><ul><li>检查是否安装成功</li></ul><blockquote><ul><li>(1) 命令行运行<code>nvcc -V</code>显示对应的版本号表示安装成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170523191.png" alt=""></p><ul><li>(2) 查看环境变量</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170710595.png" alt=""></p><ul><li>(3) 运行对应程序，均显示<code>PASS</code>则安装成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122173224113.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122173326384.png" alt=""></p></blockquote><h1 id="三、cuDNN安装"><a href="#三、cuDNN安装" class="headerlink" title="三、cuDNN安装"></a>三、cuDNN安装</h1><h3 id="1、下载与CUDA相对应的cuDNN安装包"><a href="#1、下载与CUDA相对应的cuDNN安装包" class="headerlink" title="1、下载与CUDA相对应的cuDNN安装包"></a>1、下载与CUDA相对应的cuDNN安装包</h3><ul><li>新用户需要注册后才能下载</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170943567.png" alt=""></p><ul><li>同意后，点击<code>Archived cuDNN Releases</code>选择适合的<code>cuDNN</code>版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122171028474.png" alt=""></p><ul><li>选择适合于<code>CUDA</code>版本和平台的<code>cuDNN</code>下载</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122172212722.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122172808484.png" alt=""></p><h3 id="2、cuDNN安装"><a href="#2、cuDNN安装" class="headerlink" title="2、cuDNN安装"></a>2、cuDNN安装</h3><ul><li>将安装包解压后，直接将<code>cuda</code>文件夹下的三个文件夹移入对应的<code>CUDA</code> 安装目录下</li></ul><blockquote><p>我电脑上的CUDA安装目录为<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122173548567.png" alt=""></p><ul><li>到这里GPU深度学习环境就配置好了，可以愉快地开始学习深度学习了~~~</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github搭建个人博客</title>
      <link href="/2021/02/03/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/02/03/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h3><ul><li>新建名为<code>username.github.io</code>的仓库，例如<code>Thee24LYJ.github.io</code></li><li>创建成功后，博客网站访问地址就是<code>https://Thee24LYJ.github.io</code>(不区分大小写)</li></ul><h3 id="2-配置SSH-key"><a href="#2-配置SSH-key" class="headerlink" title="2.配置SSH key"></a>2.配置SSH key</h3><ul><li><p>提交代码需要拥有<code>github</code>权限，但是直接使用用户名和密码不安全，所以我们使用<code>ssh key</code>来解决本地和服务器的连接问题</p></li><li><p>使用<code>git bash</code>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh<span class="comment"># 检查本机已经存在的ssh密匙</span></span><br></pre></td></tr></table></figure><p>如果提示<code>No such file or directory</code>说明是第一次使用<code>git</code></p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span><span class="comment"># 邮件地址为GitHub绑定的邮箱</span></span><br></pre></td></tr></table></figure><p>然后连续三次回车，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开<code>github</code>主页，进入个人设置 -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code>：输入刚才复制的<code>Key</code>，<code>Title</code>随意</p></li><li><p>测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com </span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入<code>yes</code>，然后会看到：</p><p><code>Hi Thee24LYJ! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，说明<code>SSH</code>配置成功。</p></li><li><p>此时还需要配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Thee24LYJ&quot;</span>// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用hexo写博客"><a href="#3-使用hexo写博客" class="headerlink" title="3.使用hexo写博客"></a>3.使用hexo写博客</h3><ul><li><p><code>hexo</code>介绍</p><ul><li><p><code>Hexo</code>是一个简单、快速、强大的基于 <code>Github Pages</code> 的博客发布工具，支持<code>Markdown</code>格式，有众多优秀插件和主题</p></li><li><p>官网： <a href="http://hexo.io/">http://hexo.io</a></p></li><li>github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></li></ul></li><li><p>原理</p><p>由于<code>github pages</code>存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，所以<code>hexo</code>所做的就是将这些<code>md</code>文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到<code>github</code></p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure></li><li><p>初始化</p><p>新建一个文件夹用来存放博客代码，名字任意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /e/hexo/<span class="comment">#文件夹目录</span></span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容</p></li></ul><h3 id="4-上传代码"><a href="#4-上传代码" class="headerlink" title="4.上传代码"></a>4.上传代码</h3><ul><li><p>在上传代码到<code>github</code>之前，一定要记得先把你以前所有代码下载下来（虽然<code>github</code>有版本管理，但备份一下总是好的），因为从<code>hexo</code>提交代码时会把你以前的所有代码都删掉</p></li><li><p>使用命令<code>hexo d</code></p><ul><li><p><code>ssh key</code>要配置好</p></li><li><p><code>_config.yml</code>中<code>deploy</code>要配好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Thee24LYJ/Thee24LYJ.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>执行<code>hexo d</code>报错：<code>Deployer not found: github 或者 Deployer not found: git</code></p><p>原因是还需要安装一个插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul></li><li><p>保留<code>CNAME、README.md</code>文件</p><ul><li><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非<code>md</code>文件可以把他们放到<code>source</code>文件夹下，这里的所有文件都会原样复制（除了<code>md</code>文件）到<code>public</code>目录的：</p></li><li><p>由于<code>hexo</code>默认会把所有<code>md</code>文件都转换成<code>html</code>，包括<code>README.md</code>，所有需要每次生成之后、上传之前，手动将<code>README.md</code>复制到<code>public</code>目录，并删除<code>README.html</code>。</p></li></ul></li><li><p>常用<code>hexo</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-写博客"><a href="#5-写博客" class="headerlink" title="5.写博客"></a>5.写博客</h3><ul><li><p>定位到我们的<code>hexo</code>根目录，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure><p><code>hexo</code>会帮我们在<code>_posts</code>下生成相关<code>md</code>文件，我们只需要打开这个文件就可以开始写博客了</p><p>当然也可以直接自己新建<code>md</code>文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line"><span class="section">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;my-second-blog&quot;</span></span><br></pre></td></tr></table></figure><p>最终部署时生成：<code>hexo\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。</p></li><li><p>让博文内容不完全展示</p><p>  默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上<code>&lt;!--more--&gt;</code>即可设置文章展示的长度。</p></li><li><p>删除某篇文章</p><p>  直接删除<code>_posts</code>文件夹下的<code>.md</code>文章，然后执行<code>hexo g</code>重新生成删除文章后的网页，再执行<code>hexo d</code>上传</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
