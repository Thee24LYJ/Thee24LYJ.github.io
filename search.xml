<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git使用简要教程</title>
      <link href="/2023/03/12/git%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/"/>
      <url>/2023/03/12/git%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本操作"><a href="#1、基本操作" class="headerlink" title="1、基本操作"></a>1、基本操作</h1><ul><li>git init – 初始化仓库</li></ul><blockquote><p>初始化成功后该目录下会生成.git目录(也称为<strong>附属于该仓库的工作树</strong>)，储存管理当前目录内容所需的仓库数据</p></blockquote><blockquote><p>文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in C:/Users/G3/Desktop/git test/.git/</span><br></pre></td></tr></table></figure><ul><li>git status –查看仓库的状态</li></ul><blockquote><p>工作树和仓库在被操作的过程中，状态会不断发生变化</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><blockquote><p>所谓提交（Commit），是指“记录工作树中所有文件的当前状态”</p></blockquote><blockquote><p>新建README.md文件后的status如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ touch README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        README.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><ul><li>git add –向暂存区中添加文件</li></ul><blockquote><p>只是用Git仓库的工作树创建了文件，那么该文件并不会被记入Git仓库的版本管理对象当中。因此我们用git status命令查看README.md文件时，它会显示在Untracked files里。</p></blockquote><blockquote><p>要想让文件成为Git仓库的管理对象，就需要用gitadd命令将其加入暂存区（Stage或者Index）中。暂存区是提交之前的一个临时区域</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README.md</span><br></pre></td></tr></table></figure><ul><li>git commit –保存仓库的历史记录</li></ul><blockquote><p>该命令将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件</p></blockquote><blockquote><p>-m参数后的称为提交信息，是对该提交的概述</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git commit -m &quot;First commit&quot;</span><br><span class="line">[master (root-commit) 066eaf7] First commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure><p><strong>记录详细提交信息</strong></p><blockquote><p>不加-m参数，直接执行git commit命令，接着会打开对应的编辑器编辑提交信息，其格式如下：</p></blockquote><blockquote><p>第一行：用一行文字简述提交的更改内容</p><p>第二行：空行</p><p>第三行以后：记述更改的原因和详细内容<br><strong>终止提交</strong><br>在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止<br><strong>查看提交后状态</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><ul><li>git log –查看提交日志</li></ul><blockquote><p>查看以往仓库中提交的日志。包括可以查看什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别<br><strong>注：若日志较长无法完全显示，可回车往下显示一行，并且按”q”正常退出，若非正常退出则会造成继续输入命令时无法正常显示出来；若出现这样的情况可以输入<code>reset</code>命令重置git bash，也可关闭当前终端重新打开</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git log</span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2 (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><p><strong>只显示提交信息第一行</strong></p><blockquote><p>使用命令<code>git log --pretty=short</code>即可<br><strong>只显示指定目录、文件日志</strong><br>使用命令<code>git log filename</code>即可</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git log README.md</span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2 (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><p><strong>显示文件改动</strong></p><blockquote><p>使用命令<code>git log -p</code>即可在提交信息后显示文件的前后差别</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p</span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2 (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index e69de29..71b6fb7 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -0,0 +1,5 @@</span><br><span class="line">+# hello world</span><br><span class="line">+</span><br><span class="line">+This is a test, I am trying to learn git and do some excise(maybe).</span><br><span class="line">+</span><br><span class="line">+And this is a test file.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><ul><li>git diff –查看更改前后的差别</li></ul><blockquote><p>git diff命令可以查看工作树、暂存区、最新提交之间的差别</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 71b6fb7..5b82da4 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -2,4 +2,6 @@</span><br><span class="line"></span><br><span class="line"> This is a test, I am trying to learn git and do some excise(maybe).</span><br><span class="line"></span><br><span class="line">-And this is a test file.</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+The line be deleted. This is a description.</span><br><span class="line">+</span><br><span class="line">+And this is a new line.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><blockquote><p>由于我们尚未用git add命令向暂存区添加任何东西，所以程序只会显示工作树与最新提交状态之间的差别</p><p>+”号标出的是新添加的行，被删除的行则用“-”号标出</p></blockquote><p><em>使用git add README.md将README.md文件加入暂存区</em></p><p><strong>查看工作树和最新提交的差别</strong></p><blockquote><p>现在执行<code>git diff</code><br>命令，由于工作树和暂存区的状态并无差别，结果什么都不会显示。要查看与最新提交的差别，请执行命令<code>git diff HEAD</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git diff HEAD</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 71b6fb7..5b82da4 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -2,4 +2,6 @@</span><br><span class="line"></span><br><span class="line"> This is a test, I am trying to learn git and do some excise(maybe).</span><br><span class="line"></span><br><span class="line">-And this is a test file.</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+The line be deleted. This is a description.</span><br><span class="line">+</span><br><span class="line">+And this is a new line.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><blockquote><p>不妨养成这样一个好习惯：在执行<code>git commit</code>命令之前先执行<code>git diff HEAD</code>命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的HEAD是指向当前分支中最新一次提交的指针</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Add something new and delete something old&quot;</span><br><span class="line">[master a071997] Add something new and delete something old</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看提交日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit a07199771e6436b72a32b6fec45b90caf4ed8c1b (HEAD -&gt; master)</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:51:20 2022 +0800</span><br><span class="line"></span><br><span class="line">    Add something new and delete something old</span><br><span class="line"></span><br><span class="line">commit 02117edd38575da4a4de7a40be083cef2e7883b2</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    file context changed.</span><br><span class="line"></span><br><span class="line">    I am trying to change this context of the README.md file</span><br><span class="line">    changed by LYJ</span><br><span class="line"></span><br><span class="line">commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><h1 id="2、分支操作"><a href="#2、分支操作" class="headerlink" title="2、分支操作"></a>2、分支操作</h1><ul><li>git branch –显示分支一览表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>标 * 表示当前所在分支</p></blockquote><ul><li>git checkout –创建(添加参数-b)、切换分支</li></ul><blockquote><p>使用如下命令进行切换：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-A</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b feature-A</span><br><span class="line">Switched to a new branch &#x27;feature-A&#x27;</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-A)</span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-A)</span><br><span class="line">$ git branch</span><br><span class="line">* feature-A</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><blockquote><p>此时修改代码、执行git add命令提交，代码会提交到feature-A分支，像这样不断对一个分支（例如feature-A）进行提交的操作，我们称为“培育分支”</p></blockquote><p><strong>注：这里在feature-A修改代码并提交后再切换到master分支，代码不会有相应的改动</strong></p><p><strong>切换回上一个分支</strong></p><blockquote><p>用“-”（连字符）代替分支名，就可以切换至上一个分支。当然，将“-”替换成master同样可以切换到master分支</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-A)</span><br><span class="line">$ git checkout -</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p><strong>特性分支</strong></p><blockquote><p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master分支担当</p></blockquote><p><strong>主干分支</strong></p><blockquote><p>主干分支是刚才我们讲解的特性分支的原点，同时也是合并的终点。通常人们会用master分支作为主干分支</p></blockquote><ul><li>git merge –合并分支</li></ul><blockquote><p>使用命令<code>git merge --no-ff feature-A</code>，参数–no-ff是为了在历史记录中明确记录下本次分支合并</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git merge --no-ff feature-A</span><br><span class="line">hint: Waiting for your editor to close the file...</span><br><span class="line">[main 2022-02-22T06:12:20.690Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:12:21.135Z] ExtensionHostStarterWorker created</span><br><span class="line">[main 2022-02-22T06:12:23.323Z] Starting extension host with pid 13468 (fork() took 103 ms).</span><br><span class="line">[main 2022-02-22T06:12:23.324Z] ExtensionHostStarterWorker.start() took 106 ms.</span><br><span class="line">[main 2022-02-22T06:12:50.696Z] update#setState checking for updates</span><br><span class="line">[main 2022-02-22T06:12:50.792Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:13:03.000Z] Extension host with pid 13468 exited with code: 0, signal: null.</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md | 6 +++++-</span><br><span class="line"> 1 file changed, 5 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>git log –graph 以图表形式查看分支</li></ul><blockquote><p>用git log –graph命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br><span class="line">*   commit 4c6d8896e9e288b21a36aa840f0c536d8154d683 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: a071997 40d98e7</span><br><span class="line">| | Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| | Date:   Tue Feb 22 14:12:18 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |     Merge branch &#x27;feature-A&#x27; into master</span><br><span class="line">| |</span><br><span class="line">| * commit 40d98e76c16be3748c4cc78d178049b579450e13 (feature-A)</span><br><span class="line">|/  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">|   Date:   Tue Feb 22 14:01:11 2022 +0800</span><br><span class="line">|</span><br><span class="line">|       add to feature-A</span><br><span class="line">|</span><br><span class="line">* commit a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:51:20 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     Add something new and delete something old</span><br><span class="line">|</span><br><span class="line">* commit 02117edd38575da4a4de7a40be083cef2e7883b2</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     file context changed.</span><br><span class="line">|</span><br><span class="line">|     I am trying to change this context of the README.md file</span><br><span class="line">|     changed by LYJ</span><br><span class="line">|</span><br><span class="line">* commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">  Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">      First commit</span><br></pre></td></tr></table></figure><h1 id="3、更改提交操作"><a href="#3、更改提交操作" class="headerlink" title="3、更改提交操作"></a>3、更改提交操作</h1><ul><li>git reset –回溯历史版本</li></ul><blockquote><p>这里为熟悉对历史版本的操作，先回溯历史版本，创建一个名为fix-B的特性分支</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b fix-B</span><br><span class="line">Switched to a new branch &#x27;fix-B&#x27;</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git branch</span><br><span class="line">  feature-A</span><br><span class="line">* fix-B</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><strong>回溯到创建feature-A分支前</strong></p><blockquote><p>要让仓库的HEAD、暂存区、当前工作树回溯到指定状态，需要用到gitreset –hard命令。只要提供目标时间点的哈希值[插图]，就可以完全恢复至该时间点的状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git reset --hard a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">HEAD is now at a071997 Add something new and delete something old</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>已经成功回溯到特性分支（feature-A）创建之前的状态。由于所有文件都回溯到了指定哈希值对应的时间点上，README.md文件的内容也恢复到了当时的状态<br><strong>创建fix-B分支</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b fix-B</span><br><span class="line">Switched to a new branch &#x27;fix-B&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>修改代码内容并提交</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git commit -m &quot;fix-B change&quot;</span><br><span class="line">[fix-B e690648] fix-B change</span><br><span class="line"> 1 file changed, 9 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p><strong>推进至feature-A分支合并后的状态</strong></p><blockquote><p>首先恢复到feature-A分支合并后的状态。不妨称这一操作为“推进历史”</p></blockquote><blockquote><p>git log命令只能查看以当前状态为终点的历史日志。所以这里要使用gitreflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过git reset –hard命令恢复到回溯历史前的状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git reflog</span><br><span class="line">e690648 (HEAD -&gt; fix-B) HEAD@&#123;0&#125;: commit: fix-B change</span><br><span class="line">a071997 (master) HEAD@&#123;1&#125;: checkout: moving from master to fix-B</span><br><span class="line">a071997 (master) HEAD@&#123;2&#125;: reset: moving to a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">4c6d889 HEAD@&#123;3&#125;: checkout: moving from fix-B to master</span><br><span class="line">4c6d889 HEAD@&#123;4&#125;: checkout: moving from master to fix-B</span><br><span class="line">4c6d889 HEAD@&#123;5&#125;: merge feature-A: Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">a071997 (master) HEAD@&#123;6&#125;: checkout: moving from feature-A to master</span><br><span class="line">40d98e7 (feature-A) HEAD@&#123;7&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;8&#125;: checkout: moving from master to master</span><br><span class="line">a071997 (master) HEAD@&#123;9&#125;: checkout: moving from feature-A to master</span><br><span class="line">40d98e7 (feature-A) HEAD@&#123;10&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;11&#125;: checkout: moving from feature-A to master</span><br><span class="line">40d98e7 (feature-A) HEAD@&#123;12&#125;: commit: add to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;13&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;14&#125;: checkout: moving from feature-A to master</span><br><span class="line">a071997 (master) HEAD@&#123;15&#125;: checkout: moving from master to feature-A</span><br><span class="line">a071997 (master) HEAD@&#123;16&#125;: commit: Add something new and delete something old</span><br><span class="line">02117ed HEAD@&#123;17&#125;: commit: file context changed.</span><br><span class="line">066eaf7 HEAD@&#123;18&#125;: commit (initial): First commit</span><br></pre></td></tr></table></figure><blockquote><p>在日志中，我们可以看到commit、checkout、reset、merge等Git命令的执行记录。只要不进行Git的GC（Garbage Collection，垃圾回收），就可以通过日志随意调取近期的历史状态，就像给时间机器指定一个时间点，在过去未来中自由穿梭一般。即便开发者错误执行了Git操作，基本也都可以利用git reflog命令恢复到原先的状态</p></blockquote><blockquote><p>恢复到回溯前的历史状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (fix-B)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git reset --hard 4c6d889</span><br><span class="line">HEAD is now at 4c6d889 Merge branch &#x27;feature-A&#x27; into master</span><br></pre></td></tr></table></figure><p><strong>消除冲突</strong></p><p>现在只要合并fix-B分支，就可以得到我们想要的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git merge --no-ff fix-B</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict in README.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><blockquote><p>系统告诉我们README.md文件发生了冲突（Conflict）。系统在合并README.md文件时，feature-A分支更改的部分与本次想要合并的fix-B分支更改的部分发生了冲突。不解决冲突就无法完成合并，所以我们打开README.md文件解决这个冲突</p></blockquote><p><strong>提交解决后结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master|MERGING)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master|MERGING)</span><br><span class="line">$ git commit -m &quot;Fix conflict by LYJ&quot;</span><br><span class="line">[master 898df01] Fix conflict by LYJ</span><br></pre></td></tr></table></figure><ul><li>git commit –amend 修改提交信息</li></ul><blockquote><p>要修改上一条提交信息，可以使用git commit –amend命令。我们将上一条提交信息记为了”Fix conflict”，但它其实是fix-B分支的合并，解决合并时发生的冲突只是过程之一，这样标记实在不妥。于是，我们要修改这条提交信息</p></blockquote><blockquote><p>执行上述命令后再打开的编辑器中修改之前提交信息，之后保存文件并关闭编辑器</p></blockquote><blockquote><p>执行git log –graph命令，可以看到提交日志中的相应内容也已经被修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph</span><br><span class="line">*   commit a783495d5c1328df81c759b2c2521cae175d4ae6 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: 4c6d889 e690648</span><br><span class="line">| | Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| | Date:   Tue Feb 22 14:41:40 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |     Merge branch &#x27;fix-B&#x27;</span><br><span class="line">| |</span><br><span class="line">| * commit e6906488cc59494f376a0673f65d0da0dd260c97 (fix-B)</span><br><span class="line">| | Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| | Date:   Tue Feb 22 14:32:16 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |     fix-B change</span><br><span class="line">| |</span><br><span class="line">* |   commit 4c6d8896e9e288b21a36aa840f0c536d8154d683</span><br><span class="line">|\ \  Merge: a071997 40d98e7</span><br><span class="line">| |/  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">|/|   Date:   Tue Feb 22 14:12:18 2022 +0800</span><br><span class="line">| |</span><br><span class="line">| |       Merge branch &#x27;feature-A&#x27; into master</span><br><span class="line">| |</span><br><span class="line">| * commit 40d98e76c16be3748c4cc78d178049b579450e13 (feature-A)</span><br><span class="line">|/  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">|   Date:   Tue Feb 22 14:01:11 2022 +0800</span><br><span class="line">|</span><br><span class="line">|       add to feature-A</span><br><span class="line">|</span><br><span class="line">* commit a07199771e6436b72a32b6fec45b90caf4ed8c1b</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:51:20 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     Add something new and delete something old</span><br><span class="line">|</span><br><span class="line">* commit 02117edd38575da4a4de7a40be083cef2e7883b2</span><br><span class="line">| Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">| Date:   Mon Feb 21 14:32:23 2022 +0800</span><br><span class="line">|</span><br><span class="line">|     file context changed.</span><br><span class="line">|</span><br><span class="line">|     I am trying to change this context of the README.md file</span><br><span class="line">|     changed by LYJ</span><br><span class="line">|</span><br><span class="line">* commit 066eaf72002d80f78d7031f22e38db8c87f03a9e</span><br><span class="line">  Author: Thee24LYJ &lt;1579290423@qq.com&gt;</span><br><span class="line">  Date:   Mon Feb 21 14:25:49 2022 +0800</span><br><span class="line"></span><br><span class="line">      First commit</span><br></pre></td></tr></table></figure><h3 id="git-rebase-i-压缩历史"><a href="#git-rebase-i-压缩历史" class="headerlink" title="git rebase -i 压缩历史"></a>git rebase -i 压缩历史</h3><blockquote><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录</p></blockquote><ul><li>1.创建feature-C分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (master)</span><br><span class="line">$ git checkout -b feature-C</span><br><span class="line">Switched to a new branch &#x27;feature-C&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>作为feature-C的功能实现，我们在README.md文件中添加一行文字，并且故意留下拼写错误，以便之后修正.<br>提交这部分内容。这个小小的变更就没必要先执行git add命令再执行git commit命令了，我们用git commit -am命令来一次完成这两步操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &quot;add feature-C&quot;</span><br><span class="line">[feature-C a6c2906] add feature-C</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><ul><li>2.修正拼写错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index e49ccca..8b79141 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -17,4 +17,4 @@ hello world...!</span><br><span class="line"></span><br><span class="line"> ---</span><br><span class="line"></span><br><span class="line">-- faeture-C</span><br><span class="line">+- feature-C</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>然后提交</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3@DESKTOP-OM3KFRO MINGW64 ~/Desktop/git test (feature-C)</span><br><span class="line">$ git commit -am &quot;Fix typo&quot;</span><br><span class="line">[feature-C 508e161] Fix typo</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><blockquote><p>错字漏字等失误称作typo，所以我们将提交信息记为”Fix typo”。实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们</p></blockquote><ul><li>3.更改历史</li></ul><blockquote><p>将”Fix typo”修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><blockquote><p>用上述方式执行git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pickup a6c2906 add feature-C</span><br><span class="line">pickup 508e161 Fix typo</span><br><span class="line">---修改</span><br><span class="line">pickup a6c2906 add feature-C</span><br><span class="line">fixup 508e161 Fix typo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~2</span><br><span class="line">hint: Waiting for your editor to close the file...</span><br><span class="line">[main 2022-02-22T06:53:27.400Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:53:27.436Z] ExtensionHostStarterWorker created</span><br><span class="line">[main 2022-02-22T06:53:28.558Z] Starting extension host with pid 12816 (fork() took 51 ms).</span><br><span class="line">[main 2022-02-22T06:53:28.558Z] ExtensionHostStarterWorker.start() took 51 ms.</span><br><span class="line">[main 2022-02-22T06:53:57.413Z] update#setState checking for updates</span><br><span class="line">[main 2022-02-22T06:53:57.507Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:54:12.586Z] Extension host with pid 12816 exited with code: 0, signal: null.</span><br><span class="line">Successfully rebased and updated refs/heads/feature-C.</span><br></pre></td></tr></table></figure><blockquote><p>此时再查看日志会发现add feature-C的哈希值改变了，这样一来，Fix typo就从历史中被抹去，也就相当于Add feature-C中从来没有出现过拼写错误。这算是一种良性的历史改写</p></blockquote><ul><li>4.合并至master分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff feature-C</span><br><span class="line">hint: Waiting for your editor to close the file...</span><br><span class="line">[main 2022-02-22T06:59:46.546Z] update#setState idle</span><br><span class="line">[main 2022-02-22T06:59:46.575Z] ExtensionHostStarterWorker created</span><br><span class="line">[main 2022-02-22T06:59:47.640Z] Starting extension host with pid 15528 (fork() took 54 ms).</span><br><span class="line">[main 2022-02-22T06:59:47.640Z] ExtensionHostStarterWorker.start() took 55 ms.</span><br><span class="line">[main 2022-02-22T07:00:00.585Z] Waiting for extension host with pid 15528 to exit.</span><br><span class="line">[main 2022-02-22T07:00:00.585Z] Extension host with pid 15528 exited with code: 0, signal: null.</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md | 3 +++</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><h1 id="4、推送至远程仓库"><a href="#4、推送至远程仓库" class="headerlink" title="4、推送至远程仓库"></a>4、推送至远程仓库</h1><blockquote><p>前面三个部分都是针对本地单一仓库的操作，现在开始接触网络上的远程仓库</p></blockquote><h3 id="1-git-remote-add-–添加远程仓库"><a href="#1-git-remote-add-–添加远程仓库" class="headerlink" title="1.git remote add –添加远程仓库"></a>1.git remote add –添加远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/git-tutorial.git</span><br></pre></td></tr></table></figure><h3 id="2-git-push-–推送至远程仓库"><a href="#2-git-push-–推送至远程仓库" class="headerlink" title="2.git push –推送至远程仓库"></a>2.git push –推送至远程仓库</h3><ul><li>推送至master分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>像这样执行git push命令，当前分支的内容就会被推送给远程仓库origin的master分支。-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream（上游）。添加了这个参数，将来运行git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从origin的master分支获取内容，省去了另外添加参数的麻烦</p></blockquote><blockquote><p>执行该操作后，当前本地仓库master分支的内容将会被推送到GitHub的远程仓库中</p></blockquote><ul><li>推送至master以外的分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin feature-D</span><br></pre></td></tr></table></figure><h1 id="5、从远程仓库获取"><a href="#5、从远程仓库获取" class="headerlink" title="5、从远程仓库获取"></a>5、从远程仓库获取</h1><h3 id="1-git-clone-–获取远程仓库"><a href="#1-git-clone-–获取远程仓库" class="headerlink" title="1.git clone –获取远程仓库"></a>1.git clone –获取远程仓库</h3><ul><li>获取远程仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:用户名/git-tutorial.git</span><br></pre></td></tr></table></figure><blockquote><p>执行git clone命令后我们会默认处于master分支下，同时系统会自动将origin设置成该远程仓库的标识符。也就是说，当前本地仓库的master分支与GitHub端远程仓库（origin）的master分支在内容上是完全相同的</p></blockquote><p><strong>用git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息</strong></p><ul><li>获取远程的feature-D分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-D origin/feature-D</span><br></pre></td></tr></table></figure><blockquote><p>-b参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了origin&#x2F;feature-D，就是说以名为origin的仓库（这里指GitHub端的仓库）的feature-D分支为来源，在本地仓库中创建feature-D分支</p></blockquote><ul><li>向本地的feature-D分支提交更改<blockquote><p>这里跟之前的一样</p></blockquote></li><li>推送feature-D分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote><p>从远程仓库获取feature-D分支，在本地仓库中提交更改，再将feature-D分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育feature-D分支，实现某些功能</p></blockquote><h3 id="2-git-pull-–获取最新的远程仓库"><a href="#2-git-pull-–获取最新的远程仓库" class="headerlink" title="2.git pull –获取最新的远程仓库"></a>2.git pull –获取最新的远程仓库</h3><blockquote><p>使用git pull命令，将本地的feature-D分支更新到最新状态。当前分支为feature-D分支</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin feature-D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux后台运行程序命令</title>
      <link href="/2023/02/01/Linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/01/Linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Linux/Unix</code>下,通常只有守护进程可在脱离终端的情况下能继续执行,而普通进程在关闭终端时会因收到<code>SIGHUP</code>信号(挂起信号)而退出。当终端退出后,由该终端启动的后台程序自动退出，像<code>xshell</code>等软件使用<code>ssh</code>协议进行远程连接时，实质上还是相当于在远程服务器上的终端，因此运行的普通进程会在退出终端时(包括<code>xshell</code>等软件)自动退出，但是可以使用一些方法来使进程后台运行(已运行的进程在退出终端后仍能继续运行)</p><p>这里介绍<code>nohup</code>、<code>&amp;</code>和<code>screen</code>三种方式</p></blockquote><h1 id="amp-命令"><a href="#amp-命令" class="headerlink" title="&amp;命令"></a><code>&amp;</code>命令</h1><ul><li><code>&amp;</code>的作用是让程序在当前终端继续运行而终端可以接着执行其他命令，即在当前终端未被关闭的情况下在后台运行</li></ul><blockquote><p><code>ctrl z</code> 挂起进程并放入后台<br><code>ctrl c</code> 结束进程<br><code>jobs</code> 显示当前暂停的进程<br><code>bg %N</code> 使第N个任务在后台运行(%前有空格)<br><code>fg %N</code> 使第N个任务在前台运行</p></blockquote><h1 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a><code>nohup</code>命令</h1><blockquote><p><code>nohup</code> 英文全称 <code>no hang up</code>（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p><p>该命令在默认情况下（非重定向时），会输出一个名叫 <code>nohup.out</code> 的文件到当前目录下，如果当前目录的 <code>nohup.out</code> 文件不可写，输出重定向到 <code>$HOME/nohup.out</code> 文件中</p></blockquote><ul><li><p>语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> Command [Arg...] [&amp;]</span><br></pre></td></tr></table></figure><blockquote><p><code>Command</code>：要执行的命令。<br><code>Arg</code>：一些参数，可以指定输出文件。<br><code>&amp;</code>：让命令在后台执行，终端退出后命令仍旧执行<br>(实际测试不加<code>&amp;</code>退出终端也能执行，区别在于不加<code>&amp;</code>时终端会被该命令占用不能执行其他命令)</p></blockquote></li><li><p>例如后台执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> ./run_program &amp;</span><br></pre></td></tr></table></figure></li><li><p>需要重定向输出文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> ./run_program &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><blockquote><p><code>2&gt;&amp;1</code> 解释：<br>将标准错误 <code>2</code> 重定向到标准输出 <code>&amp;1</code> ，标准输出 <code>&amp;1</code> 再被重定向输入到 <code>test.log</code> 文件中。</p><p>0 – stdin (standard input，标准输入)<br>1 – stdout (standard output，标准输出)<br>2 – stderr (standard error，标准错误输出)</p></blockquote></li></ul><h1 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a><code>screen</code>命令</h1><blockquote><p>通过<code>screen</code>，将执行的命令放到<code>screen</code>后台任务里，<code>screen</code>任务作为一个进程在服务器后台执行</p><p>一般情况下，只要没有人去<code>kill</code>你的<code>screen</code>任务进程，服务器也没有关机或重启操作，<code>screen</code>任务都会平稳运行</p></blockquote><ul><li>创建<code>screen</code>任务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S task</span><br></pre></td></tr></table></figure><blockquote><p>这种方式创建的是一个有名字的<code>screen</code>任务，任务名为<code>task</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen</span><br></pre></td></tr></table></figure><blockquote><p>这种方式创建一个没有名字的<code>screen</code>任务</p></blockquote></li></ul><blockquote><p>执行以上两种命令的任意一种后就进入了<code>screen</code>的<code>shell</code>环境，此时执行的操作都是在该<code>shell</code>环境中运行的</p></blockquote><ul><li>查看已创建的<code>screen</code>任务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There is a screen on:</span><br><span class="line">11010.Minecraft(06/26/2022 12:52:06 PM)(Detached)</span><br><span class="line">1 Socket in /run/screen/S-root.</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>11010</code>就是该<code>screen</code>任务的<code>pid</code>，<code>detached</code>表示后台运行，而<code>Attached</code>表示正在终端中运行</p></blockquote></li></ul><blockquote><p>当<code>screen</code>的<code>shell</code>环境被进程占用而无法执行其他命令时，此时可以新开一个终端执行<code>screen -d pid</code>或<code>screen -d task</code>使其在后台运行，此时就能在原来的终端继续执行其他命令(其实可以直接关闭该终端，此时<code>scrren</code>中运行的进程仍然不受影响)</p></blockquote><ul><li><p>进入<code>screen</code>任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -r pid</span><br><span class="line">$ screen -r task</span><br></pre></td></tr></table></figure><blockquote><p>以上两种方式均可进入对应的<code>screen</code>任务，只不过分别是根据<code>pid</code>和任务名称进入该任务</p></blockquote></li><li><p>删除<code>screen</code>任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>进入<code>screen</code>任务后输入<code>exit</code>结束该任务</p></blockquote></li><li><p>结束进程</p></li></ul><p>根据对应进程<code>PID</code>使用如下命令结束：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 [PID]</span><br></pre></td></tr></table></figure><h3 id="这几种方式的对比"><a href="#这几种方式的对比" class="headerlink" title="这几种方式的对比"></a>这几种方式的对比</h3><ul><li><code>&amp;</code>只能在当前终端后台运行，终端退出后进程也会随之退出</li><li><code>nohup</code>则可以使进程在当前终端退出后也能接着运行</li><li><code>screen</code>跟<code>nohup</code>命令作用一样，但是某些进程使用<code>nohup</code>命令后台运行时可能无法正常工作，此时建议使用<code>screen</code>命令</li></ul><p>参考文章：<br><a href="https://www.runoob.com/linux/linux-comm-nohup.html">Linux nohup 命令</a></p><p><a href="https://blog.csdn.net/ZZQHELLO2018/article/details/109379425">Linux命令——后台运行（nohup 与 &amp;）</a></p><p><a href="https://blog.csdn.net/weixin_43557605/article/details/120265864">screen的使用方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台运行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile基础学习</title>
      <link href="/2022/12/28/Makefile%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/28/Makefile%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile基础学习"><a href="#Makefile基础学习" class="headerlink" title="Makefile基础学习"></a>Makefile基础学习</h1><blockquote><p><code>Makefile</code>：描述哪些文件需要编译、哪些文件需要重新编译的文件，使用<code>make</code>命令对工程进行编译</p><p>本篇文章参考《【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.7》的<code>3.3</code> <code>Makefile</code>基础部分</p></blockquote><h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h2><h3 id="1-1-代码"><a href="#1-1-代码" class="headerlink" title="1.1 代码"></a>1.1 代码</h3><ul><li><code>main.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calcu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,num;</span><br><span class="line"></span><br><span class="line">    input_int(&amp;a,&amp;b);</span><br><span class="line">    num=calcu(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d =%d\r\n&quot;</span>,a,b,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>input.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_int</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>calcu.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calcu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calcu</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>input.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INPUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_int</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_INPUT_H</span></span></span><br></pre></td></tr></table></figure><ul><li><code>calcu.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CALCU_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CALCU_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calcu</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_CALCU_H</span></span></span><br></pre></td></tr></table></figure><h3 id="1-2-编译运行"><a href="#1-2-编译运行" class="headerlink" title="1.2 编译运行"></a>1.2 编译运行</h3><ul><li><code>gcc</code>手动编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c calcu.c input.c -o main</span><br></pre></td></tr></table></figure><ul><li><code>Makefile</code>编译</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.o input.o calcu.o</span></span><br><span class="line">gcc -o main.o input.o calcu.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">gcc -c main.c</span><br><span class="line"><span class="section">input.o: input.c</span></span><br><span class="line">gcc -c input.c</span><br><span class="line"><span class="section">calcu.o: calcu.c</span></span><br><span class="line">gcc -c calcu.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>make</code>命令编译工程，<code>./main</code>执行可执行程序</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ ./main</span><br></pre></td></tr></table></figure><h2 id="二、Makefile语法"><a href="#二、Makefile语法" class="headerlink" title="二、Makefile语法"></a>二、Makefile语法</h2><h3 id="2-1-Makefile规则格式"><a href="#2-1-Makefile规则格式" class="headerlink" title="2.1 Makefile规则格式"></a>2.1 Makefile规则格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标...: 依赖文件集合...</span><br><span class="line">命令1</span><br><span class="line">命令2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p><code>make</code> 命令会为 <code>Makefile</code> 中的每个以 <code>TAB</code> 开始的命令创建一个 <code>Shell</code> 进程去执行</p></blockquote><ul><li>具体例子：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.o input.o calcu.o</span></span><br><span class="line">gcc -o main.o input.o calcu.o</span><br></pre></td></tr></table></figure><blockquote><p>这条规则的目标是 <code>main</code>，&#96;&#96;main.o、input.o、calcu.o<code>是生成</code>main<code>的依赖文件，如果要更新目标</code>main&#96;，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表</p></blockquote><ul><li><code>1.2</code>中<code>Makefile</code>解释如下：</li></ul><blockquote><p>首先更新第一条规则中的 <code>main</code>，第一条规则的目标成为默认目标，只要默认目标更新了那么就认为<code>Makefile</code> 的工作完成。</p><p>在第一次编译的时候由于 <code>main</code> 还不存在，因此第一条规则会执行，第一条规则依赖于文件 <code>main.o input.o 、calcu.o</code>这个三个<code>.o</code> 文件，这三个<code>.o</code> 文件目前还都没有，因此必须先更新这三个文件。<code>make</code> 会查找以这三个<code>.o</code> 文件为目标的规则并执行。</p><p>以 <code>main.o</code>为例，发现更新 <code>main.o</code> 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为<code>gcc–c main.c</code>，不链接编译 <code>main.c</code>只是生成 <code>main.o</code>，其它两个<code>.o </code>文件同理。</p><p>最后一个规则目标是 <code>clean</code>，它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 <code>clean</code> 的话可以直接使用命令<code>make clean</code>，执行以后就会删除当前目录下所有的<code>.o </code>文件以及 <code>main</code>，因此 <code>clean</code> 的功能就是清理工程</p></blockquote><ul><li>综上，<code>Make</code>的执行过程如下：</li></ul><blockquote><p>1、<code>make</code> 命令会在当前目录下查找以 <code>Makefile</code>(<code>makefile</code> 其实也可以)命名的文件。</p><p>2、当找到 <code>Makefile</code> 文件以后就会按照 <code>Makefile</code> 中定义的规则去编译生成最终的目标文件。</p><p>3、当发现目标文件不存在，或者目标所依赖的文件比目标文件新(也就是最后修改时间比目标文件晚)的话就会执行后面的命令来更新目标</p></blockquote><h3 id="2-2-Makefile变量及赋值"><a href="#2-2-Makefile变量及赋值" class="headerlink" title="2.2 Makefile变量及赋值"></a>2.2 Makefile变量及赋值</h3><h4 id="2-2-1-变量"><a href="#2-2-1-变量" class="headerlink" title="2.2.1 变量"></a>2.2.1 变量</h4><blockquote><p><code>Makefile</code>变量都是字符串，类似于<code>C</code>语言中的宏</p><p>这里使用变量<code>objects</code>表示<code>main.o input.o calcu.o</code>，引用变量的方式是<code>$(变量名)</code>，这里就是<code>$(objects)</code>来使用变量<code>objects</code></p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;#&quot;号开头表示注释</span></span><br><span class="line"><span class="comment"># Makefile变量使用</span></span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o main <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-赋值"><a href="#2-2-2-赋值" class="headerlink" title="2.2.2 赋值"></a>2.2.2 赋值</h4><blockquote><p><code>Makefile</code>赋值符有<code>=</code>、<code>:=</code>、<code>?=</code>以及<code>+=</code>四种，只不过第四种是变量追加</p></blockquote><ul><li>赋值符<code>=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = lyj</span><br><span class="line">curname = <span class="variable">$(name)</span></span><br><span class="line">name = thee</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">@echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>Make</code> 在执行过程中会自动输出命令执行过程，使用<code>@</code>表示不输出命令执行过程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">print</span></span><br><span class="line"><span class="comment"># 输出：thee</span></span><br><span class="line"><span class="comment"># 不加@输出结果如下</span></span><br><span class="line"><span class="comment"># echo curname: thee</span></span><br><span class="line"><span class="comment"># curname: thee</span></span><br></pre></td></tr></table></figure><blockquote><p>这里输出<code>thee</code>而不是<code>lyj</code>的原因是该赋值符<code>=</code>表示被赋值变量<code>curname</code>会根据赋值变量<code>name</code>的改变而改变即<code>name</code>最终的值(变量真实值取决于它所引用变量最后一次有效值)</p></blockquote><ul><li>赋值符<code>:=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = lyj</span><br><span class="line">curname := <span class="variable">$(name)</span></span><br><span class="line">name = thee</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">@echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">print</span></span><br><span class="line"><span class="comment"># 输出：lyj</span></span><br></pre></td></tr></table></figure><blockquote><p>这里输出<code>lyj</code>是因为赋值符<code>:=</code>不会使用后面的定义的变量，只能使用前面已经定义好的(类似于<code>C</code>语言中变量的赋值，赋值结束后就不能更改了)</p></blockquote><ul><li>赋值符<code>?=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curname ?= jack</span><br></pre></td></tr></table></figure><blockquote><p>该赋值符<code>?=</code>表示如果变量 <code>curname</code> 前面没有被赋值，那么此变量就赋值为<code>jack</code>，否则该变量的值不变</p></blockquote><ul><li>变量追加<code>+=</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = lyj</span><br><span class="line">name += thee</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">@echo name: <span class="variable">$(name)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line"><span class="comment"># 输出：lyj thee</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-Makefile模式规则"><a href="#2-2-3-Makefile模式规则" class="headerlink" title="2.2.3 Makefile模式规则"></a>2.2.3 Makefile模式规则</h4><ul><li><code>%</code>表示任意长度的非空字符串，类似于通配符，如<code>%.c</code>表示所有以<code>.c</code>结尾的文件</li></ul><h4 id="2-2-4-Makefile自动化变量"><a href="#2-2-4-Makefile自动化变量" class="headerlink" title="2.2.4 Makefile自动化变量"></a>2.2.4 Makefile自动化变量</h4><blockquote><p>自动化变量就是这种变量会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完</p></blockquote><ul><li>常用自动化变量(其中<code>$@/$&lt;/$^</code>较常用)</li></ul><table><thead><tr><th align="center">自动化变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>$@</code></td><td align="center">规则中的目标集合，在模式规则中，如果有多个目标的话，<code>$@</code>表示匹配模式中定义的目标集合</td></tr><tr><td align="center"><code>$%</code></td><td align="center">当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空</td></tr><tr><td align="center"><code>$&lt;</code></td><td align="center">依赖文件集合中的第一个文件，如果依赖文件是以模式(即<code>%</code>)定义的，那么<code>$&lt;</code>就是符合模式的一系列的文件集合</td></tr><tr><td align="center"><code>$?</code></td><td align="center">所有比目标新的依赖目标集合，以空格分开</td></tr><tr><td align="center"><code>$^</code></td><td align="center">所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，<code>$^</code>会去除重复的依赖文件，只保留一份</td></tr><tr><td align="center"><code>$+</code></td><td align="center">和<code>$^</code>类似，但是当依赖文件存在重复的话不会去除重复的依赖文件</td></tr><tr><td align="center"><code>$*</code></td><td align="center">这个变量表示目标模式中<code>%</code>及其之前的部分，如果目标是 <code>test/a.test.c</code>，目标模式为<code>a.%.c</code>，那么<code>$*</code>就是<code>test/a.test</code></td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o input.o calcu.o</span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o main <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c# 使用模式规则</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span><span class="comment"># 使用自动化变量</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><blockquote><p>这里使用模式规则和自动化变量将<code>1.2</code>中<code>Makefile</code>简化如上</p></blockquote><h4 id="2-2-5-Makefile伪目标"><a href="#2-2-5-Makefile伪目标" class="headerlink" title="2.2.5 Makefile伪目标"></a>2.2.5 Makefile伪目标</h4><blockquote><p><code>Makefile</code>中一般的目标名都是要生成的文件，而伪目标不代表真正的目标名，在执行 <code>make</code> 命令的时候通过指定这个伪目标来执行其所在规则的定义的命令</p></blockquote><blockquote><p>使用伪目标主要是为了避免 <code>Makefile</code> 中定义的执行命令的目标和工作目录下的实际文件出现名字冲突，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的</p></blockquote><blockquote><p>例如对于<code>clean</code>这个工程清理的代码，如果工作目录中存在<code>clean</code>的文件，此时执行<code>make clean</code>则会因为没有依赖文件而认定目标是最新的，后面的命令也不会执行，预先设想的清理功能也无法实现，为避免这个问题，将<code>clean</code>声明为伪目标，声明方式如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br></pre></td></tr></table></figure><p>这样不管当前工作目录是否存在名为<code>clean</code>的文件，执行<code>make clean</code>都会执行工程清理</p></blockquote><h4 id="2-2-6-Makefile条件判断"><a href="#2-2-6-Makefile条件判断" class="headerlink" title="2.2.6 Makefile条件判断"></a>2.2.6 Makefile条件判断</h4><ul><li>语法<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;条件关键字&gt;</span><br><span class="line">&lt;条件为真时执行的语句&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><ul><li>语法<code>2</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;条件关键字&gt;</span><br><span class="line">&lt;条件为真时执行的语句&gt;</span><br><span class="line">else</span><br><span class="line">&lt;条件为假时执行的语句&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><ul><li>条件关键词</li></ul><blockquote><p><code>ifeq/ifneq</code>、<code>ifdef/ifndef</code></p><ul><li><p><code>ifeq</code>使用方法(相同为真) 参数可以为函数返回值</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;参数 1&gt;, &lt;参数 2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;参数 1&gt;&#x27;,&#x27;&lt;参数 2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;参数 1&gt;&quot;</span>,<span class="string">&quot;&lt;参数 2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;参数 1&gt;&quot;</span>,&#x27;&lt;参数 2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;参数 1&gt;&#x27;,<span class="string">&quot;&lt;参数 2&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>ifneq</code>使用方法同<code>ifeq</code>(不相同为真)</p></li><li><p><code>ifdef</code>使用方法</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;变量名&gt;</span><br></pre></td></tr></table></figure><p>  如果”变量名”值非空，那么表达式为真，否则为假，”变量名”也可以是函数返回值</p></li><li><p><code>ifndef</code>使用方法同<code>ifdef</code>，但是含义与之相反</p></li></ul><blockquote><p>这里的<code>ifdef</code>和<code>ifndef</code>与<code>C</code>语言中含义类似</p></blockquote></blockquote><h4 id="2-2-7-Makefile函数使用"><a href="#2-2-7-Makefile函数使用" class="headerlink" title="2.2.7 Makefile函数使用"></a>2.2.7 Makefile函数使用</h4><blockquote><p><code>Makefile</code>支持函数，但无法自定义函数</p><p>函数用法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(函数名 参数集合)</span><br><span class="line"><span class="comment"># 或者是如下：</span></span><br><span class="line">$&#123;函数名 参数集合&#125;</span><br></pre></td></tr></table></figure><p>接下来是常用的几个函数</p></blockquote><ul><li><code>subst</code>函数：字符串替换</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 该函数功能是将字符串&lt;text&gt;中的&lt;from&gt;内容替换为&lt;to&gt;，返回被替换后的字符串</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> thee,lyj,hello thee!)</span></span><br><span class="line"><span class="comment"># 这里将thee替换为lyj,替换后的字符串为hello lyj!</span></span><br></pre></td></tr></table></figure><ul><li><code>patsubst</code>函数：模式字符串替换</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 此函数查找字符串&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配就用&lt;replacement&gt;来替换掉，&lt;pattern&gt;可以使用通配符&quot;%&quot;，表示任意长度的字符串，函数返回值就是替换后的字符串。如果&lt;replacement&gt;中也包涵&quot;%&quot;，那么&lt;replacement&gt;中的&quot;%&quot;将是&lt;pattern&gt;中的那个&quot;%&quot;所代表的字符串</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,a.c b.c c.c d.c)</span></span><br><span class="line"><span class="comment"># 这里将a.c b.c c.c d.c替换为a.o b.o c.o d.o</span></span><br></pre></td></tr></table></figure><ul><li><code>dir</code>函数：获取目录</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 此函数用来从文件名序列&lt;names&gt;中提取出目录部分，返回值是文件名序列&lt;names&gt;的目录部分</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;src/a.c&gt;)</span></span><br><span class="line"><span class="comment"># 返回目录部分即src/</span></span><br></pre></td></tr></table></figure><ul><li><code>notdir</code>函数：去除文件中的目录部分</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(notdir &lt;names...&gt;)</span><br><span class="line"># 此函数用与从文件名序列&lt;names&gt;中提取出文件名非目录部分</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;src/a.c&gt;)</span></span><br><span class="line"><span class="comment"># 返回非目录部分即a.c</span></span><br></pre></td></tr></table></figure><ul><li><code>foreach</code>函数：循环</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;所包含的表达式。每次&lt;text&gt;都会返回一个字符串，循环的过程中，&lt;text&gt;中所包含的每个字符串会以空格隔开，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串将会是函数 foreach 函数的返回值</span></span><br></pre></td></tr></table></figure><ul><li><code>wildcard</code>函数</li></ul><blockquote><p>通配符<code>%</code>只能用在规则中，只有在规则中它才会展开，如果在变量定义和函数使用时，通配符不会自动展开，这个时候就要用到函数 <code>wildcard</code>将其展开</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 获取当前目录所有.c文件，类似于%</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解C指针</title>
      <link href="/2022/12/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%E6%8C%87%E9%92%88/"/>
      <url>/2022/12/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章是《深入理解C指针》的阅读笔记。</p></blockquote><ul><li><code>printf</code>函数的格式</li></ul><table><thead><tr><th align="center">格式控制符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">按照十进制整型数据实际长度输出</td></tr><tr><td align="center">%ld</td><td align="center">输出长整形数据</td></tr><tr><td align="center">%md</td><td align="center">m为指定输出字段宽度，如果数据位数小于m则左端补空格，否则按照实际位数输出</td></tr><tr><td align="center">%u</td><td align="center">输出无符号整型数据，输出无符号整型也可以用 %d，这将无符号转换成有符号数，但没必要</td></tr><tr><td align="center">%c</td><td align="center">输出一个字符</td></tr><tr><td align="center">%f</td><td align="center">以小数形式输出单精度和双精度浮点数，不指定字段宽度由系统确定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入</td></tr><tr><td align="center">%.mf</td><td align="center">保留小数点后m位输出浮点数</td></tr><tr><td align="center">%o</td><td align="center">按照八进制整型数据输出</td></tr><tr><td align="center">%s</td><td align="center">输出字符串</td></tr><tr><td align="center">%x</td><td align="center">按照十六进制整型数据输出</td></tr></tbody></table><blockquote><p>%x、%X、%#x、%#X的区别</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">47</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#X\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="number">2f</span></span><br><span class="line"><span class="number">2F</span></span><br><span class="line"><span class="number">0x2f</span></span><br><span class="line"><span class="number">0X2F</span></span><br></pre></td></tr></table></figure><blockquote><p>输出<code>%d</code>、<code>\</code>和<code>&quot;&quot;</code></p><p>要输出<code>%d</code>只需在前面再加上一个<code>%</code>，要输出<code>\</code>只需在前面再加上一个<code>\</code>，要输出双引号也只需在前面加上一个<code>\</code>即可</p></blockquote><h2 id="1-3-指针操作符"><a href="#1-3-指针操作符" class="headerlink" title="1.3 指针操作符"></a>1.3 指针操作符</h2><table><thead><tr><th align="center">操作符</th><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">无</td><td align="center">声明指针</td></tr><tr><td align="center">*</td><td align="center">解引</td><td align="center">解引指针</td></tr><tr><td align="center">-&gt;</td><td align="center">指向</td><td align="center">访问指针引用结构的字段</td></tr><tr><td align="center">+</td><td align="center">加</td><td align="center">对指针做加法</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">对指针做减法</td></tr><tr><td align="center">&#x3D;&#x3D;&#x2F;!&#x3D;</td><td align="center">相等&#x2F;不等于</td><td align="center">比较两个指针</td></tr><tr><td align="center">&gt;&#x2F;&gt;&#x3D;&#x2F;&lt;&#x2F;&lt;&#x3D;</td><td align="center">大于&#x2F;大于等于&#x2F;小于&#x2F;小于等于</td><td align="center">比较两个指针</td></tr><tr><td align="center">(数据转换)</td><td align="center">转换</td><td align="center">改变指针的类型</td></tr></tbody></table><h3 id="1-3-1-指针算术运算"><a href="#1-3-1-指针算术运算" class="headerlink" title="1.3.1 指针算术运算"></a>1.3.1 指针算术运算</h3><ul><li>指针加整数</li></ul><blockquote><p>实际上加这个整数和指针数据类型对应字节数的乘积，如<code>sizeof(int)*10</code></p><p>大部分编译器允许给<code>void</code>指针做算术运算，但可能导致语法错误</p></blockquote><ul><li>指针减整数</li></ul><blockquote><p>同指针加整数，实际上减去该整数和指针数据类型对应字节数乘积</p></blockquote><ul><li>指针相减</li></ul><blockquote><p>指针相减得到两个地址差值(整数1,2…)，通常用于判断数组中的元素顺序</p></blockquote><h3 id="1-3-2-比较指针"><a href="#1-3-2-比较指针" class="headerlink" title="1.3.2 比较指针"></a>1.3.2 比较指针</h3><blockquote><p>指针可以用标准的比较操作符来比较。通常比较结果可以用来判断数组元素的相对顺序</p></blockquote><h2 id="1-4-指针常见用法"><a href="#1-4-指针常见用法" class="headerlink" title="1.4 指针常见用法"></a>1.4 指针常见用法</h2><h3 id="1-4-1-多层间接引用"><a href="#1-4-1-多层间接引用" class="headerlink" title="1.4.1 多层间接引用"></a>1.4.1 多层间接引用</h3><blockquote><p>双重指针：指针的指针</p><p>使用多层间接引用可以为代码编写使用提供更多的灵活性</p><p>例子：<code>mian()</code>函数的<code>argv</code>和<code>argv</code>参数</p></blockquote><h3 id="1-4-2-常量与指针"><a href="#1-4-2-常量与指针" class="headerlink" title="1.4.2 常量与指针"></a>1.4.2 常量与指针</h3><ul><li>指向常量的指针</li></ul><blockquote><p>定义指向常量的指针<code>const int *p</code>意味着不能通过指针修改它所引用的值，但能访问该值和改变指针(指向另一个常量)</p></blockquote><ul><li>指向非常量的常量指针</li></ul><blockquote><p>定义指向非常量的常量指针<code>int *const p</code>意味着不能改变指针，但能修改它指向的数据</p></blockquote><ul><li>指向常量的常量指针</li></ul><blockquote><p><code>const int *const p</code>，很少使用，该指针本身不能修改，指向的数据也不能通过它修改</p></blockquote><ul><li>指向”指向常量的常量指针”的指针</li></ul><blockquote><p><code>const int *const *p</code></p></blockquote><table><thead><tr><th align="center">指针类型</th><th align="center">指针是否可以修改</th><th align="center">指向的数据是否可以修改</th></tr></thead><tbody><tr><td align="center">指向非常量的指针</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">指向常量的指针</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">指向非常量的常量指针</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">指向常量的常量指针</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h1 id="第二章-C的动态内存管理"><a href="#第二章-C的动态内存管理" class="headerlink" title="第二章 C的动态内存管理"></a>第二章 C的动态内存管理</h1><blockquote><p>动态内存管理：使用分配和释放函数手动实现</p></blockquote><h2 id="2-1-动态内存分配"><a href="#2-1-动态内存分配" class="headerlink" title="2.1 动态内存分配"></a>2.1 动态内存分配</h2><h3 id="1-C中动态分配内存基本步骤"><a href="#1-C中动态分配内存基本步骤" class="headerlink" title="1.C中动态分配内存基本步骤"></a>1.<code>C</code>中动态分配内存基本步骤</h3><blockquote><p>1.用malloc类的函数分配内存</p><blockquote><p>malloc函数的参数指定要分配的字节数。如果成功，它会返回从堆上分配的内存的指针；如果失败则会返回空指针</p></blockquote><p>2.用这些内存支持应用程序</p><p>3.用free函数释放内存</p></blockquote><h3 id="2-内存泄露"><a href="#2-内存泄露" class="headerlink" title="2.内存泄露"></a>2.内存泄露</h3><blockquote><p>如果不再使用已分配的内存却未将其释放就会发生内存泄漏，导致内存泄漏的情况可能如下：</p><ul><li>丢失内存地址</li><li>应该调用<code>free</code>函数却没调用(隐式泄露)</li></ul></blockquote><h2 id="2-2-动态内存分配函数"><a href="#2-2-动态内存分配函数" class="headerlink" title="2.2 动态内存分配函数"></a>2.2 动态内存分配函数</h2><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">malloc</td><td align="center">从堆上分配内存</td></tr><tr><td align="center">realloc</td><td align="center">在之前分配的内存块的基础上，将内存重新分配为更大或者更小的部分</td></tr><tr><td align="center">calloc</td><td align="center">从堆上分配内存并清零</td></tr><tr><td align="center">free</td><td align="center">将内存块返回堆(释放内存)</td></tr></tbody></table><h3 id="2-2-1-malloc函数"><a href="#2-2-1-malloc函数" class="headerlink" title="2.2.1 malloc函数"></a>2.2.1 malloc函数</h3><blockquote><p>malloc函数从堆上分配一块内存，所分配的字节数由该函数唯一的参数指定，返回值是void指针，如果内存不足，就会返回NULL。此函数不会清空或者修改内存，所以我们认为新分配的内存包含垃圾数据</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>传递参数给这个函数时要小心，因为如果参数是负数就会引发问题。在有些系统中，参数是负数会返回NULL。如果malloc的参数是0，其行为是实现相关的：可能返回NULL指针，也可能返回一个指向分配了0字节区域的指针。如果malloc函数的参数是NULL，那么一般会生成一个警告然后返回0字节</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> *pi=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(pi!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//指针没有问题，执行后续操作</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//无效指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要不要强制类型转换</li></ul><blockquote><p>C引入void指针之前，在两种互不兼容的指针类型之间赋值需要对malloc使用显式转换类型以避免产生警告。因为可以将void指针赋值给其他任何指针类型，所以不再需要显式类型转换了</p><p>如果没有引用malloc的头文件，类型转换可能会有问题，编译器可能会产生警告。C默认函数返回整数，如果没有引用malloc的原型，编译器会抱怨你试图把int赋值给指针</p></blockquote><ul><li>分配内存失败</li></ul><blockquote><p>如果声明了一个指针，但没有在使用之前为它指向的地址分配内存，那么内存通常会包含垃圾，这往往会导致一个无效内存引用的错误</p></blockquote><ul><li>没有给malloc传递正确参数</li></ul><blockquote><p>malloc函数分配的字节数是由它的参数指定的，在用这个函数分配正确的字节数时要小心</p></blockquote><ul><li>确认分配的内存数</li></ul><blockquote><p>malloc可分配的最大内存是跟系统相关的，看起来这个大小由size_t限制。不过这个限制可能受可用的物理内存和操作系统的其他限制所影响。</p><p>执行malloc时应该分配所请求数量的内存然后返回内存地址。如果操作系统采用“惰性初始化”策略直到访问内存才真正分配的话会怎样？这时候万一没有足够的内存用来分配就会有问题，答案取决于运行时和操作系统。开发者一般不需要处理这个问题，因为这种初始化策略非常罕见</p></blockquote><ul><li>静态、全局指针和malloc</li></ul><blockquote><ul><li>初始化静态或局部变量时不能调用函数进行初始化</li></ul><blockquote><p>对于静态变量，可以通过在后面用一个单独的语句给变量分配内存来避免这个问题。但是全局变量不能用单独的赋值语句，因为全局变量是在函数和可执行代码外部声明的，赋值语句这类代码必须出现在函数中</p></blockquote></blockquote><h3 id="2-2-2-calloc函数"><a href="#2-2-2-calloc函数" class="headerlink" title="2.2.2 calloc函数"></a>2.2.2 calloc函数</h3><blockquote><p>calloc会在分配内存的同时清空内存即将内容置为0</p><p>calloc函数会根据numElements和elementSize两个参数的乘积来分配内存，并返回一个指向内存的第一个字节的指针。如果不能分配内存，则会返回NULL。此函数最初用来辅助分配数组内存</p><p>如果numElements或elementSize为0，那么calloc可能返回空指针。如果calloc无法分配内存就会返回空指针，而且全局变量errno会设置为ENOMEM（内存不足），这是POSIX错误码，有的系统上可能没有</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> numElements,<span class="type">size_t</span> elementSize)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-recalloc函数"><a href="#2-2-3-recalloc函数" class="headerlink" title="2.2.3 recalloc函数"></a>2.2.3 recalloc函数</h3><blockquote><p>我们可能需要时不时地增加或减少为指针分配的内存，如果需要一个变长数组这种做法尤其有用，realloc函数会重新分配内存并释放掉原来旧的内存</p><p>realloc函数返回指向内存块的指针。该函数接受两个参数，第一个参数是指向原内存块的指针，第二个是请求的大小。重新分配的块大小和第一个参数引用的块大小不同。返回值是指向重新分配的内存的指针</p><p>请求的大小可以比当前分配的字节数小或者大。如果比当前分配的小，那么多余的内存会还给堆，不能保证多余的内存会被清空。如果比当前分配的大，那么可能的话，就在紧挨着当前分配内存的区域分配新的内存，否则就会在堆的其他区域分配并把旧的内存复制到新区域。</p><p>如果大小是0而指针非空，那么就释放内存。如果无法分配空间，那么原来的内存块就保持不变，不过返回的指针是空指针，且errno会设置为ENOMEM</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">recalloc</span><span class="params">(<span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">第一个参数</th><th align="center">第二个参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">空</td><td align="center">无</td><td align="center">同malloc</td></tr><tr><td align="center">非空</td><td align="center">0</td><td align="center">释放内存</td></tr><tr><td align="center">非空</td><td align="center">小于原内存</td><td align="center">利用当前块分配更小的块</td></tr><tr><td align="center">非空</td><td align="center">大于原内存</td><td align="center">在当前位置或其他位置分配更大的块</td></tr></tbody></table><h3 id="2-2-4-alloca函数和变长数组"><a href="#2-2-4-alloca函数和变长数组" class="headerlink" title="2.2.4 alloca函数和变长数组"></a>2.2.4 alloca函数和变长数组</h3><blockquote><p>alloca函数（微软为malloca）在函数的栈帧上分配内存。函数返回后会自动释放内存。若底层的运行时系统不基于栈，alloca函数会很难实现，所以这个函数是不标准的，如果应用程序需要可移植就尽量避免使用它</p><p>C99引入了变长数组（VLA），允许函数内部声明和创建其长度由变量决定的数组</p></blockquote><h2 id="2-3-使用free函数释放内存"><a href="#2-3-使用free函数释放内存" class="headerlink" title="2.3 使用free函数释放内存"></a>2.3 使用free函数释放内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>指针参数应该指向由malloc类函数分配的内存的地址，这块内存会被返还给堆。尽管指针仍然指向这块区域，但是我们应该将它看成指向垃圾数据。稍后可能重新分配这块区域，并将其装进不同的数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><blockquote><p>内存释放后仍然有可能包含原值，pi变量仍然指向之前的地址，这种情况称为迷途指针</p></blockquote><blockquote><p>如果传递给free函数的参数是空指针，通常它什么都不做。如果传入的指针所指向的内存不是由malloc类的函数分配，那么该函数的行为将是未定义的</p></blockquote><h3 id="2-3-1-将释放的指针赋值为NULL"><a href="#2-3-1-将释放的指针赋值为NULL" class="headerlink" title="2.3.1 将释放的指针赋值为NULL"></a>2.3.1 将释放的指针赋值为NULL</h3><blockquote><p>已释放的指针仍然可能造成问题。如果我们试图解引一个已释放的指针，其行为将是未定义的，因此调用free将指针赋值为NULL，该技术目的是解决迷途指针问题</p></blockquote><h3 id="2-3-2-重复释放"><a href="#2-3-2-重复释放" class="headerlink" title="2.3.2 重复释放"></a>2.3.2 重复释放</h3><blockquote><p>指两次释放同一块内存，这种情况是不应该出现的。</p></blockquote><h2 id="2-4-迷途指针"><a href="#2-4-迷途指针" class="headerlink" title="2.4 迷途指针"></a>2.4 迷途指针</h2><blockquote><p>内存已经释放而指针还在引用原始指针，这样的指针就是迷途指针，迷途指针没有指向有效对象，也被称为过早释放</p></blockquote><blockquote><p>使用迷途指针会造成一系列问题：</p><ul><li>如果访问内存，则行为不可预期；</li><li>如果内存不可访问，则是<strong>段错误</strong>；</li><li>潜在的安全隐患。</li></ul></blockquote><h3 id="2-4-1-迷途指针示例"><a href="#2-4-1-迷途指针示例" class="headerlink" title="2.4.1 迷途指针示例"></a>2.4.1 迷途指针示例</h3><ul><li><p>执行free函数后继续访问或修改该内存</p></li><li><p>一个以上指针同时指向同一内存区域而其中一个指针被释放，另外一个指针就是迷途指针</p></li><li><p>指针在块语句中赋值为局部变量地址，该块语句出栈后地址不在有效，此时指针就是迷途指针</p></li></ul><h3 id="2-4-2-处理迷途指针"><a href="#2-4-2-处理迷途指针" class="headerlink" title="2.4.2 处理迷途指针"></a>2.4.2 处理迷途指针</h3><ul><li>释放指针后置为NULL，后续使用这个指针会终止应用程序。不过，如果存在多个指针的话还是会有问题，因为赋值只会影响一个指针</li><li>写一个特殊的函数代替free函数</li><li>有些系统（运行时或调试系统）会在释放后覆写数据（比如0xDEADBEEF，取决于被释放的对象，Visual Studio会用0xCC、0xCD或者0xDD）。在不抛出异常的情况下，如果程序员在预期之外的地方看到这些值，可以认为程序可能在访问已释放的内存</li><li>用第三方工具检测迷途指针和其他问题</li></ul><h3 id="2-4-3-调试器对检测内存泄露的支持"><a href="#2-4-3-调试器对检测内存泄露的支持" class="headerlink" title="2.4.3 调试器对检测内存泄露的支持"></a>2.4.3 调试器对检测内存泄露的支持</h3><blockquote><p>微软提供解决动态内存分配的覆写和内存泄露的技术</p></blockquote><ul><li>检查堆的完整性；</li><li>检查内存泄漏；</li><li>模拟堆内存不够的情况</li></ul><blockquote><p>Mudflap库为GCC编译器提供了类似的功能，它的运行时库支持对内存泄漏的检测和其他功能，这种检测是通过监控指针解引操作来实现的。</p></blockquote><h2 id="2-5-动态内存分配技术"><a href="#2-5-动态内存分配技术" class="headerlink" title="2.5 动态内存分配技术"></a>2.5 动态内存分配技术</h2><h3 id="2-5-1-C的垃圾回收"><a href="#2-5-1-C的垃圾回收" class="headerlink" title="2.5.1 C的垃圾回收"></a>2.5.1 C的垃圾回收</h3><blockquote><p>malloc和free函数提供了手动分配和释放内存的方法。不过对于很多问题，需要考虑使用C的手动内存管理，比如性能、达到好的引用局部性、线程问题，以及优雅地清理内存。</p><p>有些非标准的技术可以用来解决部分问题，这些技术的关键特性在于自动释放内存。内存不再使用之后会被收集起来以备后续使用，释放的内存称为垃圾，因此，垃圾回收就是指这个过程</p></blockquote><h3 id="2-5-2-资源获取即初始化-RAII"><a href="#2-5-2-资源获取即初始化-RAII" class="headerlink" title="2.5.2 资源获取即初始化(RAII)"></a>2.5.2 资源获取即初始化(RAII)</h3><blockquote><p>由Bjarne Stroustrup发明，用于解决C++资源分配和释放。即使有异常发生，这种技术也能保证资源的初始化和后续的释放。分配的资源最终总是会得到释放</p></blockquote><h3 id="2-5-3-使用异常处理函数"><a href="#2-5-3-使用异常处理函数" class="headerlink" title="2.5.3 使用异常处理函数"></a>2.5.3 使用异常处理函数</h3><blockquote><p>尽管异常处理不属于标准C，但如果可以使用它且不考虑移植问题，它会很有用</p></blockquote><h1 id="第三章-指针和函数"><a href="#第三章-指针和函数" class="headerlink" title="第三章 指针和函数"></a>第三章 指针和函数</h1><h2 id="3-1-程序的栈和堆"><a href="#3-1-程序的栈和堆" class="headerlink" title="3.1 程序的栈和堆"></a>3.1 程序的栈和堆</h2><h3 id="3-1-1-程序栈"><a href="#3-1-1-程序栈" class="headerlink" title="3.1.1 程序栈"></a>3.1.1 程序栈</h3><blockquote><p>程序栈是支持函数执行的内存区域，通常和堆共享。也就是说，它们共享同一块内存区域。程序栈通常占据这块区域的下部，而堆用的则是上部。</p><p>程序栈存放<strong>栈帧</strong>（stack frame），栈帧有时候也称为<strong>活跃记录</strong>（activation record）或<strong>活跃帧</strong>（activation frame）。栈帧存放函数参数和局部变量。</p></blockquote><ul><li>调用函数时，函数的栈帧被推到栈上，栈向上“长出”一个栈帧。当函数终止时，其栈帧从程序栈上弹出。栈帧所使用的内存不会被清理，但最终可能会被推到程序栈上的另一个栈帧覆盖</li><li>动态分配的内存来自堆，堆向下“生长”。随着内存的分配和释放，堆中会布满碎片。尽管堆是向下生长的，但这只是个大体方向，实际上内存可能在堆上的任意位置分配</li></ul><h3 id="3-1-2-栈帧的组织"><a href="#3-1-2-栈帧的组织" class="headerlink" title="3.1.2 栈帧的组织"></a>3.1.2 栈帧的组织</h3><ul><li>返回地址：函数完成后要返回的程序内部地址</li><li>局部数据存储：为局部变量分配的内存</li><li>参数存储：为函数参数分配的内存</li><li>栈指针和基指针：运行时系统用来管理栈的指针</li></ul><blockquote><p>栈指针通常指向栈顶部。基指针（帧指针）通常存在并指向栈帧内部的地址，比如返回地址，用来协助访问栈帧内部的元素。这两个指针都不是C指针，它们是运行时系统管理程序栈的地址。如果运行时系统用C实现，这些指针倒真是C指针</p></blockquote><h2 id="3-2-通过指针传递和返回数据"><a href="#3-2-通过指针传递和返回数据" class="headerlink" title="3.2 通过指针传递和返回数据"></a>3.2 通过指针传递和返回数据</h2><h3 id="3-2-1-使用指针传递数据"><a href="#3-2-1-使用指针传递数据" class="headerlink" title="3.2.1 使用指针传递数据"></a>3.2.1 使用指针传递数据</h3><blockquote><p>使用指针来传递数据的一个主要原因是函数可以修改数据</p></blockquote><h3 id="3-2-2-使用值传递数据"><a href="#3-2-2-使用值传递数据" class="headerlink" title="3.2.2 使用值传递数据"></a>3.2.2 使用值传递数据</h3><h3 id="3-2-3-传递指向常量的指针"><a href="#3-2-3-传递指向常量的指针" class="headerlink" title="3.2.3 传递指向常量的指针"></a>3.2.3 传递指向常量的指针</h3><blockquote><p>传递指向常量的指针是C中常用的技术，效率很高，因为我们只传了数据的地址，能避免某些情况下复制大量内存。不过，如果只是传递指针，数据就能被修改。如果不希望数据被修改，就要传递指向常量的指针。</p></blockquote><h3 id="3-2-4-返回指针"><a href="#3-2-4-返回指针" class="headerlink" title="3.2.4 返回指针"></a>3.2.4 返回指针</h3><blockquote><p>返回指针很容易，只要返回的类型是某种数据类型的指针即可。从函数返回对象时经常用到以下两种技术：</p><ul><li>使用malloc在函数内部分配内存并返回其地址。调用者负责释放返回的内存。</li><li>传递一个对象给函数并让函数修改它。这样分配和释放对象的内存都是调用者的责任。</li></ul></blockquote><p>从函数返回指针时可能存在几个潜在的问题：</p><ul><li>返回未初始化的指针</li><li>返回指向无效地址的指针</li><li>返回局部变量的指针</li><li>返回指针但是没有释放内存</li></ul><h3 id="3-2-5-局部数据指针"><a href="#3-2-5-局部数据指针" class="headerlink" title="3.2.5 局部数据指针"></a>3.2.5 局部数据指针</h3><blockquote><p>比如说在函数中定义局部变量数据并返回该地址，此时返回的数据地址无效，因为函数的栈帧从占中弹出了</p></blockquote><h3 id="3-2-6-传递空指针"><a href="#3-2-6-传递空指针" class="headerlink" title="3.2.6 传递空指针"></a>3.2.6 传递空指针</h3><blockquote><p>使用if(arr!&#x3D;&#x3D;NULL)来判断arr指针是否是空指针</p></blockquote><h3 id="3-2-7-传递指针的指针"><a href="#3-2-7-传递指针的指针" class="headerlink" title="3.2.7 传递指针的指针"></a>3.2.7 传递指针的指针</h3><blockquote><p>将指针传递给函数时，传递的是值。如果我们想修改原指针而不是指针的副本，就需要传递指针的指针</p></blockquote><h2 id="3-3-函数指针"><a href="#3-3-函数指针" class="headerlink" title="3.3 函数指针"></a>3.3 函数指针</h2><blockquote><p>函数指针是持有函数地址的指针，使用函数指针时要小心，因为C不会检查参数传递是否正确</p></blockquote><h3 id="3-3-1-声明函数指针"><a href="#3-3-1-声明函数指针" class="headerlink" title="3.3.1 声明函数指针"></a>3.3.1 声明函数指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*foo)();</span><br></pre></td></tr></table></figure><h3 id="3-3-2-使用函数指针"><a href="#3-3-2-使用函数指针" class="headerlink" title="3.3.2 使用函数指针"></a>3.3.2 使用函数指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num*num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fptr=square;</span><br><span class="line"><span class="comment">//ftpr=&amp;square;//作用同上，在这种上下文环境中编译器会忽略取地址操作符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5 square is %d\n&quot;</span>,fptr(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><blockquote><p>为函数指针声明类型定义比较方便，类型定义看起来有点奇怪，通常类型定义的名字是声明的最后一个元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*funcptr)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">...</span><br><span class="line">funcptr fptr2;</span><br><span class="line">fptr2=square;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;8 square is %d\n&quot;</span>,fptr2(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-3-传递函数指针"><a href="#3-3-3-传递函数指针" class="headerlink" title="3.3.3 传递函数指针"></a>3.3.3 传递函数指针</h3><blockquote><p>传递函数指针很简单，只要把函数指针声明作为函数参数即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fptrOperation)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compute</span><span class="params">(fptrOperation operation, <span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> operation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,compute(add,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,compute(sub,<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-4-返回函数指针"><a href="#3-3-4-返回函数指针" class="headerlink" title="3.3.4 返回函数指针"></a>3.3.4 返回函数指针</h3><blockquote><p>返回函数指针需要把函数返回类型声明为函数指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fptrOperation <span class="title function_">select</span><span class="params">(<span class="type">char</span> opcode)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> add;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> subtract;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(<span class="type">char</span> opcode, <span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    fptrOperation operation = select(opcode);</span><br><span class="line">    <span class="keyword">return</span> operation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,evaluate(<span class="string">&#x27;+&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,evaluate(<span class="string">&#x27;-&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-5-使用函数指针数组"><a href="#3-3-5-使用函数指针数组" class="headerlink" title="3.3.5 使用函数指针数组"></a>3.3.5 使用函数指针数组</h3><blockquote><p>函数指针数组可以基于某些条件选择要执行的函数，声明这种数组很简单，只要把函数指针声明为数组的类型即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*operation)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">operation operations[<span class="number">128</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">---</span><br><span class="line"><span class="type">int</span> (*operations[<span class="number">128</span>])(<span class="type">int</span>, <span class="type">int</span>)=&#123;<span class="literal">NULL</span>&#125;;<span class="comment">//作用同上</span></span><br></pre></td></tr></table></figure><h3 id="3-3-6-比较函数指针"><a href="#3-3-6-比较函数指针" class="headerlink" title="3.3.6 比较函数指针"></a>3.3.6 比较函数指针</h3><blockquote><p>使用相等和不等操作符来比较函数指针</p></blockquote><h3 id="3-3-7-转换函数指针"><a href="#3-3-7-转换函数指针" class="headerlink" title="3.3.7 转换函数指针"></a>3.3.7 转换函数指针</h3><blockquote><p>我们可以将指向某个函数的指针转换为其他类型的指针，不过要谨慎使用，因为运行时系统不会验证函数指针所用的参数是否正确。也可以把一种函数指针转换为另一种再转换回来，得到的结果和原指针相同，但函数指针的长度不一定相等</p><p>无法保证函数指针和数据指针相互转换后正常工作</p></blockquote><blockquote><p>void*指针不一定能用在函数指针上，不过在交换函数指针时通常会见到<code>typedef void (*fptrBase)()</code>的”基本”函数指针类型(基本指针)，用做占位符，用来交换函数指针的值</p></blockquote><h1 id="第四章-指针和数组"><a href="#第四章-指针和数组" class="headerlink" title="第四章 指针和数组"></a>第四章 指针和数组</h1><blockquote><p>数组和指针表示法紧密关联，在合适的上下文中可以互换</p></blockquote><h2 id="4-1-数组概述"><a href="#4-1-数组概述" class="headerlink" title="4.1 数组概述"></a>4.1 数组概述</h2><blockquote><p>数组是能用索引访问的同质元素连续集合。这里所说的连续是指数组的元素在内存中是相邻的，中间不存在空隙，而同质是指元素都是同一类型的。数组声明用的是方括号集合，可以拥有多个维度。</p></blockquote><h3 id="4-1-1-一维数组"><a href="#4-1-1-一维数组" class="headerlink" title="4.1.1 一维数组"></a>4.1.1 一维数组</h3><blockquote><p>一维数组是线性结构，使用一个索引访问成员；数组索引从0开始到声明的长度减1结束</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">vector</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="4-1-2-二维数组"><a href="#4-1-2-二维数组" class="headerlink" title="4.1.2 二维数组"></a>4.1.2 二维数组</h3><blockquote><p>二维数组使用行和列来标识数组元素，这类数组需要映射为内存中的一维地址空间。在C中这是通过行–列顺序实现的。先将数组的第一行放进内存，接着是第二行、第三行，直到最后一行。</p><p>我们可以将二维数组当做数组的数组，也就是说，如果只用一个下标访问数组，得到的是对应行的指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>多维数组具有两个及两个以上维度。对于多维数组，需要多组括号来定义数组的类型和长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr3d[<span class="number">3</span>][<span class="number">2</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;,&#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-指针表示法和数组"><a href="#4-2-指针表示法和数组" class="headerlink" title="4.2 指针表示法和数组"></a>4.2 指针表示法和数组</h2><blockquote><p>指针在处理数组时很有用，我们可以用指针指向已有的数组，也可以从堆上分配内存然后把这块内存当做一个数组使用。数组表示法和指针表示法在某种意义上可以互换。不过，它们并不完全相同</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">vector</span>[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *pv=<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure><blockquote><p>pv变量是指向数组第一个元素而不是指向数组本身的指针。给pv赋值是把数组的第一个元素的地址赋给pv。</p><p>vector、&amp;vector[0]、pv三者的值相同，都表示数组第一个元素的地址，而&amp;vector表示数组的地址(整个数组的指针)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pv[i]</span><br><span class="line">*(pv+i)</span><br><span class="line"><span class="comment">//上面两者等价</span></span><br></pre></td></tr></table></figure><blockquote><p>pv指针包含一个内存块的地址，方括号表示法会取出pv中包含的地址，用指针算术运算把索引i加上，然后解引新地址返回其内容</p></blockquote><ul><li>数组和指针的差别</li></ul><blockquote><ul><li><p>vector[i]生成的代码和*(vector+i)生成的不一样，vector[i]表示法生成的机器码从位置vector开始，移动i个位置，取出内容。而*(vector+i)表示法生成的机器码则是从vector开始，在地址上增加i，然后取出这个地址中的内容</p></li><li><p>sizeof操作符对数组和同一个数组的指针操作也是不同的。对vector调用sizeof操作符会返回20，就是这个数组分配的字节数。对pv调用sizeof操作符会返回4，就是指针的长度</p></li><li><p>pv是一个左值，左值表示赋值操作符左边的符号。左值必须能修改。像vector这样的数组名字不是左值，它不能被修改。我们不能改变数组所持有的地址，但可以给指针赋一个新值从而引用不同的内存段</p></li></ul></blockquote><h2 id="4-3-使用malloc创建一维数组"><a href="#4-3-使用malloc创建一维数组" class="headerlink" title="4.3 使用malloc创建一维数组"></a>4.3 使用malloc创建一维数组</h2><blockquote><p>如果从堆上分配内存并把地址赋给一个指针，那就肯定可以对指针使用数组下标并把这块内存当成一个数组，不过用完记得释放内存</p></blockquote><h2 id="4-4-使用realloc调整数组长度"><a href="#4-4-使用realloc调整数组长度" class="headerlink" title="4.4 使用realloc调整数组长度"></a>4.4 使用realloc调整数组长度</h2><blockquote><p>用malloc创建的已有数组的长度可以通过realloc函数来调整。C99标准支持变长数组，有些情况下这种解决方案可能比使用realloc函数更好。如果没有使用C99标准，那就只能用realloc。此外，变长数组只能在函数内部声明，如果数组需要的生命周期比函数长，那也只使用realloc</p></blockquote><h2 id="4-5-传递一维数组"><a href="#4-5-传递一维数组" class="headerlink" title="4.5 传递一维数组"></a>4.5 传递一维数组</h2><blockquote><p>将一维数组作为参数传递给函数实际是通过值来传递数组的地址，这样信息传递就更高效，因为我们不需要传递整个数组，从而也就不需要在栈上分配内存。通常，这也意味着要传递数组长度，否则在函数看来，我们只有数组的地址而不知道其长度</p><p>可以使用两种表示法在函数声明中声明数组：数组表示法和指针表示法</p></blockquote><h3 id="4-5-1-使用数组表示法"><a href="#4-5-1-使用数组表示法" class="headerlink" title="4.5.1 使用数组表示法"></a>4.5.1 使用数组表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">displayArray</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,*(arr+i)); 作用同上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-使用指针表示法"><a href="#4-5-2-使用指针表示法" class="headerlink" title="4.5.2 使用指针表示法"></a>4.5.2 使用指针表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">displayArray</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,*(arr+i)); 作用同上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-使用指针的一维数组"><a href="#4-6-使用指针的一维数组" class="headerlink" title="4.6 使用指针的一维数组"></a>4.6 使用指针的一维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//表示地址</span></span><br><span class="line">*arr[i] = i;<span class="comment">//解引指针，得到该地址的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是等价的指针表示法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(arr+i)=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">**(arr+i)=i;</span><br></pre></td></tr></table></figure><blockquote><p>子表达式(arr+i)表示数组的第i个元素的地址，用子表达式*(arr+i)修改这个地址的内容(该内容其实也是地址)。在第一条语句中我们将已分配的内存赋给这个位置。对(arr+i)子表达式做两次解引（如第二条语句所示），会返回所分配内存的位置，然后我们把i赋给它</p></blockquote><h2 id="4-7-指针和多维数组"><a href="#4-7-指针和多维数组" class="headerlink" title="4.7 指针和多维数组"></a>4.7 指针和多维数组</h2><blockquote><p>可以将多维数组的一部分看做子数组。比如说，二维数组的每一行都可以当做一维数组。这种行为会对我们用指针处理多维数组有所影响</p></blockquote><p>二维数组表示法：</p><blockquote><p><code>arr[i][j]</code>的地址为<code>address of arr+(i*size of row)+(j*size of element)</code></p></blockquote><h2 id="4-8-传递多维数组"><a href="#4-8-传递多维数组" class="headerlink" title="4.8 传递多维数组"></a>4.8 传递多维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display2DArray</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>],<span class="type">int</span> rows)</span>;</span><br><span class="line">---</span><br><span class="line"><span class="type">void</span> <span class="title function_">display2DArray</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>],<span class="type">int</span> rows)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这两种写法都指明了数组的列数，这很有必要，因为编译器需要知道每行有几个元素。如果没有传递这个信息，编译器就无法计算想<code>arr[0][3]</code>这样的表达式</p><p>在第一种写法中，表达式<code>arr[]</code>是数组指针的一个隐式声明，而第二种写法中的<code>(*arr)</code>表达式则是指针的一个显式声明</p></blockquote><h2 id="4-9-动态分配二维数组"><a href="#4-9-动态分配二维数组" class="headerlink" title="4.9 动态分配二维数组"></a>4.9 动态分配二维数组</h2><blockquote><p>为二维数组动态分配内存涉及几个问题：（1）数组元素是否需要连续；（2）数组是否规则</p><p>通常声明的二维数组所分配的内存是连续的，不过，当我们用malloc这样的函数创建二维数组时，在内存分配上会有几种选择。由于我们可以将二维数组当做数组的数组，因而“内层”的数组没有理由一定要是连续的。如果对这种数组使用下标，数组的不连续对程序员是透明的。<strong>注意</strong>：连续性还会影响复制内存等其他操作，内存不连续就可能需要多次复制。</p></blockquote><h3 id="4-9-1-分配可能不连续的内存"><a href="#4-9-1-分配可能不连续的内存" class="headerlink" title="4.9.1 分配可能不连续的内存"></a>4.9.1 分配可能不连续的内存</h3><blockquote><p>下面的代码演示了如何创建一个内存可能不连续的二维数组。首先分配“外层”数组，然后分别用malloc语句为每一行分配，因此内存不一定连续，实际分配情况取决于堆管理器和堆的状态，也有可能是连续的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> columns = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **) <span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">matrix[i] = (<span class="type">int</span> *) <span class="built_in">malloc</span>(columns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-2-分配连续内存"><a href="#4-9-2-分配连续内存" class="headerlink" title="4.9.2 分配连续内存"></a>4.9.2 分配连续内存</h3><blockquote><p>第一种技术，第一个malloc分配了一个整数指针的数组，一个元素用来存储一行的指针，在for循环中，我们将第二个malloc所分配的内存的一部分赋值给第一个数组的每个元素</p><p>从技术上讲，第一个数组的内存可以和数组“体”的内存分开，为数组“体”分配的内存是连续的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> columns = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **) <span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">matrix[<span class="number">0</span>] = (<span class="type">int</span> *) <span class="built_in">malloc</span>(rows *columns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">matrix[i] = matrix[<span class="number">0</span>] + i *columns;</span><br></pre></td></tr></table></figure><blockquote><p>第二种技术，数组所需的所有内存是一次性分配的，后面的代码用到这个数组时不能使用下标，必须手动计算索引，每个元素被初始化为其索引的积。不能使用数组下标是因为我们丢失了允许编译器使用下标所需的“形态”信息</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *matrix = (<span class="type">int</span> *)<span class="built_in">malloc</span>(rows *columns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">    *(matrix + (i*columns) + j) = i*j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-不规则数组和指针"><a href="#4-10-不规则数组和指针" class="headerlink" title="4.10 不规则数组和指针"></a>4.10 不规则数组和指针</h2><blockquote><p>不规则数组是每一行的列数不一样的二维数组</p></blockquote><ul><li>复合字面量创建二维数组</li></ul><blockquote><p>复合字面量是一种C构造，前面看起来像类型转换操作，后面跟着花括号括起来的初始化列表</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">const</span> <span class="type">int</span>)&#123;<span class="number">100</span>&#125;</span><br><span class="line">(<span class="type">int</span>[<span class="number">3</span>])&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">---</span><br><span class="line"><span class="type">int</span> (*(arr[]))=&#123;</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这个数组有3行3列，将数组元素用数字0到8按行–列顺序初始化</p><p>下面使用3个复合字面量声明不规则数组(复合字面量在创建不规则数组时很有用)：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*(arr2[]))=&#123;</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">(<span class="type">int</span>[])&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="第五章-指针和字符串"><a href="#第五章-指针和字符串" class="headerlink" title="第五章 指针和字符串"></a>第五章 指针和字符串</h1><h2 id="5-1-字符串基础"><a href="#5-1-字符串基础" class="headerlink" title="5.1 字符串基础"></a>5.1 字符串基础</h2><blockquote><p>字符串是以ASCII字符NUL(即\0)结尾的字符序列。字符串通常存储在数组或者从堆上分配的内存中。不过，并非所有的字符数组都是字符串，字符数组可能没有NUL字符。字符数组也用来表示布尔值等小的整数单元，以节省内存空间</p></blockquote><ul><li>C中有两种类型的字符串</li></ul><blockquote><ul><li><p><strong>单字节字符串</strong></p><p>  由char数据类型组成的序列。 </p></li><li><p><strong>宽字符串</strong></p><p>  由wchar_t数据类型组成的序列</p></li></ul><p>wchar_t数据类型用来表示宽字符，要么是16位宽，要么是32位宽。这两种字符串都以NUL结尾。可以在string.h中找到单字节字符串函数，而在wchar.h中找到宽字符串函数。创建宽字符主要用来支持非拉丁字符集，对于支持外语的应用程序很有用</p></blockquote><ul><li>字符串的长度是字符串中除了NUL字符之外的字符数。为字符串分配内存时，要记得为所有的字符再加上NUL字符分配足够的空间。NULL和NUL不同。NULL用来表示特殊的指针，通常定义为((void*)0)，而NUL是一个char，定义为\0，两者不能混用。字符常量是单引号引起来的字符序列。字符常量通常由一个字符组成，也可以包含多个字符，比如转义字符</li></ul><h3 id="5-1-1-字符串声明"><a href="#5-1-1-字符串声明" class="headerlink" title="5.1.1 字符串声明"></a>5.1.1 字符串声明</h3><blockquote><p>声明字符串的方式有三种：字面量、字符数组和字符指针。字符串字面量是用双引号引起来的字符序列，常用来进行初始化。不要把字符串字面量和单引号引起来的字符搞混——后者是字符字面量。</p></blockquote><ul><li>字符数组声明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> header[<span class="number">32</span>];</span><br><span class="line"><span class="comment">//实际只能放31个字符，以NUL结尾</span></span><br></pre></td></tr></table></figure><ul><li>字符指针声明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *header;</span><br><span class="line"><span class="comment">//未指明字符串长度和位置(未初始化)</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-字符串字面量池"><a href="#5-1-2-字符串字面量池" class="headerlink" title="5.1.2 字符串字面量池"></a>5.1.2 字符串字面量池</h3><blockquote><ul><li><p>定义字面量时通常会将其分配在字面量池中，这个内存区域保存了组成字符串的字符序列。多次用到同一个字面量时，字面量池中通常只有一份副本。这样会减少应用程序占用的内存。通常认为字面量是不可变的，因此只有一份副本不会有什么问题。不过，认定只有一份副本或者字面量不可变不是一种好做法，大部分编译器有关闭字面量池的选项，一旦关闭，字面量可能生成多个副本，每个副本拥有自己的地址</p></li><li><p>字符串字面量一般分配在只读内存中，所以是不可变的。字符串字面量在哪里使用，或者它是全局、静态或局部的都无关紧要，从这个角度讲，字符串字面量不存在作用域的概念。</p></li></ul></blockquote><ul><li>字符串字面量不是常量的情况</li></ul><blockquote><p>大部分编译器中将字符串字面量看做常量，无法修改字符串。</p></blockquote><h3 id="5-1-3-字符串初始化"><a href="#5-1-3-字符串初始化" class="headerlink" title="5.1.3 字符串初始化"></a>5.1.3 字符串初始化</h3><blockquote><p>初始化字符串采用的方法取决于变量是被声明为字符数组还是字符指针，字符串所用的内存要么是数组要么是指针指向的一块内存。我们可以用字符串字面量或者一系列字符初始化字符串，或者从别的地方（比如说标准输入）得到字符</p></blockquote><h4 id="1-初始化char数组"><a href="#1-初始化char数组" class="headerlink" title="1.初始化char数组"></a>1.初始化char数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cahr header[]=<span class="string">&quot;Meadia Player&quot;</span>;<span class="comment">//初始化操作符初始化char数组</span></span><br><span class="line">---</span><br><span class="line"><span class="type">char</span> header[<span class="number">13</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(header,<span class="string">&quot;Meadia Player&quot;</span>);<span class="comment">//使用strcpy()函数初始化char数组</span></span><br></pre></td></tr></table></figure><h4 id="2-初始化char指针"><a href="#2-初始化char指针" class="headerlink" title="2.初始化char指针"></a>2.初始化char指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cahr *header=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Media Player&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(header,<span class="string">&quot;Media Player&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>在使用malloc()函数确定字符串长度时：</p><ul><li>记得算上终结符NUL(即\0)</li><li>不能使用sizeof操作符，而采用strlen()函数确定已有字符串长度</li></ul></blockquote><blockquote><p>试图用字符字面量来初始化char指针不会起作用。因为字符字面量是int类型，这其实是尝试把整数赋给字符指针。这样经常会造成应用程序在解引指针时终止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *prefix=<span class="string">&#x27;+&#x27;</span>;<span class="comment">//不合法</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="type">char</span> *prefix=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>);</span><br><span class="line">*prefix=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">*(prefix+<span class="number">1</span>)=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-从标准输入初始化字符串"><a href="#3-从标准输入初始化字符串" class="headerlink" title="3.从标准输入初始化字符串"></a>3.从标准输入初始化字符串</h4><blockquote><p>使用标准输入等外部源初始化字符串</p></blockquote><h4 id="4-字符串位置小结"><a href="#4-字符串位置小结" class="headerlink" title="4.字符串位置小结"></a>4.字符串位置小结</h4><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221126143436.png"></p><h2 id="5-2-标准字符串操作"><a href="#5-2-标准字符串操作" class="headerlink" title="5.2 标准字符串操作"></a>5.2 标准字符串操作</h2><h3 id="5-2-1-比较字符串"><a href="#5-2-1-比较字符串" class="headerlink" title="5.2.1 比较字符串"></a>5.2.1 比较字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">负数：按字典序(字母序)s1&lt;s2</span><br><span class="line">    <span class="number">0</span>：s1=s2</span><br><span class="line">   正数：按字典序(字母序)s1&gt;s2</span><br></pre></td></tr></table></figure><blockquote><p>要比较的两个字符串都以指向char常量的指针的形式传递，这让我们可以放心地使用这个函数，而不用担心传入的字符串被修改</p></blockquote><h3 id="5-2-2-赋值字符串"><a href="#5-2-2-赋值字符串" class="headerlink" title="5.2.2 赋值字符串"></a>5.2.2 赋值字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char *s1,const char *s2);</span><br></pre></td></tr></table></figure><blockquote><p>两个指针可以引用同一个字符串。两个指针引用同一个地址称为<strong>别名</strong>。尽管通常情况下这不是问题，但要知道，把一个指针赋值给另一个指针不会复制字符串，只是复制了字符串的地址</p></blockquote><h3 id="5-2-3-拼接字符串"><a href="#5-2-3-拼接字符串" class="headerlink" title="5.2.3 拼接字符串"></a>5.2.3 拼接字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *s1,const char *s2);</span><br></pre></td></tr></table></figure><blockquote><p>此函数把第二个字符串拼接到第一个的结尾，第二个字符串是以常量char指针的形式传递的。函数不会分配内存，这意味着第一个字符串必须足够长，能容纳拼接后的结果，否则函数可能会越界写入，导致不可预期的行为。函数的返回值的地址跟第一个参数的地址一样</p></blockquote><h2 id="5-3-传递字符串"><a href="#5-3-传递字符串" class="headerlink" title="5.3 传递字符串"></a>5.3 传递字符串</h2><h3 id="5-3-1-传递简单字符串"><a href="#5-3-1-传递简单字符串" class="headerlink" title="5.3.1 传递简单字符串"></a>5.3.1 传递简单字符串</h3><blockquote><p>取决于不同的字符串声明方式，有几种方法可以把字符串的地址传递给函数</p></blockquote><h3 id="5-3-2-传递字符常量的指针"><a href="#5-3-2-传递字符常量的指针" class="headerlink" title="5.3.2 传递字符常量的指针"></a>5.3.2 传递字符常量的指针</h3><blockquote><p>以字符常量指针的形式传递字符串指针是很常见也很有用的技术，这样可以用指针传递字符串，同时也能防止传递的字符串被修改</p></blockquote><h3 id="5-3-3-传递需要初始化的字符串"><a href="#5-3-3-传递需要初始化的字符串" class="headerlink" title="5.3.3 传递需要初始化的字符串"></a>5.3.3 传递需要初始化的字符串</h3><blockquote><ul><li>传递空缓冲区让函数填充后返回</li><li>函数动态分配缓冲区并返回</li></ul></blockquote><h3 id="5-3-4-给应用程序传递参数"><a href="#5-3-4-给应用程序传递参数" class="headerlink" title="5.3.4 给应用程序传递参数"></a>5.3.4 给应用程序传递参数</h3><blockquote><p>C用传统的argc和argv参数支持命令行参数。第一个参数argc，是一个指定传递的参数数量的整数。系统至少会传递一个参数，这个参数是可执行文件的名字。第二个参数argv，通常被看做字符串指针的一维数组，每个指针引用一个命令行参数</p></blockquote><h2 id="5-4-返回字符串"><a href="#5-4-返回字符串" class="headerlink" title="5.4 返回字符串"></a>5.4 返回字符串</h2><blockquote><p>函数返回字符串时，它返回的实际是字符串的地址。这里应该关注的主要问题是如何返回合法的地址，要做到这一点，可以返回以下三种对象之一的引用：</p><ul><li><p>字面量；</p></li><li><p>动态分配的内存；</p></li><li><p>本地字符串变量。</p></li></ul></blockquote><h3 id="5-4-1-返回字面量的地址"><a href="#5-4-1-返回字面量的地址" class="headerlink" title="5.4.1 返回字面量的地址"></a>5.4.1 返回字面量的地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello world!!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-返回动态分配内存的地址"><a href="#5-4-2-返回动态分配内存的地址" class="headerlink" title="5.4.2 返回动态分配内存的地址"></a>5.4.2 返回动态分配内存的地址</h3><blockquote><p>如果需要从函数返回字符串，可以在堆上分配字符串内存并返回其地址</p></blockquote><ul><li>返回局部字符串地址</li></ul><blockquote><p>返回局部字符串的地址可能会有问题，如果内存被别的栈帧覆写就会损坏，应该避免使用这种方法</p></blockquote><h2 id="5-5-函数指针和字符串"><a href="#5-5-函数指针和字符串" class="headerlink" title="5.5 函数指针和字符串"></a>5.5 函数指针和字符串</h2><blockquote><p>通过将函数传递给另一个函数对字符串进行灵活操作</p></blockquote><h1 id="第六章-指针和结构体"><a href="#第六章-指针和结构体" class="headerlink" title="第六章 指针和结构体"></a>第六章 指针和结构体</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><blockquote><p>声明C结构体的方式有多种，这里只介绍其中两种。</p><p>第一种使用struct关键字声明结构体。第二种使用类型定义结构体</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">person</span>&#123;</span></span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">person</span>&#123;</span></span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line">&#125;Person;</span><br><span class="line">Person person;<span class="comment">//person实例声明</span></span><br><span class="line">person.name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Emily&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(person.name,<span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line">---</span><br><span class="line">Person *ptrPerson;</span><br><span class="line">ptrPerson=(Person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Person));</span><br><span class="line">ptrPerson-&gt;name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Emily&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ptrPerson-&gt;name,<span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">ptrPerson-&gt;age = <span class="number">23</span>;</span><br></pre></td></tr></table></figure><ul><li>为结构体分配内存</li></ul><blockquote><p>为结构体分配内存时，分配的内存大小至少是各个字段的长度和。不过，实际长度通常会大于这个和，因为结构体的各字段之间可能会有填充。某些数据类型需要对齐到特定边界就会产生填充。比如说，短整数通常对齐到能被2整除的地址上，而整数对齐到能被4整除的地址上</p><p>这些额外内存的分配意味着几个问题：</p><ul><li><p>要谨慎使用指针算术运算；</p></li><li><p>结构体数组的元素之间可能存在额外的内存</p></li></ul></blockquote><h2 id="6-2-结构体释放问题"><a href="#6-2-结构体释放问题" class="headerlink" title="6.2 结构体释放问题"></a>6.2 结构体释放问题</h2><blockquote><p>在为结构体分配内存时，运行时系统不会自动为结构体内部的指针分配内存。类似地，当结构体消失时，运行时系统也不会自动释放结构体内部的指针指向的内存</p><p>当我们声明含有指针类型变量的结构体或对其动态分配内存时，相应的指针会包含垃圾数据，需要对其分配内存并把地址赋给每个指针，务必记得最后要手动释放该指针以及动态分配内存的结构体的指针</p></blockquote><h2 id="6-3-避免malloc-x2F-free开销"><a href="#6-3-避免malloc-x2F-free开销" class="headerlink" title="6.3 避免malloc&#x2F;free开销"></a>6.3 避免malloc&#x2F;free开销</h2><blockquote><p>重复分配然后释放结构体会产生一些开销，可能导致巨大的性能瓶颈。解决这个问题的一种办法是为分配的结构体单独维护一个表。当用户不再需要某个结构体实例时，将其返回结构体池中。当我们需要某个实例时，从结构体池中获取一个对象。如果池中没有可用的元素，我们就动态分配一个实例。这种方法高效地维护一个结构体池，能按需使用和重复使用内存</p></blockquote><h2 id="6-4-使用指针支持数据结构"><a href="#6-4-使用指针支持数据结构" class="headerlink" title="6.4 使用指针支持数据结构"></a>6.4 使用指针支持数据结构</h2><blockquote><p>指针可以为简单或复杂的数据结构提供更多的灵活性。这些灵活性可能来自动态内存分配，也可能来自切换指针引用的便利性。内存无需像数组那样是连续的，只要总的内存大小对就可以</p></blockquote><h3 id="6-4-1-单链表"><a href="#6-4-1-单链表" class="headerlink" title="6.4.1 单链表"></a>6.4.1 单链表</h3><blockquote><p>链表是由一系列互相连接的节点组成的数据结构。通常会有一个节点称为<strong>头节点</strong>，其他节点顺序跟在头节点后面，最后一个节点称为<strong>尾节点</strong>。我们可以用指针轻松实现节点之间的连接，动态按需分配每个节点</p><p>链表有好几种类型，最简单的是单链表，一个节点到下一个节点只有一个连接，连接从头节点开始，到尾节点结束。循环链表没有尾节点，链表的最后一个节点又指向头节点。双链表用了两个链表，一个向前连接，一个向后连接，我们可以在两个方向上查找节点，这类链表更灵活，但是也更难实现</p></blockquote><h3 id="6-4-2-使用指针支持队列"><a href="#6-4-2-使用指针支持队列" class="headerlink" title="6.4.2 使用指针支持队列"></a>6.4.2 使用指针支持队列</h3><blockquote><p>队列是一种线性数据结构，行为类似排队。它通常支持两种主要操作：入队和出队。入队操作把元素添加到队列中，出队操作从队列中删除元素。一般来说，第一个添加到队列中的元素也是第一个离开队列的元素，这种行为被称为先进先出（FIFO）</p></blockquote><h3 id="6-4-3-使用指针支持栈"><a href="#6-4-3-使用指针支持栈" class="headerlink" title="6.4.3 使用指针支持栈"></a>6.4.3 使用指针支持栈</h3><blockquote><p>栈数据结构也是一种链表。对于栈，元素被推入栈顶，然后被弹出。当多个元素被推入和弹出时，栈的行为是先进后出（FILO）。第一个推入栈的元素最后一个弹出</p></blockquote><h3 id="6-4-4-使用指针支持树"><a href="#6-4-4-使用指针支持树" class="headerlink" title="6.4.4 使用指针支持树"></a>6.4.4 使用指针支持树</h3><blockquote><p>树是很有用的数据结构，它的名字源于元素之间的关系。通常，子节点连接到父节点，从整体上看就像一颗倒过来的树，根节点表示这种数据结构的开始元素。</p><p>树可以有任意数量的子节点，不过，二叉树比较常见，它的每个节点能有0个、1个或是2个子节点。子节点要么是左子节点，要么是右子节点。没有子节点的节点称为叶子节点，就跟树叶一样</p></blockquote><h1 id="第七章-安全问题和指针误用"><a href="#第七章-安全问题和指针误用" class="headerlink" title="第七章 安全问题和指针误用"></a>第七章 安全问题和指针误用</h1><blockquote><p><strong>地址空间布局随机化</strong>（Address Space Layout Randomization，ASLR）过程会把应用程序的数据区域随机放置在内存中，这些数据区域包括代码、栈和堆。随机放置这些区域导致攻击者更难预测内存的位置，从而更难利用它们。有些类型的攻击（比如说return-to-libc攻击），会覆写栈的一部分，然后把控制转移到这个区域。这个区域经常是共享C库libc。如果栈和libc的位置是未知的，这类攻击的成功率就会降低。</p><p>如果代码位于内存的不可执行区域，<strong>数据执行保护</strong>（Data Execution Prevention，DEP）技术会阻止执行这些代码。在有些类型的攻击中，恶意代码会覆写内存的某个区域，然后将控制转移到这个区域。如果这个区域（比如栈或是堆）的代码不可执行，那么恶意代码就无法执行了。这种技术可以用硬件实现，也可以用软件实现</p></blockquote><h2 id="7-1-指针的声明和初始化"><a href="#7-1-指针的声明和初始化" class="headerlink" title="7.1 指针的声明和初始化"></a>7.1 指针的声明和初始化</h2><h3 id="7-1-1-不恰当的指针声明"><a href="#7-1-1-不恰当的指针声明" class="headerlink" title="7.1.1 不恰当的指针声明"></a>7.1.1 不恰当的指针声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr1, ptr2;<span class="comment">//ptr1为int指针变量，ptr2为int变量</span></span><br><span class="line"><span class="type">int</span> *ptr1, *ptr2;<span class="comment">//ptr1和ptr2都是int指针变量</span></span><br><span class="line"><span class="type">int</span> *ptr1;<span class="comment">//每个变量声明独占一行更好</span></span><br><span class="line"><span class="type">int</span> *ptr2;</span><br></pre></td></tr></table></figure><blockquote><p>用类型定义代替宏定义是另一个好习惯。类型定义允许编译器检查作用域规则，而宏定义不一定会</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PINT int*</span></span><br><span class="line">PINT ptr1,ptr2;</span><br></pre></td></tr></table></figure><blockquote><p>这里定义效果同上，ptr1为int指针变量，ptr2为int变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PINT;</span><br><span class="line">PINT ptr1,ptr2;</span><br></pre></td></tr></table></figure><blockquote><p>这里ptr1和ptr2都是int指针变量</p></blockquote><h3 id="7-1-2-使用指针前未初始化"><a href="#7-1-2-使用指针前未初始化" class="headerlink" title="7.1.2 使用指针前未初始化"></a>7.1.2 使用指针前未初始化</h3><blockquote><p>在初始化指针之前就使用指针会导致运行时错误，有时候将这种指针称为<strong>野指针</strong></p></blockquote><h3 id="7-1-3-处理未初始化指针"><a href="#7-1-3-处理未初始化指针" class="headerlink" title="7.1.3 处理未初始化指针"></a>7.1.3 处理未初始化指针</h3><blockquote><p>以下三种方法用来处理未初始化指针</p><ul><li>总是使用NULL来初始化指针</li><li>使用assert函数<ul><li>如果assert()函数参数为真，那么什么都不会发生，如果表达式为假，程序会终止</li></ul></li><li>使用第三方工具</li></ul></blockquote><h2 id="7-2-指针的使用问题"><a href="#7-2-指针的使用问题" class="headerlink" title="7.2 指针的使用问题"></a>7.2 指针的使用问题</h2><blockquote><p>很多安全问题聚焦的是缓冲区溢出的概念，以下几种情况可能导致缓冲区溢出：</p><ul><li><p>访问数组元素时没有检查索引值；</p></li><li><p>对数组指针做指针算术运算时不够小心；</p></li><li><p>用gets这样的函数从标准输入读取字符串；</p></li><li><p>误用strcpy和strcat这样的函数</p></li></ul><p>如果缓冲区溢出发生在栈帧的元素上，就可能把栈帧的返回地址部分覆写为对同一时间创建的恶意代码的调用。函数返回时会将控制转移到恶意函数，该函数可以执行任何操作，只受限于当前用户的特权等级</p></blockquote><h3 id="7-2-1-测试NULL"><a href="#7-2-1-测试NULL" class="headerlink" title="7.2.1 测试NULL"></a>7.2.1 测试NULL</h3><blockquote><p>用malloc这类函数时一定要检查返回值，否则可能会导致程序非正常终止</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//malloc分配内存失败</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//进行后续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-错误使用解引操作"><a href="#7-2-2-错误使用解引操作" class="headerlink" title="7.2.2 错误使用解引操作"></a>7.2.2 错误使用解引操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">int *pi=&amp;num;</span><br><span class="line">---</span><br><span class="line">int num;</span><br><span class="line">int *pi;</span><br><span class="line">pi=&amp;num;</span><br><span class="line">---</span><br><span class="line">int num;</span><br><span class="line">int *pi;</span><br><span class="line">*pi=&amp;num;//错误，不能把地址赋值给int型变量</span><br></pre></td></tr></table></figure><h3 id="7-2-3-迷途指针"><a href="#7-2-3-迷途指针" class="headerlink" title="7.2.3 迷途指针"></a>7.2.3 迷途指针</h3><blockquote><p>释放指针后却仍然在引用原来的内存，就会产生迷途指针，这其内容可能已经改变。对这块内存进行写操作可能会损坏内存，而读操作则可能返回无效数据，这两种情况都可能导致程序终止</p></blockquote><h3 id="7-2-4-越过数组边界访问内存"><a href="#7-2-4-越过数组边界访问内存" class="headerlink" title="7.2.4 越过数组边界访问内存"></a>7.2.4 越过数组边界访问内存</h3><blockquote><p>没有什么可以阻止程序访问为数组分配空间以外的内存；使用下标计算的地址不会检查索引值</p></blockquote><h3 id="7-2-5-错误计算数组长度"><a href="#7-2-5-错误计算数组长度" class="headerlink" title="7.2.5 错误计算数组长度"></a>7.2.5 错误计算数组长度</h3><blockquote><p>将数组传递给函数时，一定要同时传递数组长度。这个信息帮助函数避免越过数组边界</p></blockquote><h3 id="7-2-6-错误使用sizeof操作符"><a href="#7-2-6-错误使用sizeof操作符" class="headerlink" title="7.2.6 错误使用sizeof操作符"></a>7.2.6 错误使用sizeof操作符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int buffer[20];</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(buffer));//80字节</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(buffer)/sizeof(int));20个</span><br></pre></td></tr></table></figure><h3 id="7-2-7-匹配指针类型"><a href="#7-2-7-匹配指针类型" class="headerlink" title="7.2.7 匹配指针类型"></a>7.2.7 匹配指针类型</h3><blockquote><p>最好使用合适的指针类型来存储数据！</p></blockquote><h3 id="7-2-8-有界指针"><a href="#7-2-8-有界指针" class="headerlink" title="7.2.8 有界指针"></a>7.2.8 有界指针</h3><blockquote><p><strong>有界指针</strong>是指指针的使用被限制在有效的区域内。C没有对这类指针提供直接支持，但可以显示确保这个限制得以执行。</p><ul><li>创建指针检验函数</li><li>使用ANSI-C和C++的边界模型检查工具CBMC</li></ul><p>C++中的智能指针提供了一种模仿指针同时支持边界检查的方法，不幸的是，C没有智能指针</p></blockquote><h3 id="7-2-9-字符串的安全问题"><a href="#7-2-9-字符串的安全问题" class="headerlink" title="7.2.9 字符串的安全问题"></a>7.2.9 字符串的安全问题</h3><blockquote><p>字符串相关的安全问题一般发生在越过字符串末尾写入的情况</p><p>如果使用strcpy和strcat这类字符串函数，稍不留神就会引发缓冲区溢出。strncpy和strncat函数可以对这种操作提供一些支持，它们的size_t参数指定要复制的字符的最大数量。不过，如果字符数量计算不正确，替代函数也容易出错</p></blockquote><ul><li>C11中（Annex K）加入了strcat_s和strcpy_s函数，如果发生缓冲区溢出，它们会返回错误，目前只有Microsoft Visual C++支持</li><li>还有scanf_s和wscanf_s函数可以用来防止缓冲区溢出</li></ul><blockquote><p>gets函数从标准输入读取一个字符串，并把字符保存在目标缓冲区中，它可能会越过缓冲区的声明长度写入。如果字符串太长的话，就会发生缓冲区溢出。</p></blockquote><h3 id="7-2-10-指针算术运算和结构体"><a href="#7-2-10-指针算术运算和结构体" class="headerlink" title="7.2.10 指针算术运算和结构体"></a>7.2.10 指针算术运算和结构体</h3><blockquote><p>我们应该只对数组使用指针算术运算，因为数组肯定分配在连续的内存块上，指针算术运算可以得到有效的偏移量。不过，不应该将它们用在结构体内，因为结构体的字段可能分配在不连续的内存区域，因为存在内存对齐的情况</p><p>即使结构体内的内存是连续的，用指针算术运算来访问结构体的字段也不是好做法</p></blockquote><h3 id="7-2-11-函数指针的问题"><a href="#7-2-11-函数指针的问题" class="headerlink" title="7.2.11 函数指针的问题"></a>7.2.11 函数指针的问题</h3><blockquote><p>函数和函数指针用来控制程序的执行顺序，但是它们可能会被误用，导致不可预期的行为</p><p>如果函数和函数指针的签名不同，不要把函数赋给函数指针，这样会导致未定义的行为</p><p>函数指针可以执行不同的函数，这取决于分配给它的地址</p></blockquote><h2 id="7-3-内存释放问题"><a href="#7-3-内存释放问题" class="headerlink" title="7.3 内存释放问题"></a>7.3 内存释放问题</h2><h3 id="7-3-1-重复释放"><a href="#7-3-1-重复释放" class="headerlink" title="7.3.1 重复释放"></a>7.3.1 重复释放</h3><blockquote><p>将同一块内存释放两次称为重复释放</p><p>避免这类问题的简单办法是释放指针后总是将其置为NULL，大部分堆管理器都会忽略后续对空指针的释放</p></blockquote><h3 id="7-3-2-清除敏感数据"><a href="#7-3-2-清除敏感数据" class="headerlink" title="7.3.2 清除敏感数据"></a>7.3.2 清除敏感数据</h3><blockquote><p>一旦不再需要内存中的敏感数据，马上进行覆写掉是个好主意。当应用程序终止后，大部分操作系统都不会把用到的内存清零或是执行别的操作。系统可能会将之前用过的空间分配给别的程序，那么它就能访问内存中的内容。覆写敏感数据后别的应用程序就难以从之前持有这部分数据的内存中获取有用的信息</p></blockquote><h2 id="7-4-使用静态分析工具"><a href="#7-4-使用静态分析工具" class="headerlink" title="7.4 使用静态分析工具"></a>7.4 使用静态分析工具</h2><blockquote><p>有很多静态分析工具可以检查指针的误用，此外，大部分编译器都有选项来监测本章提到的很多问题。比如说，GCC编译器的-Wall选项可以启用编译器警告</p></blockquote><h1 id="第八章-其他重要内容"><a href="#第八章-其他重要内容" class="headerlink" title="第八章 其他重要内容"></a>第八章 其他重要内容</h1><blockquote><p>本章将研究以下几个很指针相关的主题</p><ul><li>指针的类型转换；</li><li>访问硬件设备；</li><li>别名和强别名；</li><li>使用restrict关键字；</li><li>线程；</li><li>面向对象技术</li></ul></blockquote><blockquote><p>关于线程，我们对两个方面感兴趣：一是用指针在线程之间共享数据这个基本问题，二是如何用指针支持回调函数。一个操作可能会调用某函数来执行任务，如果实际被调用的函数发生了改变，我们就称之为回调函数。我们可以使用回调函数在线程之间通信</p><p>本章会讲到两种在C中支持面向对象类型的方法：第一种是用不透明指针，这种技术对用户隐藏了数据结构的实现细节；第二种技术说明如何在C中实现多态类型。</p></blockquote><h2 id="8-1-转换指针"><a href="#8-1-转换指针" class="headerlink" title="8.1 转换指针"></a>8.1 转换指针</h2><blockquote><p>类型转换是一种基本操作，跟指针结合使用时很有用。转换指针对我们大有帮助，原因包括：</p><ul><li>访问有特殊目的的地址；</li><li>分配一个地址来表示端口；</li><li>判断机器的字节序</li></ul><p>机器的字节序一般是指数据类型内部的字节顺序。两种常见的字节序是小字节序和大字节序。小字节序是指将低位字节存储在低地址中，而大字节序是指将高位字节存储在低地址中</p></blockquote><h3 id="8-1-1-访问特殊用途的地址"><a href="#8-1-1-访问特殊用途的地址" class="headerlink" title="8.1.1 访问特殊用途的地址"></a>8.1.1 访问特殊用途的地址</h3><blockquote><p>访问特殊用途的地址的需求一般发生在嵌入式系统上，嵌入式系统对应用程序的介入很少</p></blockquote><h3 id="8-1-2-访问端口"><a href="#8-1-2-访问端口" class="headerlink" title="8.1.2 访问端口"></a>8.1.2 访问端口</h3><blockquote><p>端口既是硬件概念，也是软件概念。服务器用软件端口指明它们要接收发给这台机器的某类消息。硬件端口通常是一个连接到外部设备的物理输入输出系统组件。程序通过读写硬件端口可以处理信息和命令</p></blockquote><blockquote><p>机器用十六进制地址表示端口，将数据作为无符号整数处理。volatile关键字修饰符表示可以在程序以外改变变量。比如说，外部设备可能会向端口写入数据，且可以独立于计算机的处理器执行这个写操作。出于优化目的，编译器有时候会临时使用缓存或是寄存器来持有内存中的值，如果外部的操作修改了这个内存位置，改动并不能反映到缓存或寄存器中。</p><p>用volatile关键字可以阻止运行时系统使用寄存器暂存端口值，每次访问端口都需要系统读写端口，而不是从寄存器中读取一个可能已经过期的值。我们不应该把所有变量都声明为volatile，因为这样会阻碍编译器进行所有类型的优化，用非volatile变量访问volatile内存不是个好主意，这么做会导致未定义的行为</p><p>之后应用程序可以通过解引端口指针来读写端口</p></blockquote><h3 id="8-1-3-使用DMA访问内存"><a href="#8-1-3-使用DMA访问内存" class="headerlink" title="8.1.3 使用DMA访问内存"></a>8.1.3 使用DMA访问内存</h3><blockquote><p>直接内存访问（Direct Memory Access，DMA）是一种辅助系统在内存和某些设备间传输数据的底层操作，它不属于ANSI C规范，但是操作系统通常提供对这种操作的支持。DMA操作一般与CPU并行进行，这样可以将CPU解放出来执行其他任务，从而得到更好的性能。</p><p>程序员先调用DMA函数，然后等待操作完成。通常，程序员会提供一个回调函数，当操作完成后，操作系统会调用回调函数，回调函数由函数指针指定</p></blockquote><h3 id="8-1-4-判断机器的字节序"><a href="#8-1-4-判断机器的字节序" class="headerlink" title="8.1.4 判断机器的字节序"></a>8.1.4 判断机器的字节序</h3><blockquote><p>我们可以使用类型转换操作来判断架构的字节序。<strong>字节序</strong>是指内存单元中字节的顺序，字节序一般分为<strong>小字节序</strong>和<strong>大字节序</strong></p></blockquote><h2 id="8-2-别名、强别名和restrict关键字"><a href="#8-2-别名、强别名和restrict关键字" class="headerlink" title="8.2 别名、强别名和restrict关键字"></a>8.2 别名、强别名和restrict关键字</h2><blockquote><p>如果两个指针引用同一内存地址，则其中一个指针是另一个指针的别名</p><p>当编译器为指针生成代码时，除非特别指定，它必须假设可能会存在别名。使用别名会对编译器生成代码有所限制，如果两个指针引用同一位置，那么任何一个都可能修改这个位置。当编译器生成读写这个位置的代码时，它就不能通过把值放入寄存器来优化性能。对于每次引用，它只能执行机器级别的加载和保存操作。频繁的加载&#x2F;保存会很低效，在某些情况下，编译器还必须关心操作执行的顺序</p></blockquote><blockquote><p><strong>强别名</strong>是另一种别名，它不允许一种类型的指针成为另一种类型的指针的别名。强别名规则对符号或修饰符不起作用</p></blockquote><blockquote><p>不过，有些情况下，对同样的数据采用不同的表现形式也是有用的，为了避免别名问题，可以采用这几种技术：</p><ul><li>使用联合体</li><li>关闭强别名</li><li>使用char指针</li></ul></blockquote><blockquote><p>编译器总是假定char指针是任意对象的潜在别名，所以，大部分情况下可以安全地使用。不过，把其他数据类型的指针转换成char指针，再把char指针转换成其他数据类型的指针，则会导致未定义的行为，应该避免这么做</p></blockquote><h3 id="8-2-1-使用联合体以多种方式表示值"><a href="#8-2-1-使用联合体以多种方式表示值" class="headerlink" title="8.2.1 使用联合体以多种方式表示值"></a>8.2.1 使用联合体以多种方式表示值</h3><blockquote><p>C是类型语言，在声明变量时就得为其指定类型。可以存在不同类型的多个变量，有时候，可能需要把一种类型转换成另一种类型，这一般是通过类型转换实现的，不过也可以使用联合体。<strong>类型双关</strong>就是指这种绕开类型系统的技术。但如果转换涉及指针，可能会产生严重问题</p></blockquote><h3 id="8-2-2-强别名"><a href="#8-2-2-强别名" class="headerlink" title="8.2.2 强别名"></a>8.2.2 强别名</h3><blockquote><p>编译器不会强制使用强别名，它只会产生警告。编译器假设两个或更多不同类型的指针永远不会引用同一个对象，这也包括除名字外其他都相同的结构体的指针。有了强别名，编译器可以做某些类型的优化</p></blockquote><h3 id="8-2-3-使用restrict关键字"><a href="#8-2-3-使用restrict关键字" class="headerlink" title="8.2.3 使用restrict关键字"></a>8.2.3 使用restrict关键字</h3><blockquote><p>C编译器默认假设指针有别名，用restrict关键字可以在声明指针时告诉编译器这个指针没有别名，这样就允许编译器产生更高效的代码。很多情况下这是通过缓存指针实现的，不过要记住这只是个建议，编译器也可以选择不优化代码。如果用了别名，那么执行代码会导致未定义行为，编译器不会因为破坏强别名假设而提供任何警告信息</p></blockquote><h2 id="8-3-线程和指针"><a href="#8-3-线程和指针" class="headerlink" title="8.3 线程和指针"></a>8.3 线程和指针</h2><blockquote><p>线程之间共享数据会引发一些问题。常见的问题是数据损坏。线程可以写入对象，但可能时不时地被挂起，导致对象处于不一致的状态。之后另一个线程可能会在第一个线程继续写入之前读取对象，那么第二个线程就会使用无效的或损坏的数据</p></blockquote><h3 id="8-3-1-线程间共享指针"><a href="#8-3-1-线程间共享指针" class="headerlink" title="8.3.1 线程间共享指针"></a>8.3.1 线程间共享指针</h3><blockquote><p>两个或更多线程共享数据可能损坏数据。</p></blockquote><h3 id="8-3-2-使用函数指针支持回调"><a href="#8-3-2-使用函数指针支持回调" class="headerlink" title="8.3.2 使用函数指针支持回调"></a>8.3.2 使用函数指针支持回调</h3><blockquote><p>是如果一个线程的事件导致另一个线程的函数调用，就称为回调。将回调函数的指针传递给线程，而函数的某个事件会引发对回调函数的调用，这种方法在GUI应用程序中处理用户线程事件很有用</p></blockquote><h2 id="8-4-面向对象技术"><a href="#8-4-面向对象技术" class="headerlink" title="8.4 面向对象技术"></a>8.4 面向对象技术</h2><blockquote><p>C不支持面向对象编程，不过，借助不透明指针，我们也可以使用C封装数据以及支持某种程度的多态行为。我们可以隐藏数据结构的实现和支持函数，用户没有必要知道数据结构的实现细节，减少这些实现细节就可以降低应用程序的复杂度</p><p>多态行为可以帮助提高应用程序的可维护性。多态函数的行为取决于它执行的目标对象，这意味着我们可以更容易地为应用程序添加功能</p></blockquote><h3 id="8-4-1-创建和使用不透明指针"><a href="#8-4-1-创建和使用不透明指针" class="headerlink" title="8.4.1 创建和使用不透明指针"></a>8.4.1 创建和使用不透明指针</h3><blockquote><p>不透明指针用来在C中实现数据封装。一种方法是在头文件中声明不包含任何实现细节的结构体，然后在实现文件中定义与数据结构的特定实现配合使用的函数。数据结构的用户可以看到声明和函数原型，但是实现会被隐藏（在.c&#x2F;.obj文件中）。</p></blockquote><h3 id="8-4-2-C中的多态"><a href="#8-4-2-C中的多态" class="headerlink" title="8.4.2 C中的多态"></a>8.4.2 C中的多态</h3><blockquote><p>C++这类面向对象语言的多态是建立在基类及派生类之间继承关系的基础上的。C不支持继承，所以我们得模拟结构体之间的继承</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C:数组指针与指针数组</title>
      <link href="/2022/11/13/C-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
      <url>/2022/11/13/C-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h1><h3 id="1-数组指针"><a href="#1-数组指针" class="headerlink" title="1.数组指针"></a>1.数组指针</h3><blockquote><p>即数组的指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;<span class="comment">//int型数组</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>];<span class="comment">//数组指针,指向包含三个int型数组的指针</span></span><br><span class="line"><span class="comment">//优先级: ()&gt;[]&gt;*</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;数组a的起始地址:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line"> &lt;&lt; <span class="string">&quot;数组b的起始地址:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">-----------</span><br><span class="line">数组a的起始地址:<span class="number">0x61fdfc</span> </span><br><span class="line">数组b的起始地址:<span class="number">0x61fdf0</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到数组a和数组b位于栈空间上，a的起始地址大于b</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;sizeof(p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;sizeof(*p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(*p) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">------------</span><br><span class="line"><span class="built_in">sizeof</span>(a)=<span class="number">12</span></span><br><span class="line"><span class="built_in">sizeof</span>(p)=<span class="number">8</span></span><br><span class="line"><span class="built_in">sizeof</span>(*p)=<span class="number">12</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cxxabi.h&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(a).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">*p type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">a type:<span class="type">int</span> [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>p</code>表示指向包含三个<code>int</code>型变量数组的<strong>指针</strong>，其存放的是&#x3D;&#x3D;地址&#x3D;&#x3D;，因此其占用空间大小根据机器是<code>32</code>位还是<code>64</code>位有所不同，我电脑是<code>64</code>位的，因此其占用空间为<code>8</code>字节。</p><p><code>*p</code>可以认为表示的是包含三个<code>int</code>型变量的<strong>数组</strong>，因此其占用空间为<code>3*4=12</code>字节，表示的就是整型数组<code>a</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;数组a地址:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;a[0]地址:&quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;a[1]地址:&quot;</span> &lt;&lt; &amp;a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;a[2]地址:&quot;</span> &lt;&lt; &amp;a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p =&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*p + 1 =&quot;</span> &lt;&lt; *p + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*p + 2 =&quot;</span> &lt;&lt; *p + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*p)=&quot;</span> &lt;&lt; *(*p) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*p + 1)=&quot;</span> &lt;&lt; *(*p + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*p + 2)=&quot;</span> &lt;&lt; *(*p + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------下面储存地址与数组无法对应-----------*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p =&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p + 1 =&quot;</span> &lt;&lt; p + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p + 1 =&quot;</span> &lt;&lt; p + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p =&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(p + 1)=&quot;</span> &lt;&lt; *(p + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(p + 2)=&quot;</span> &lt;&lt; *(p + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;**p =&quot;</span> &lt;&lt; **p &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;**(p + 1)=&quot;</span> &lt;&lt; **(p + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;**(p + 2)=&quot;</span> &lt;&lt; **(p + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0]=&quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p[1]=&quot;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;p[2]=&quot;</span> &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------结果----------------</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>)=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">数组a地址:<span class="number">0x61fdf0</span></span><br><span class="line">a[<span class="number">0</span>]地址:<span class="number">0x61fdf0</span></span><br><span class="line">a[<span class="number">1</span>]地址:<span class="number">0x61fdf4</span></span><br><span class="line">a[<span class="number">2</span>]地址:<span class="number">0x61fdf8</span></span><br><span class="line">*p =<span class="number">0x61fdf0</span></span><br><span class="line">*p + <span class="number">1</span> =<span class="number">0x61fdf4</span></span><br><span class="line">*p + <span class="number">2</span> =<span class="number">0x61fdf8</span></span><br><span class="line">*(*p)=<span class="number">4</span></span><br><span class="line">*(*p + <span class="number">1</span>)=<span class="number">5</span></span><br><span class="line">*(*p + <span class="number">2</span>)=<span class="number">6</span></span><br><span class="line"><span class="comment">/*--------下面储存地址与数组无法对应-----------*/</span></span><br><span class="line">p =<span class="number">0x61fdf0</span></span><br><span class="line">p + <span class="number">1</span> =<span class="number">0x61fdfc</span></span><br><span class="line">p + <span class="number">1</span> =<span class="number">0x61fe08</span></span><br><span class="line">*p =<span class="number">0x61fdf0</span></span><br><span class="line">*(p + <span class="number">1</span>)=<span class="number">0x61fdfc</span></span><br><span class="line">*(p + <span class="number">2</span>)=<span class="number">0x61fe08</span></span><br><span class="line">**p =<span class="number">4</span></span><br><span class="line">**(p + <span class="number">1</span>)=<span class="number">0</span></span><br><span class="line">**(p + <span class="number">2</span>)=<span class="number">6422000</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">0x61fdf0</span></span><br><span class="line">p[<span class="number">1</span>]=<span class="number">0x61fdfc</span></span><br><span class="line">p[<span class="number">2</span>]=<span class="number">0x61fe08</span></span><br></pre></td></tr></table></figure><blockquote><p><em>个人理解</em>：</p><ul><li><p><code>p</code>指向数组<code>a</code>的地址(首地址)即<code>a[0]</code>也即<code>4</code>的地址，<code>p+1</code>指向数组<code>c</code>的地址(首地址)即将该指针往后移动<code>length</code>字节，<code>length</code>为<code>p</code>指向数组的所有元素的字节数；这里我先定义数组<code>c</code>，再定义数组<code>a</code>使得<code>p+1</code>指向数组<code>c</code>(理论上可用<code>p+1</code>指针访问数组<code>c</code>，但实践中不能这样访问)</p></li><li><p><code>p</code>指向数组<code>a</code>的地址(<code>p</code>可以理解为指向二维数组的指针，但这里实际上指向一维数组)，<code>*p</code>指向数组<code>a</code>第一个元素的地址，<code>*p+1</code>指向数组<code>a</code>第二个元素的地址，<code>**p</code>则表示提领<code>*p</code>地址的元素值。</p><ul><li><p>对于二维数组<code>arr</code>来说，<code>p</code>指向数组<code>arr[0]</code>即<code>&#123;1,6,9,4&#125;</code>的地址，<code>p+1</code>指向数组<code>arr[1]</code>即<code>&#123;5,6,7,8&#125;</code>的地址，以此类推。</p></li><li><p><code>*p</code>表示长度为4的整型数组，直接输出<code>*p</code>即相当于输出其地址，使用<code>**p</code>提领该<code>*p</code>地址的值</p></li></ul>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">p=arr;</span><br><span class="line">cout &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;arr[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">                            </span><br><span class="line">------------</span><br><span class="line"><span class="number">0x7ffc3814ec30</span> <span class="number">0x7ffc3814ec40</span> <span class="number">0x7ffc3814ec50</span></span><br><span class="line"><span class="number">0x7ffc3814ec30</span> <span class="number">0x7ffc3814ec40</span> <span class="number">0x7ffc3814ec50</span></span><br><span class="line">------------</span><br><span class="line">arr type:<span class="type">int</span> [<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line">arr[<span class="number">0</span>] type:<span class="type">int</span> [<span class="number">4</span>]</span><br><span class="line">&amp;arr[<span class="number">0</span>] type:<span class="built_in">int</span> (*) [<span class="number">4</span>]</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">4</span>]</span><br><span class="line">*p type:<span class="type">int</span> [<span class="number">4</span>]</span><br><span class="line">**p type:<span class="type">int</span></span><br></pre></td></tr></table></figure><ul><li>对于<code>arr[0]</code>和<code>&amp;arr[0]</code>来说，其类似于<code>*p</code>和<code>p</code>，因此直接输出两者值一样</li></ul></li><li><p>由于<code>*p+n</code>可以代表数组<code>a</code>的元素的地址，n从0开始，因此使用<code>*p+1</code>和<code>*p+2</code>依次访问<code>a[1]</code>和<code>a[2]</code>的地址，使用<code>*(*p+1)即a[1]</code>和<code>*(*p+2)即a[2]</code>访问对应的数据。若此时<code>p</code>指向二维数组<code>arr</code>，则<code>p+1</code>指向数组<code>arr</code>第二行的首地址即<code>arr[1]</code>也即<code>&amp;arr[1]</code>，<code>*(p+1)</code>表示该数组第二行第一个元素地址，<code>*(p+1)+1</code>表示该数组第二行第二个元素地址，依次类推。</p></li></ul></blockquote><h5 id="对于二维整型数组array-i-j-来说，定义数组指针int-p-j-来指向该数组array即p-array，则有如下结论："><a href="#对于二维整型数组array-i-j-来说，定义数组指针int-p-j-来指向该数组array即p-array，则有如下结论：" class="headerlink" title="对于二维整型数组array[i][j]来说，定义数组指针int (*p)[j]来指向该数组array即p=array，则有如下结论："></a>对于二维整型数组<code>array[i][j]</code>来说，定义数组指针<code>int (*p)[j]</code>来指向该数组<code>array</code>即<code>p=array</code>，则有如下结论：</h5><ul><li><code>p</code>指向该数组第一行，<code>p+1</code>指向数组第二行，…，<code>p+k</code>指向数组第<code>k+1</code>行，依此类推；</li><li><code>*p</code>指向该数组第一行第一列元素，<code>*p+1</code>指向该数组第一行第二列元素，…，<code>*(p+k)+m</code>指向该数组第<code>k+1</code>行第<code>m+1</code>列元素</li><li><code>*p</code>表示该数组第一行第一列的元素即<code>array[0][0]</code>，<code>*(*p+1)</code>指向该数组第一行第二列的元素即<code>array[0][1]</code>，…，<code>*(*(p+k)+m)</code>表示该数组第<code>k+1</code>行第<code>m+1</code>列的元素即<code>array[k][m]</code></li></ul><h4 id="数组指针指向一-x2F-二维数组"><a href="#数组指针指向一-x2F-二维数组" class="headerlink" title="数组指针指向一&#x2F;二维数组"></a>数组指针指向一&#x2F;二维数组</h4><ul><li>一维数组赋值给数组指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">p=&amp;a;<span class="comment">//正确</span></span><br><span class="line">p=a;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">a type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">&amp;a type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>错误原因</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:<span class="number">66</span>:<span class="number">6</span>: error: cannot convert <span class="string">&#x27;int [3]&#x27;</span> to <span class="string">&#x27;int (*)[3]&#x27;</span> in assignment</span><br><span class="line">p = a;</span><br><span class="line">^</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>这是因为<code>&amp;a</code> 是指整个数组的首地址，而<code>a</code>是指数组首元素的首地址，虽然二者值相同的，但表示的意义不同。这里<code>p</code>是数组指针，指向整个数组。<code>p=&amp;a</code>等号两边的数据类型完全一致，而<code>p=a</code>等号两边的数据类型不一致，因此会提示错误信息。</p><p>&#x3D;&#x3D;补充：<code>a</code>表示数组名称，<code>&amp;a</code>表示整个数组的首地址，类型为<code>int (*) [3]</code>，<code>a+1</code>表示数组的第二个元素地址，类型为<code>int*</code>，<code>&amp;a[0]</code>表示数组首元素地址，类型为<code>int*</code>，<code>a[0]</code>表示数组首元素值，类型为<code>int</code>&#x3D;&#x3D;</p></blockquote></blockquote><ul><li>二维数组赋值给数组指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">p = arr;<span class="comment">//正确</span></span><br><span class="line">p = &amp;arr;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">arr type:<span class="type">int</span> [<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line">&amp;arr type:<span class="built_in">int</span> (*) [<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line">p type:<span class="built_in">int</span> (*) [<span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><p>错误原因</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array2.cpp:<span class="number">10</span>:<span class="number">6</span>: error: cannot convert ‘<span class="built_in">int</span> (*)[<span class="number">3</span>][<span class="number">4</span>]’ to ‘<span class="built_in">int</span> (*)[<span class="number">4</span>]’ in assignment</span><br><span class="line">   <span class="number">10</span> |  p = &amp;arr;</span><br><span class="line">      |      ^~~~</span><br><span class="line">      |      |</span><br><span class="line">      |      <span class="built_in">int</span> (*)[<span class="number">3</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>这里错误的原因同一维数组</p></blockquote></blockquote><h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h3><ul><li>存放一维数组元素的地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">4</span>];<span class="comment">//定义数组指针</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// p[0] = &amp;a[0];</span></span><br><span class="line"><span class="comment">// p[1] = &amp;a[1];</span></span><br><span class="line"><span class="comment">// p[2] = &amp;a[2];</span></span><br><span class="line"><span class="comment">// p[3] = &amp;a[3];</span></span><br><span class="line"><span class="comment">//等价于下面语句</span></span><br><span class="line">*p = &amp;a[<span class="number">0</span>];<span class="comment">//指针数组赋值</span></span><br><span class="line">*(p + <span class="number">1</span>) = &amp;a[<span class="number">1</span>];</span><br><span class="line">*(p + <span class="number">2</span>) = &amp;a[<span class="number">2</span>];</span><br><span class="line">*(p + <span class="number">3</span>) = &amp;a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><blockquote><p>这里给指针数组赋值不能只写<code>*p=&amp;a[0]</code>，否则后面利用它来访问数组的时候会出问题，因为没有把数组<code>a</code>的其他元素地址赋值给指针数组<code>p</code>的其他元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[0]=&quot;</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[1]=&quot;</span> &lt;&lt; &amp;a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[2]=&quot;</span> &lt;&lt; &amp;a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a[3]=&quot;</span> &lt;&lt; &amp;a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[0]=&quot;</span> &lt;&lt; &amp;p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[1]=&quot;</span> &lt;&lt; &amp;p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[2]=&quot;</span> &lt;&lt; &amp;p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[3]=&quot;</span> &lt;&lt; &amp;p[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0]=&quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[1]=&quot;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[2]=&quot;</span> &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[3]=&quot;</span> &lt;&lt; p[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+1)=&quot;</span> &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+2)=&quot;</span> &lt;&lt; *(p+<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+3)=&quot;</span> &lt;&lt; *(p+<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//-------other-----</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+1=&quot;</span> &lt;&lt; p+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+2=&quot;</span> &lt;&lt; p+<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+3=&quot;</span> &lt;&lt; p+<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line"><span class="comment">//p type:int* [4]</span></span><br><span class="line"><span class="comment">//*p type:int*</span></span><br><span class="line"><span class="comment">//sizeof(p)=32</span></span><br><span class="line"><span class="comment">//sizeof(*p)=8</span></span><br><span class="line">&amp;a[<span class="number">0</span>]=<span class="number">0x61fdd0</span></span><br><span class="line">&amp;a[<span class="number">1</span>]=<span class="number">0x61fdd4</span></span><br><span class="line">&amp;a[<span class="number">2</span>]=<span class="number">0x61fdd8</span></span><br><span class="line">&amp;a[<span class="number">3</span>]=<span class="number">0x61fddc</span></span><br><span class="line"></span><br><span class="line">&amp;p[<span class="number">0</span>]=<span class="number">0x61fde0</span></span><br><span class="line">&amp;p[<span class="number">1</span>]=<span class="number">0x61fde8</span></span><br><span class="line">&amp;p[<span class="number">2</span>]=<span class="number">0x61fdf0</span></span><br><span class="line">&amp;p[<span class="number">3</span>]=<span class="number">0x61fdf8</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">0x61fdd0</span></span><br><span class="line">p[<span class="number">1</span>]=<span class="number">0x61fdd4</span></span><br><span class="line">p[<span class="number">2</span>]=<span class="number">0x61fdd8</span></span><br><span class="line">p[<span class="number">3</span>]=<span class="number">0x61fddc</span></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line">*p=<span class="number">0x61fdd0</span></span><br><span class="line">*(p+<span class="number">1</span>)=<span class="number">0x61fdd4</span></span><br><span class="line">*(p+<span class="number">2</span>)=<span class="number">0x61fdd8</span></span><br><span class="line">*(p+<span class="number">3</span>)=<span class="number">0x61fddc</span></span><br><span class="line"><span class="comment">//---other-----</span></span><br><span class="line">p=<span class="number">0x61fde0</span></span><br><span class="line">p+<span class="number">1</span>=<span class="number">0x61fde8</span></span><br><span class="line">p+<span class="number">2</span>=<span class="number">0x61fdf0</span></span><br><span class="line">p+<span class="number">3</span>=<span class="number">0x61fdf8</span></span><br></pre></td></tr></table></figure><blockquote><p>这里<code>p</code>是指针数组，类型为<code>int* [4]</code>，其中存放的是一维数组<code>a</code>的各个元素的地址，<code>*p</code>是指针数组中的指针，类型为<code>int*</code>，其存放的是一维数组<code>a</code>中一个元素的地址。</p><p>对于指针数组<code>p</code>，<code>&amp;p[0]、&amp;p[1]、&amp;p[2]、&amp;p[3]</code>是指针数组<code>p</code>自身的地址，用于存放数组<code>a</code>的地址；<code>p[0]、p[1]、p[2]、p[3]</code>存放的是数组<code>a</code>的<code>&#123;1,2,3,4&#125;</code>对应元素的地址。</p><p>使用指针数组<code>p</code>来访问数组<code>a</code>时，<code>p[i]</code>和<code>*(p+i)</code>都是取数组<code>a</code>某个元素的地址，<code>*p[i]</code>和<code>*(*p+i)</code>都是取数组<code>a</code>某个元素的值。</p></blockquote><ul><li>存放二维数组元素的地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// p[0] = b[0];</span></span><br><span class="line"><span class="comment">// p[1] = b[1];</span></span><br><span class="line"><span class="comment">// p[2] = b[2];</span></span><br><span class="line"><span class="comment">// p[3] = b[3];</span></span><br><span class="line"><span class="comment">//等价于下面语句</span></span><br><span class="line">*p = b[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = b[<span class="number">1</span>];</span><br><span class="line">*(p + <span class="number">2</span>) = b[<span class="number">2</span>];</span><br><span class="line">*(p + <span class="number">3</span>) = b[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &amp;b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b+<span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b+<span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b+<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;b[1] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;b[<span class="number">1</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b[1] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(b[<span class="number">1</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b+1 type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(b+<span class="number">1</span>).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;**p type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(**p).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(p[<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="number">0x61fdd0</span> <span class="number">0x61fdd8</span> <span class="number">0x61fde0</span> <span class="number">0x61fde8</span></span><br><span class="line"><span class="number">0x61fdd0</span> <span class="number">0x61fdd8</span> <span class="number">0x61fde0</span> <span class="number">0x61fde8</span></span><br><span class="line"><span class="number">0x61fdd0</span> <span class="number">0x61fdd8</span> <span class="number">0x61fde0</span> <span class="number">0x61fde8</span></span><br><span class="line">&amp;b[<span class="number">1</span>] type:<span class="built_in">int</span> (*) [<span class="number">2</span>]</span><br><span class="line">b[<span class="number">1</span>] type:<span class="type">int</span> [<span class="number">2</span>]</span><br><span class="line">b+<span class="number">1</span> type:<span class="built_in">int</span> (*) [<span class="number">2</span>]</span><br><span class="line">p type:<span class="type">int</span>* [<span class="number">4</span>]</span><br><span class="line">*p type:<span class="type">int</span>*</span><br><span class="line">**p type:<span class="type">int</span></span><br><span class="line">p[<span class="number">0</span>] type:<span class="type">int</span>*</span><br></pre></td></tr></table></figure><blockquote><p>对于二维数组<code>b</code>，<code>b+1、b[1]、&amp;b[1]</code>的值都相同，但是其表示的意义不同；<code>b+i</code>和<code>&amp;b[i]</code>表示二维数组第<code>i+1</code>行数组(这里是一维数组)的首地址，<code>b[i]</code>表示二维数组第<code>i+1</code>行数组(一维数组)的第一个元素的首地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[0]=&quot;</span> &lt;&lt; &amp;p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[1]=&quot;</span> &lt;&lt; &amp;p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[2]=&quot;</span> &lt;&lt; &amp;p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p[3]=&quot;</span> &lt;&lt; &amp;p[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+1=&quot;</span> &lt;&lt; p+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+2=&quot;</span> &lt;&lt; p+<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+3=&quot;</span> &lt;&lt; p+<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+1)=&quot;</span> &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+2)=&quot;</span> &lt;&lt; *(p+<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+3)=&quot;</span> &lt;&lt; *(p+<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*p)=&quot;</span> &lt;&lt; *(*p) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*p+1)=&quot;</span> &lt;&lt; *(*p + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*(p+1))=&quot;</span> &lt;&lt; *(*(p + <span class="number">1</span>)) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*(p+1)+1)=&quot;</span> &lt;&lt; *(*(p + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*(p+2))=&quot;</span> &lt;&lt; *(*(p + <span class="number">2</span>)) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*(p+2)+1)=&quot;</span> &lt;&lt; *(*(p + <span class="number">2</span>) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(*(p+3))=&quot;</span> &lt;&lt; *(*(p + <span class="number">3</span>)) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;*(*(p+3)+1)=&quot;</span> &lt;&lt; *(*(p + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">&amp;p[<span class="number">0</span>]=<span class="number">0x61fe00</span></span><br><span class="line">&amp;p[<span class="number">1</span>]=<span class="number">0x61fe08</span></span><br><span class="line">&amp;p[<span class="number">2</span>]=<span class="number">0x61fe10</span></span><br><span class="line">&amp;p[<span class="number">3</span>]=<span class="number">0x61fe18</span></span><br><span class="line">p=<span class="number">0x61fe00</span></span><br><span class="line">p+<span class="number">1</span>=<span class="number">0x61fe08</span></span><br><span class="line">p+<span class="number">2</span>=<span class="number">0x61fe10</span></span><br><span class="line">p+<span class="number">3</span>=<span class="number">0x61fe18</span></span><br><span class="line">*p=<span class="number">0x61fde0</span></span><br><span class="line">*(p+<span class="number">1</span>)=<span class="number">0x61fde8</span></span><br><span class="line">*(p+<span class="number">2</span>)=<span class="number">0x61fdf0</span></span><br><span class="line">*(p+<span class="number">3</span>)=<span class="number">0x61fdf8</span></span><br><span class="line">*(*p)=<span class="number">1</span> *(*p+<span class="number">1</span>)=<span class="number">3</span></span><br><span class="line">*(*(p+<span class="number">1</span>))=<span class="number">2</span> *(*(p+<span class="number">1</span>)+<span class="number">1</span>)=<span class="number">4</span></span><br><span class="line">*(*(p+<span class="number">2</span>))=<span class="number">5</span> *(*(p+<span class="number">2</span>)+<span class="number">1</span>)=<span class="number">7</span></span><br><span class="line">*(*(p+<span class="number">3</span>))=<span class="number">6</span> *(*(p+<span class="number">3</span>)+<span class="number">1</span>)=<span class="number">8</span></span><br></pre></td></tr></table></figure><blockquote><p>这里和数组指针访问二维数组基本一致</p><p>值得注意的是，用数组指针和指针数组同时指向二维数组时，其引用和使用数组名引用都是一样的</p><p>表示数组中<code>i</code>行<code>j</code>列的一个元素，下面的表示都是等价的：</p><p><code>*(*(p+i)+j)、*(p[i]+j)、(*(p+i))[j]和p[i][j]</code></p></blockquote><h3 id="3-二维数组相关"><a href="#3-二维数组相关" class="headerlink" title="3.二维数组相关"></a>3.二维数组相关</h3><blockquote><p>总结指针在数组中的一些应用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">100</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(array).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array[0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(array[<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;array[0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;array[<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;array[0][0] type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;array[<span class="number">0</span>][<span class="number">0</span>]).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array+1 type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(array+<span class="number">1</span>).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*array type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*array).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*array) type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(&amp;(*array)).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&amp;(*array) type:&quot;</span>&lt;&lt;abi::__cxa_demangle(<span class="built_in">typeid</span>(*&amp;(*array)).<span class="built_in">name</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line">array type:<span class="type">int</span> [<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">array[<span class="number">0</span>] type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">&amp;array[<span class="number">0</span>] type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">&amp;array[<span class="number">0</span>][<span class="number">0</span>] type:<span class="type">int</span>*</span><br><span class="line">array+<span class="number">1</span> type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">*array type:<span class="type">int</span> [<span class="number">3</span>]</span><br><span class="line">&amp;(*array) type:<span class="built_in">int</span> (*) [<span class="number">3</span>]</span><br><span class="line">*&amp;(*array) type:<span class="type">int</span> [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>从上面的输出可以看出，<code>array</code>是数组名，同时也可以说成是指向<code>array[0][0]</code>地址的指针，此时，<code>array</code>&#x2F;<code>array[0]</code>&#x2F;<code>&amp;array[0]</code>&#x2F;<code>&amp;array[0][0]</code>的值是一样的，都是指向数组最开始的地址，但它们表示的含义是不同的。</p><p>从类型结果来看，<code>array</code>&#x2F;<code>array+1</code>&#x2F;<code>array+2</code>分别是该数组每一行整个一维数组的地址，等同于<code>&amp;array[0]</code>&#x2F;<code>&amp;array[1]</code>&#x2F;<code>&amp;array[2]</code>；<code>*array</code>&#x2F;<code>*(array+1)</code>&#x2F;<code>*(array+2)</code>分别是该数组每一行的首地址，等同于<code>array[0]</code>&#x2F;<code>array[1]</code>&#x2F;<code>array[2]</code>； </p><p>&#x3D;&#x3D;相当于C语言直接将相邻的方括号<code>[]</code>使用<code>*</code>来表示，比如说a[1]和1[a]，最后展开后是<code>*(a+1)</code>和<code>*(1+a)</code>，本质上都是相同的&#x3D;&#x3D;；</p><p>还有值得注意的就是，<code>&amp;</code>和<code>*</code>的操作是互逆的，这里<code>&amp;</code>是取地址操作符，这里<code>*</code>是指针运算符，也能说是取内容运算符，相当于找到该指针指向变量的值。</p></blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/mick_hu/article/details/100931034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166806157116782388032815%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166806157116782388032815&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100931034-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_control2&utm_term=%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187">数组指针和指针数组</a></p><p><a href="https://www.cnblogs.com/mq0036/p/3382732.html">数组指针和指针数组的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux:创建用户和修改权限</title>
      <link href="/2022/11/09/Linux-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%92%8C%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/"/>
      <url>/2022/11/09/Linux-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%92%8C%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建用户"><a href="#一、创建用户" class="headerlink" title="一、创建用户"></a>一、创建用户</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser [USER]</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>[USER]</code>为用户名</p></li><li><p>新的<code>UNIX</code>密码是该用户密码，然后其他信息输入根据需要选择是否输入(当然一路回车也可)</p></li><li><p>执行完上述命令后即可创建好用户(自动在<code>/home</code>目录下创建同名文件夹)，此时默认用户权限为<code>755</code>即<code>(drwxr-xr-x)</code></p></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194607.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194632.png"></p><hr><blockquote><p><code>useradd</code>和<code>adduser</code>的区别</p></blockquote><ul><li><code>useradd</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加用户：sudo useradd -m 用户名 </span><br><span class="line">设置密码：sudo passwd 用户名</span><br><span class="line">删除用户：sudo userdel  -r  用户名</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>useradd</code>时，如果后面不添加任何参数选项，如<code>sudo useradd test</code>创建出来的用户将是默认“三无”用户：一无<code>Home Directory</code>，二无密码，三无系统<code>Shell</code>，因此利用这个用户登录系统，是登录不了的</p><p>使用<code>useradd -m +用户名</code>的方式创建，它会在<code>/home</code>目录下创建同名文件夹，然后利用<code>passwd + 用户名</code>为指定的用户名设置密码</p></blockquote><ul><li><code>adduser</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser 用户名</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>adduser</code>时，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。</p><p><code>adduser</code>会提示设置密码，<code>useradd</code>不会</p><p><code>adduser</code>会创建用户目录，<code>useradd</code>不会</p><p><code>adduser</code>会询问全名，房间号码，电话号码等用户信息，<code>useradd</code>不会</p></blockquote><h1 id="二、修改权限"><a href="#二、修改权限" class="headerlink" title="二、修改权限"></a>二、修改权限</h1><p><img src="https://img-blog.csdnimg.cn/20210129232516224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1NDE1NQ==,size_16,color_FFFFFF,t_70"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> 777 user</span><br><span class="line">$ sudo <span class="built_in">chmod</span> 755 user</span><br></pre></td></tr></table></figure><blockquote><p>一般给权限<code>755</code>就可以了，最好别给<code>777</code>，不然就和<code>root</code>用户没什么区别了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194648.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20221109194703.png"></p><p>参考链接:</p><ul><li><a href="https://blog.csdn.net/xiaofengdada/article/details/122294475">linux用户和用户组详解(一）</a></li><li><a href="https://www.cnblogs.com/FengZeng666/p/13047659.html">useradd和adduser的区别与使用方法</a></li><li><a href="https://blog.csdn.net/weixin_42054155/article/details/113408572">chmod777到底是什么意思</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习笔记</title>
      <link href="/2022/09/04/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/04/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB学习笔记"><a href="#MATLAB学习笔记" class="headerlink" title="MATLAB学习笔记"></a>MATLAB学习笔记</h1><blockquote><p><strong>注：本篇学习笔记来自<a href="https://weread.qq.com/web/bookDetail/6a132d2059faf26a1107cdc">《MATLAB从基础到精通》</a>，书中采用MATLAB 7.0，因此后面相关函数在新版本MATLAB中可能需要做些修改才能运行。</strong></p></blockquote><h2 id="第一章-MATLAB常用数据类型："><a href="#第一章-MATLAB常用数据类型：" class="headerlink" title="第一章 MATLAB常用数据类型："></a><strong>第一章 MATLAB常用数据类型：</strong></h2><blockquote><p>整型、浮点型、逻辑类型、结构体、元胞数组及字符串等</p><p>MATLAB数据类型在使用中与其他编程语言相比，有一个突出的特点，即不用对变量的数据类型进行定义，MATLAB软件会自动依据变量被赋值的情况，生成相应数据类型的数据。(和JavaScript有点像)</p></blockquote><h3 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;whos<span class="comment">%查看工作空间变量</span></span><br><span class="line">&gt;&gt;isinteger(value)<span class="comment">%判断变量value数据类型是否是整型</span></span><br></pre></td></tr></table></figure><ul><li><code>intmin()</code>和<code>intmax()</code>函数可用于确定整型数据类型的数据范围(最大值和最小值)，其中<code>intmin()</code>函数用于求数据类型的下限，<code>intmax()</code>函数用于求数据类型的上限。</li></ul><h3 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single()/double()函数：单精度/双精度浮点型(<span class="number">32</span>/<span class="number">64</span>位)</span><br><span class="line">&gt;&gt; isfloat(value)<span class="comment">%判断变量value数据类型是否是浮点型(是返回&quot;1&quot;，否则返回&quot;0&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><code>realmin (&#39;single&#39;)</code>和<code>realmin(&#39;double&#39;)</code>函数，分别返回数据类型单精度浮点型和双精度浮点型的最小值，<code>realmax(&#39;single&#39;)</code>和<code>realmax(&#39;double&#39;)</code>分别返回其相应的最大值</li></ul><h3 id="3-逻辑类型"><a href="#3-逻辑类型" class="headerlink" title="3.逻辑类型"></a>3.逻辑类型</h3><ul><li><p>逻辑类型仅包括两个值：“0”和“1”，分别代表逻辑“假”和“真”。</p></li><li><p>逻辑类型主要用于关系和逻辑运算，在使用过程中通过查找、条件语句的逻辑判断，可以判断条件是否为真。</p></li></ul><blockquote><ul><li>查找矩阵中符合条件的数据：大于5则返回”1”，否则返回”0”</li><li>逻辑非运算，矩阵中元素是0返回”1”，否则返回”0”</li></ul></blockquote><h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h3><blockquote><p>字符串生成：主要通过直接赋值法、已有字符串的连接和其他数据类型的转换</p><p>一维字符串</p><ul><li><p>直接赋值法</p></li><li><p>连接法：<code>strcat()</code>函数&#x2F;连接符”[]”</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;str2=strcat(str1,<span class="string">&quot;str&quot;</span>)</span><br><span class="line">&gt;&gt;str3=[str1,str2]</span><br></pre></td></tr></table></figure></li></ul><p>二维字符串</p><ul><li>二维字符串的生成方法与一维类似，不过使用连接符“[ ]”连接时，二维字符串要求每行的字符有相同的列数，如果每行列数不同会报错，此时可以通过填空补足</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;str2=char(<span class="string">&#x27;ABC&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>)<span class="comment">% char()创建二维字符串，列数不同字符行，末尾自动留空</span></span><br><span class="line">&gt;&gt;str3=strvcat(str1,str2)<span class="comment">%垂直连接字符串</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="4-1-字符串操作函数"><a href="#4-1-字符串操作函数" class="headerlink" title="4.1 字符串操作函数"></a>4.1 字符串操作函数</h5><ul><li>字符串判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ischar(s):判断s数据类型是否为字符串</span><br><span class="line">isletter(s):判断s中每个字符元素是否为字母</span><br><span class="line">isspace(s):判断s中每个字符元素是否为空格</span><br></pre></td></tr></table></figure><ul><li>字符串访问</li></ul><p>通过下标法来实现的，即根据字符元素在字符串中的位置来访问，其中位置的确定包括行列坐标和线性索引坐标两种方式。在MTALAB中字符数组是按列存储的。</p><ul><li>字符串查找和替换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strfind(str,s):在字符串str中查找字符s</span><br><span class="line">findstr(s1,s2):在长字符串中查找短字符串</span><br><span class="line">strrep(s1,s2,s3):在字符串s1中查找字符串s2并将其替换为字符串s3</span><br><span class="line">i = strmatch(s1,s2):在字符串s1中匹配查找与字符串s2起始一致的字符行，返回行号</span><br><span class="line">i = strmatch(s1,s2,’exact’):在字符串s1中匹配查找与字符串s2完全一致的字符行，返回行号</span><br></pre></td></tr></table></figure><ul><li>字符串比较</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k=strcmp(s1,s2):比较字符串s1和s2是否相同</span><br><span class="line">k=strncmp(s1,s2,n):比较字符串s1和s2前n个字符是否相同</span><br><span class="line">k=strcmpi(s1,s2):比较字符串s1和s2是否相同，不区分字符串字母的大小写</span><br></pre></td></tr></table></figure><ul><li>字符串大小写转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=lower(s):将字符串s中的大写英文字母全部转换为小写</span><br><span class="line">str=upper(s):将字符串s中的小写英文字母全部转换为大写</span><br></pre></td></tr></table></figure><ul><li>字符串执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval()函数可用于字符串表达式的执行，函数的具体用法如下:</span><br><span class="line">eval(expression):用于在命令行执行expression中的字符串表达式</span><br><span class="line">[a1,a2,a3,...]=eval(‘function(b1,b2,b3,...)’):其中&quot;function(b1,b2,b3,...)&quot;为待执行的字符串表达式，&quot;a1,a2,a3,...&quot;为字符串表达式的输出结果</span><br></pre></td></tr></table></figure><ul><li>字符串空格操作相关函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str=strtok(s):查找字符串第一个空格前的字符，返回到字符串str中</span><br><span class="line">str=deblank(s):去除字符串s末尾的空格，返回去除空格的字符串str</span><br><span class="line">str=strtrim(s):删除字符串s头尾的空格，返回去除空格的字符串str</span><br><span class="line">blanks(n):生成含n个空格的字符串</span><br></pre></td></tr></table></figure><h3 id="5-元胞数组"><a href="#5-元胞数组" class="headerlink" title="5.元胞数组"></a>5.元胞数组</h3><blockquote><p>元胞数组是由可以包括任何数据类型的元胞组成的数组</p></blockquote><h5 id="5-1元胞数组创建"><a href="#5-1元胞数组创建" class="headerlink" title="5.1元胞数组创建"></a>5.1元胞数组创建</h5><ul><li>直接赋值法:直接在命令行中给元胞数组的每个元素赋值，或者使用大括号“{ }”创建元胞数组</li><li>函数法:使用<code>cell()</code>函数创建(先对元胞内存空间预分配，再对元胞中的元素进行赋值)</li></ul><h5 id="5-2元胞数组访问"><a href="#5-2元胞数组访问" class="headerlink" title="5.2元胞数组访问"></a>5.2元胞数组访问</h5><ul><li>大括号访问元胞数组:可对其数据执行操作</li><li>小括号访问元胞数组:不可对其数据执行操作</li></ul><h5 id="5-3元胞数组显示"><a href="#5-3元胞数组显示" class="headerlink" title="5.3元胞数组显示"></a>5.3元胞数组显示</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">celldisp(s):用于显示元胞数组s中的具体内容</span><br><span class="line">celldisp(s,name):以字符串name为元胞名，显示元胞数组s中的具体内容</span><br><span class="line">cellplot(s):以图形化的方式显示元胞数组s</span><br><span class="line">cellplot(s,&#x27;legend&#x27;):以图形化的方式显示元胞数组s，同时显示不同数据类型的颜色图例标注</span><br></pre></td></tr></table></figure><h5 id="5-4元胞数组删除"><a href="#5-4元胞数组删除" class="headerlink" title="5.4元胞数组删除"></a>5.4元胞数组删除</h5><blockquote><p>元胞数组的删除主要是通过把需要删除的元胞赋值为空来实现。通过大括号和小括号访问元胞并将其置空，可以分别删除元胞数组的内容或整体</p></blockquote><h3 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6.结构体"></a>6.结构体</h3><blockquote><p>结构体数据类型可以把不同数据类型的变量放到同一个变量名下，通过不同“域”的概念对结构体中的不同数据进行赋值、操作。结构体中的数据存储在相应的“域”中</p></blockquote><h5 id="6-1结构体生成"><a href="#6-1结构体生成" class="headerlink" title="6.1结构体生成"></a>6.1结构体生成</h5><ul><li>命令行直接赋值法:直接把不同类型的数据赋值给结构体变量不同的域中</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结构与域之间用点号“.”连接，不同域中可保存不同数据类型的变量</span><br><span class="line">&gt;&gt;ss.str=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&gt;&gt;ss.num=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">&gt;&gt;ss</span><br><span class="line">ss=</span><br><span class="line">str:<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">num:[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li>函数法:<code>struct()</code>函数创建结构体变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=struct(&#x27;field1&#x27;,values1,&#x27;field2&#x27;,value2,...)% “&#x27;field1&#x27;”和“&#x27;field2&#x27;”为域名，“values1”和“values2”为域中的值</span><br></pre></td></tr></table></figure><h5 id="6-2结构体操作"><a href="#6-2结构体操作" class="headerlink" title="6.2结构体操作"></a>6.2结构体操作</h5><ul><li>结构体元素访问</li><li>结构体显示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fieldnames()函数显示结构体的域名</span><br><span class="line">getfield()函数显示结构体各域中的具体内容</span><br></pre></td></tr></table></figure><ul><li>结构体删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = rmfield(ss,&#x27;field&#x27;):用于删除结构体中的域“field”</span><br><span class="line">s = rmfield(ss,FIELDS):用于同时删除结构体中的多个域，FIELDS为需要删除的多个域的域名的字符串</span><br></pre></td></tr></table></figure><h3 id="7-不同数据类型转化"><a href="#7-不同数据类型转化" class="headerlink" title="7.不同数据类型转化"></a>7.不同数据类型转化</h3><ul><li>数组与字符串转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = num2str(A):把数值型数据数组A转换为字符型数据，默认情况下转换的数据精度为5位有效数字</span><br><span class="line">str = num2str(A,precision):按照指定的数据精度转换数组A到字符串类型数据str，precision为字符串中数据的有效位数</span><br><span class="line">str = num2str(A,format):按照指定的数据格式转换数组A到字符串类型数据str。format的书写格式为%m1.m2g/f/e，其中m1指定总共显示的有效数字位数，m2代表小数点后的有效数字位数，“g”格式代表用指数或定点标记，“e”格式代表用指数标记，“f”格式代表用定点标记，与函数sprinf()的输出显示设置相同</span><br><span class="line">x = str2num(&#x27;str&#x27;):字符串转化为数组</span><br></pre></td></tr></table></figure><blockquote><p>int2str()函数和str2int()函数可以完成整型数据与字符串的转换，即取整数据与字符串的转换。mat2str()函数和str2mat()函数可以实现矩阵与字符串的转换，其用法类似于num2str()函数和str2num()函数，但不可以用于高维数组</p></blockquote><ul><li>不同进制数据转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dec2hex(x)和hex2dec(x):用于十六进制数和十进制数之间的相互转换</span><br><span class="line">dec2bin(x)和bin2dec(x):用于二进制数和十进制数之间的相互转换</span><br><span class="line">str=dec2base(d,base)和d=base2dec(&#x27;strn&#x27;,base):用于任意进制的数与十进制数之间的转换</span><br></pre></td></tr></table></figure><ul><li>元胞数组与数值类型转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = num2cell(A):转换数组A到元胞数组c</span><br><span class="line">c = num2cell(A,dims):按照指定的维数转换数组A到元胞数组c</span><br></pre></td></tr></table></figure><blockquote><p>char()函数和cellstr()函数用于元胞数组和字符串之间的转换；</p><p>cell2struct()函数和struct2cell()函数可用于元胞数组和结构体的转换</p></blockquote><h2 id="第二章-矩阵和数组"><a href="#第二章-矩阵和数组" class="headerlink" title="第二章 矩阵和数组"></a><strong>第二章 矩阵和数组</strong></h2><h3 id="1-矩阵和数组的概念"><a href="#1-矩阵和数组的概念" class="headerlink" title="1.矩阵和数组的概念"></a>1.矩阵和数组的概念</h3><p>数组为具有相同数据类型的数据组合，矩阵的概念主要应用于数学中，在MATLAB中矩阵一般即指二维数组，但是矩阵与数组在部分运算上又是有很大区别的</p><h3 id="2-矩阵和数组创建"><a href="#2-矩阵和数组创建" class="headerlink" title="2.矩阵和数组创建"></a>2.矩阵和数组创建</h3><ul><li>直接输入法</li></ul><blockquote><p>同一行中的数据使用空格或者逗号分隔</p><p>分号表示每一行数据输入结束</p><p>所有数据都包含在方括号“[ ]”中</p></blockquote><ul><li>函数法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zeros()函数:全零矩阵生成。一般用于初始变量创建时预留内存空间，在后面的计算中再为矩阵元素赋具体的值</span><br><span class="line">eye()函数:单位矩阵生成。用法与全零矩阵生成方法类似，但是eye()函数不支持二维以上矩阵的生成</span><br><span class="line">ones()函数:全1矩阵生成，用法同zeros()函数</span><br><span class="line">rand()函数:随机矩阵生成。只用于生成0～1的平均分布的随机数，不包括0和1</span><br><span class="line">randn()函数:用于生成均值为0，方差为1的正态分布的随机数，其他用法同rand()函数</span><br><span class="line">randperm(n)函数:用于生成1:n随机分布的n个正整数</span><br><span class="line">compan()函数:生成伴随矩阵，只适用于向量</span><br><span class="line">magic()函数:生成魔方矩阵，矩阵每行、每列及两条对角线上元素和都相等</span><br><span class="line">diag()函数:生成对角矩阵，即只有对角线上有非零元素的矩阵</span><br><span class="line">triu()/tril函数:上/下三角矩阵，即对角线以下/上元素全为0的矩阵</span><br></pre></td></tr></table></figure><ul><li>外部导入法</li></ul><p>通过数据导入平台或者文件输入函数，把txt、excel、mat等文件中存储的数据导入MATLAB工作空间内，并以矩阵的形式存储数据</p><h3 id="3-矩阵和数组基本操作"><a href="#3-矩阵和数组基本操作" class="headerlink" title="3.矩阵和数组基本操作"></a>3.矩阵和数组基本操作</h3><h5 id="3-1-基本信息获取"><a href="#3-1-基本信息获取" class="headerlink" title="3.1 基本信息获取"></a>3.1 基本信息获取</h5><ul><li>数据显示: <code>disp(x)</code>函数在命令行窗口输出矩阵x，不显示矩阵名(语句后不加分号也能显示)</li><li>矩阵判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isempty(A):判断矩阵是否为空，若为空返回1，否则返回0</span><br><span class="line">空矩阵是指没有任何元素的矩阵，一般的使用过程中，对空矩阵执行操作会出错，因而在对矩阵进行一些操作前需要判断矩阵是否为空</span><br><span class="line">isequal(A,B):判断矩阵A、B的数值是否相等，仅当A、B矩阵所有元素都相等时返回1，否则返回0</span><br><span class="line">isfloat(A):判断矩阵A的数据类型是否为浮点型，如果是则返回1，否则返回0</span><br><span class="line">isinteger(A):判断矩阵A的数据类型是否为整数型，如果是则返回1，否则返回0</span><br></pre></td></tr></table></figure><ul><li>大小信息获取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size(X):用于获取矩阵X的行数和列数</span><br><span class="line">length(X):用于获取矩阵X的长度，即矩阵行数或列数中的较大值</span><br><span class="line">numel(X):用于获取矩阵X中元素个数总和</span><br><span class="line">ndims(X):用于获取矩阵X的维数</span><br></pre></td></tr></table></figure><h5 id="3-2-元素访问"><a href="#3-2-元素访问" class="headerlink" title="3.2 元素访问"></a>3.2 元素访问</h5><ul><li>单个元素访问</li></ul><blockquote><p>矩阵和数组是由行和列组成的，例如矩阵A中A(i,j)对应于矩阵的第i行、第j列的元素，可以通过数据行列形式访问指定行列下标的元素。同时MATLAB提供矩阵单下标的数据访问方式，这主要是因为基于矩阵的列存储数据的，第i行、j列的数据对应单下标即为(j-1)*m+i，其中m为矩阵的行数。在访问到需要的单个元素，即可进一步对访问到的单个元素进行编辑操作</p></blockquote><ul><li>多个元素访问</li></ul><blockquote><p>通过矩阵的下标或者根据矩阵中元素的线性索引值来访问</p></blockquote><ul><li>行列元素访问</li></ul><blockquote><p>行列元素的访问通过冒号运算符来实现，对于行数据访问，“：”代表所有列的数据，对于列数据访问，“：”代表所有行数据，即A(i,:)访问矩阵的第i行的所有数据。A(:,j)访问矩阵的第j列的所有数据</p></blockquote><ul><li>全部元素访问</li></ul><blockquote><p>矩阵全部元素访问主要还是基于下标和单下标访问机制，只是在访问的时候以符号“：”代替所有元素</p></blockquote><ul><li>对角线元素访问</li></ul><blockquote><p>对角线元素的访问主要通过diag()函数来实现，该函数可用于生成对角矩阵，同时也可用于访问指定对角线上的元素，但不可利用此函数修改矩阵对角线上的值</p></blockquote><ul><li>end在矩阵元素访问中的使用</li></ul><blockquote><p>end在矩阵中代表最后一个元素，可以是一行的最后、一列的最后或者整个矩阵最后的一个元素，同时结合冒号的使用，可以访问从某个元素开始到最后的元素。使用end访问矩阵中的数据，可以不需要矩阵具体的大小</p></blockquote><ul><li><code>Find()</code>函数在矩阵元素访问中的访问</li></ul><blockquote><p>查找访问矩阵中满足一定条件的元素</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">indices=find(X):查找矩阵X中的非零元素，返回矩阵X中非零元素的线性索引</span><br><span class="line">indices=find(X,k):查找矩阵X中的非零元素，返回矩阵X中前k个非零元素的线性索引</span><br><span class="line">indices=find(X,k,’last’):查找矩阵X中的非零元素，返回矩阵X中后k个非零元素的线性索引</span><br><span class="line">[row,col]=find(X):查找矩阵X中的非零元素，返回矩阵X中非零元素的行列下标</span><br><span class="line">[row,col]=find(X,k):查找矩阵X中的非零元素，返回矩阵X中前k个非零元素的行列下标</span><br><span class="line">[row,col]=find(X,k,’last’):查找矩阵X中的非零元素，返回矩阵X中后k个非零元素的行列下标</span><br></pre></td></tr></table></figure><h3 id="4-矩阵及数组简单运算"><a href="#4-矩阵及数组简单运算" class="headerlink" title="4.矩阵及数组简单运算"></a>4.矩阵及数组简单运算</h3><h5 id="4-1-基本函数"><a href="#4-1-基本函数" class="headerlink" title="4.1 基本函数"></a>4.1 基本函数</h5><ul><li>连接函数</li></ul><blockquote><p>矩阵的连接包括水平方向左右连接和垂直方向上下连接，水平连接的矩阵需要具有相同的行数，垂直连接的矩阵需要具有相同的列数。而矩阵连接可以通过中括号“[]”或连接函数实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[A;B] :用于垂直方向连接具有相同列数的矩阵A和B</span><br><span class="line">[A B]或[A,B]:用于水平方向连接具有相同行数的矩阵A和B</span><br><span class="line">cat(dim,A,B):在指定维数上连接矩阵A和B，其中cat(1,A,B)相当于[A;B]，cat(2,A,B)相当于[A,B]和[A B]</span><br><span class="line">horzcat(A,B):用于水平方向连接矩阵A和B</span><br><span class="line">vertcat(A,B):用于垂直方向连接矩阵A和B</span><br></pre></td></tr></table></figure><ul><li>翻转函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fliplr(A):用于矩阵A的左右翻转，不适用于二维以上矩阵或数组</span><br><span class="line">flipud(A):用于矩阵A的上下翻转，不适用于二维以上矩阵或数组</span><br><span class="line">rot90(A):用于矩阵A逆时针90度翻转，rot90(A,k)可按逆时针方向90*k度旋转矩阵A</span><br><span class="line">transpose(A):用于返回转置后的矩阵A，同A&#x27;</span><br></pre></td></tr></table></figure><ul><li>改变矩阵大小</li></ul><blockquote><p>矩阵的大小即矩阵的行列数。在MATLAB 7.0中矩阵大小的改变可以通过添加、删除、拼接元素的方法来实现，同时可以通过函数重现排列、复制矩阵，达到改变矩阵大小的目的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = reshape(A,m,n):用于重新排列矩阵A，返回大小为m×n的矩阵B，矩阵A的元素个数需要等于m×n</span><br><span class="line">B = reshape(A,m,n,p,...):用于重新排列矩阵A，返回大小为m×n×p…的矩阵B，矩阵A的元素个数需要等于m×n×p…，用于高维数组的重排</span><br><span class="line">B = reshape(A,...,[],...):重排矩阵A，其中一维的大小可以使用默认值</span><br><span class="line">B = reshape(A,size):根据size函数得出的矩阵大小值重排矩阵</span><br></pre></td></tr></table></figure><blockquote><p>MATLAB 7.0提供了repmat()函数复制矩阵。矩阵的复制在矩阵运算中具有较大的用处，因为一般的矩阵加、减等运算要求矩阵具有相同的大小。而如果遇到一个矩阵每列（行）需要都加上或减去一个数值时，即矩阵与向量的操作，不同大小的矩阵无法相加减。如果通过循环，基于矩阵中每列（行）相加减，算法的效率不高，特别是当需要计算的矩阵很大时，对算法运行时间影响很大，而函数repmat()通过复制矩阵，可以向量生成与需要加、减的矩阵相同的矩阵，进行矩阵间的运算，算法效率较高</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = repmat(A,m,n):以A为重复单元，把A看做整体，返回m×n个A组成的矩阵B</span><br><span class="line">B = repmat(A,n):以A为重复单元，把A看做整体，返回n×n个A组成的矩阵B</span><br></pre></td></tr></table></figure><ul><li>其他常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B=unique(A):去除矩阵A中的重复元素，返回无重复元素的A到新变量B，B以向量形式存在，并按从小到大的顺序排列A中无重复的元素</span><br><span class="line">[B, m, n]=unique(A):去除A中重复元素，返回无重复元素的A到新向量B，m为B在A中的线性索引值，即b=A(m)，n为A在B中的索引值，即A=b(n)</span><br><span class="line">B=unique(A,&#x27;rows&#x27;):去除矩阵A中的重复行，返回新矩阵B，其中矩阵B中行的排列是按照第一列元素从小到大排列，如果第一列元素相同，则依次比较后面的列</span><br><span class="line">[B, m, n]=unique(A,&#x27;rows&#x27;):去除矩阵A中的重复行，返回新矩阵B，m为矩阵B在A中对应的行索引，即B=A(m,:)，n为矩阵A在B中对应的行索引，即A=B(n,:)</span><br><span class="line"></span><br><span class="line">indces=sub2ind(size, i, j):用于把矩阵的行列下标转换为线性索引下标，其中size为需要转换的矩阵的维数，i和j分别为需要转换的行、列下标值，indices返回大小为size的矩阵i行j列对应的线性索引值</span><br><span class="line">[i,j] = ind2sub(size, indces):用于将矩阵的线性索引下标转换为行列下标，其中size为需要转换的矩阵的维数，indices为需要转换的线性索引下标值，函数返回的i和j分别为indices对应的行、列下标值</span><br></pre></td></tr></table></figure><h5 id="4-2-加减运算"><a href="#4-2-加减运算" class="headerlink" title="4.2 加减运算"></a>4.2 加减运算</h5><blockquote><p>矩阵的加减运算要求相加减的矩阵有相同的维数，即相同的行列数，与线性代数中的运算法则是相同的</p></blockquote><h5 id="4-3-乘法运算"><a href="#4-3-乘法运算" class="headerlink" title="4.3 乘法运算"></a>4.3 乘法运算</h5><blockquote><p>矩阵与数组在乘法运算中有所区别，矩阵的乘法是线性代数中常用的运算，要求被乘矩阵的列数等于相乘矩阵的行数。而数组的乘法是点乘运算，即数组具有相同下标的元素相乘，运算时在一般乘法运算的“*”前加上“.”，需要两数组具有相同的维数</p><p>C&#x3D;A*B:用于矩阵的乘法，要求矩阵A的列数等于矩阵B的行数</p><p>C&#x3D;A.*B:用于数组的乘法，要求矩阵A和B具有相同的大小</p><p>注意，如果A和B中有一个为标量，则不需要遵守上述规则，标量与矩阵中每个元素相乘</p></blockquote><h5 id="4-4-除法运算"><a href="#4-4-除法运算" class="headerlink" title="4.4 除法运算"></a>4.4 除法运算</h5><blockquote><p>矩阵的除法与数组的除法有一定差异，其中矩阵的除法对应与线性代数中的逆运算相关，而数组的除法则是点除，是数组中相同下标元素的相除。同时除法运算又分为左除和右除</p></blockquote><ul><li>矩阵的除法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A\B:矩阵的左除，如果A为方阵，即n*n阶矩阵，可用于计算方程Ax=B的解，等效于inv(A)*B</span><br><span class="line">B/A:矩阵的右除，用于计算方程xA=B的解，等效于B*inv(A)</span><br></pre></td></tr></table></figure><ul><li>数组的除法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A./B:数组的左除，即A(i,j)/B(i,j)</span><br><span class="line">A.\B:数组的右除，即B(i,j)/A(i,j)</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果A是标量，数组的左除A.&#x2F;B即A除以矩阵数组B的每一个元素，右除A.\B即矩阵数组B的每个元素除以标量A；如果B是标量，则数组的左除A.&#x2F;B即矩阵数组A的每个元素除以B，右除A.\B即标量B除以矩阵数组A的每一个元素</p></blockquote><h5 id="4-5-乘方运算"><a href="#4-5-乘方运算" class="headerlink" title="4.5 乘方运算"></a>4.5 乘方运算</h5><blockquote><p>矩阵与数组在乘方运算中也有不同，矩阵的乘方相当于多个矩阵相乘，而数组的乘方即数组中每个元素的乘方运算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">矩阵的乘方运算:C=A^B。其中，A需为方阵，即矩阵的行列数相等，B为标量。A^B的运算即相当于B个矩阵A相乘</span><br><span class="line">数组的乘方运算:C=A.^B。其中，当A、B都为数组时，需大小相等；C(i,j)的计算结果即为A(i,j)的B(i,j)次方；如果A为标量，A.^B的运算即相当于分别对元素A做B(i,j)次方；如果B为标量，A.^B的运算即相当于对数组A中的每个元素做B阶乘方运算</span><br></pre></td></tr></table></figure><h3 id="5-矩阵的特殊运算"><a href="#5-矩阵的特殊运算" class="headerlink" title="5.矩阵的特殊运算"></a>5.矩阵的特殊运算</h3><ul><li>行列式运算</li></ul><blockquote><p>函数det用于计算矩阵的行列式。如果矩阵为方阵，则其存在行列式，可通过函数det计算出矩阵的行列式值，此值为一标量</p></blockquote><ul><li>逆运算</li></ul><blockquote><p>在线性代数中，若矩阵A是方阵，且为非奇异阵，即行列式值不为0，存在矩阵x使Ax&#x3D;I和xA&#x3D;I，x称为矩阵A的逆矩阵，记做A-1。在MATLAB中用函数inv()来计算矩阵的逆运算</p></blockquote><ul><li>秩运算</li></ul><blockquote><p>矩阵中线性无关的行数与列数称为矩阵的秩。在MATLAB 7.0中，函数rank()用于求矩阵的秩</p></blockquote><ul><li>特征值运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e=eig(x):其中e是由特征值组成的列向量，x是输入的方矩阵</span><br><span class="line">[v,d]=eig(x):方阵x的全部特征值，构成对角阵d，其对角线即为特征值，v是一个与x相同大小的矩阵，每一列是矩阵x的一个特征值所对应的特征向量</span><br></pre></td></tr></table></figure><h3 id="6-数组特殊运算"><a href="#6-数组特殊运算" class="headerlink" title="6.数组特殊运算"></a>6.数组特殊运算</h3><blockquote><p>在MATLAB中，数组的特殊运算主要包括关系运算、逻辑运算和集合运算，与一般的矩阵运算不同的是，这些运算都是基于数组中每个元素进行的</p></blockquote><h5 id="6-1-关系运算"><a href="#6-1-关系运算" class="headerlink" title="6.1 关系运算"></a>6.1 关系运算</h5><blockquote><p>MATLAB中的关系运算主要用于判断数组的大小关系，关系成立返回“1”，关系不成立则返回“0”。MATLAB中提供的关系符有大于（&gt;），小于（&lt;），大于等于（&gt;&#x3D;），小于等于（&lt;&#x3D;），等于（&#x3D;&#x3D;），不等于（～&#x3D;）。</p><p>其中，关系运算用于比较的两个对象如果都是数组，则要求数组大小相同，因为关系运算是判断两个数组相应位置上元素的大小关系；而如果比较的对象中有一个为标量，即标量与数组中每个元素进行比较。通过数组的关系运算可以方便地判断数组中元素的大小关系，同时数组与标量的关系运算也比较常用，结合查找函数find可以查找到符合一定条件的数组元素对应的位置信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组大于运算:C=A&gt;BC=(A&gt;B)C=gt(A,B)</span><br><span class="line">数组大于等于运算:C=A&gt;=BC=(A&gt;=B)C=ge(A,B)</span><br><span class="line">数组小于运算:C=A&lt;BC=(A&lt;B)C=lt(A,B)</span><br><span class="line">数组小于等于运算:C=A&lt;=BC=(A&lt;=B)C=le(A,B)</span><br><span class="line">数组等于运算:C=A==BC=(A==B)C=eq(A,B)</span><br><span class="line">数组不等于运算:C=A~=BC=(A~=B)C=ne(A,B)</span><br></pre></td></tr></table></figure><h5 id="6-2-逻辑运算"><a href="#6-2-逻辑运算" class="headerlink" title="6.2 逻辑运算"></a>6.2 逻辑运算</h5><blockquote><p>MATLAB中提供的逻辑运算主要有与运算（&amp;）、或运算（|）、非运算（~）、异或运算（xor）、快速逻辑与运算（&amp;&amp;）、快速逻辑或运算（||）和逻辑函数all、any</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">与运算(&amp;):C=A&amp;B，当数组A、B相应位置上的元素都为非零元素，即返回1，否则返回0</span><br><span class="line">或运算(|):C=A|B，当数组A、B相应位置上的元素至少一个为非零元素，即返回1，否则返回0</span><br><span class="line">非运算(~):C=~A，当数组A相应位置上的元素都为非零元素，即返回0，否则返回1</span><br><span class="line">异或运算(xor):C=xor(A,B)，当数组A、B相应位置上的元素一个为非零元素，一个为零，即返回1，否则返回0</span><br><span class="line">快速逻辑与运算(&amp;&amp;):C=A&amp;&amp;B，其中，A、B需为逻辑变量或标量，当A、B都为真或为标量时不为0，即返回1，否则返回0。在进行快速逻辑与运算的时候，如果A已发现是零，则不去判断B是否为零，直接返回结果“0”；但是如果A为1，即仍然要判断B是否为零</span><br><span class="line">快速逻辑或运算(||):C=A||B，A、B需为逻辑变量或标量，当A、B存在一个为真或一个标量不为0，即返回1，否则返回0。快速逻辑或运算当A判断结果为非零后，无须继续判断B，即返回结果“1”；如果A为零，则需进一步判断B是否为非零</span><br><span class="line"> all(x):判断数组x中的元素是否都为非零元素，是则返回“1”，否则返回“0”。当x为数组时，默认对列数据进行判断，即判断数组中各列元素是否都为非零元素。而如果需要判断行元素是否都为非零元素即指定判断的维数，all(x,dim)，其中dim=2用于行数据判断</span><br><span class="line"> any(x):判断数组x中的元素是否存在任何一个元素为非零元素，是则返回“1”，否则返回“0”。当x为数组时，默认对列数据进行判断，即判断数组中各列元素是否都为非零元素。而如果需要判断行元素是否存在非零元素即指定判断的维数，any(x,dim)，其中dim=2用于行数据判断</span><br></pre></td></tr></table></figure><h3 id="7-向量及其运算"><a href="#7-向量及其运算" class="headerlink" title="7.向量及其运算"></a>7.向量及其运算</h3><h5 id="7-1-向量的生成"><a href="#7-1-向量的生成" class="headerlink" title="7.1 向量的生成"></a>7.1 向量的生成</h5><blockquote><p>只有一行或一列元素的数组或矩阵即为向量，向量可以看成一维的数组或矩阵。向量可分为行向量和列向量</p></blockquote><ul><li>使用冒号法生成向量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用冒号法生成向量主要用于生成具有等间隔的向量，其格式为：x0:xstep:xend。其中，x0为向量的初始值，xstep为步长，xend为终止值</span><br></pre></td></tr></table></figure><ul><li>函数法生成向量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linspace(a,b,n):a和b是生成向量的初值和终值，n是向量中元素的个数。当n默认时，默认生成a～b范围内的100个元素</span><br><span class="line">logspace(a,b,n):10a和10b是生成向量的初值和终值，n是向量中元素的个数。当n默认时，默认生成10a～10b范围内的50个元素</span><br></pre></td></tr></table></figure><h5 id="7-2-向量的运算"><a href="#7-2-向量的运算" class="headerlink" title="7.2 向量的运算"></a>7.2 向量的运算</h5><ul><li><p>常用函数</p><ul><li>判断是否为向量: <code>isvector(x)</code>函数</li><li>向量内积: <code>dot(A,B)</code>函数</li><li>向量外积: <code>cross(A,B)</code>函数</li></ul></li><li><p>集合运算</p><ul><li>交集: <code>intersect(A,B)</code>函数</li><li>并集: <code>union(A,B)</code>函数</li><li>差集: <code>setdiff(A,B)</code>函数</li><li>异或: <code>setxor(A,B)</code>函数、</li></ul></li></ul><h3 id="8-高维数组操作"><a href="#8-高维数组操作" class="headerlink" title="8.高维数组操作"></a>8.高维数组操作</h3><blockquote><p>除上面的矩阵、数组、向量外，MATLAB还支持高维数组的使用，高维数组即二维以上的数组。不过一般情况下高维数组多用于存储数组，特别在图像处理中，对于一幅图像数据，多存储为高维数组</p></blockquote><h5 id="8-1-高维数组创建"><a href="#8-1-高维数组创建" class="headerlink" title="8.1 高维数组创建"></a>8.1 高维数组创建</h5><ul><li>直接输入法</li></ul><blockquote><p>通过给相应下标的数组元素赋值实现。**&#x3D;&#x3D;三维数组在原来矩阵的行、列基础上，增加了页作为第三维数组的表示&#x3D;&#x3D;**</p></blockquote><ul><li>函数法</li></ul><blockquote><p>使用zeros、ones、rand、repmat、reshape、cat等函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flipdim(A,dim)函数:实现高维数组的翻转操作</span><br><span class="line">A为需要翻转的数组，dim为翻转的基准维数，当dim为3时即对高维数组按页翻转</span><br></pre></td></tr></table></figure><h1 id="其余注意点"><a href="#其余注意点" class="headerlink" title="其余注意点"></a>其余注意点</h1><blockquote><p>Cell模式是MATLAB的一大特色，通过Cell模式的使用可以让用户在调试某一段代码块的时候，方便地重复运行，同时也向用户提供了代码块的思想。不同的功能可以设计成不同的代码块，分块执行代码，便于程序的执行、查错。</p><p>一段代码以%%标记后加一个空格即为代码块生成了Cell模式，光标移动到Cell模式中时，背景将变为浅黄色。按“Ctrl+Enter”组合键或者选择“Cell”→“Evaluate Current Cell”命令控制执行当前Cell模块下的代码。同时Cell模式的开启与关闭分别通过菜单项Enable Cell Mode和Disable Cell Mode控制</p><p>MATLAB提供了nargin()函数和nargout())函数输入&#x2F;输出参数</p><p>为测试程序执行的快慢，可以采用tic和toc函数计算代码运行时间</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入控制语句: input命令</span><br><span class="line">键盘输入语句: keyboard命令</span><br><span class="line">暂停语句: pause命令</span><br><span class="line">指令显示控制语句: echo命令</span><br><span class="line">返回语句: return命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATLAB提供的可具有警告提示功能的语句主要有warning语句、error语句、errordlg语句，其调用格式如下:</span><br><span class="line">warning(&#x27;message&#x27;):&quot;message&quot;中为程序出错的提示信息，出错警告后，程序继续执行</span><br><span class="line">error(&#x27;message&#x27;):&quot;message&quot;中为程序出错的提示信息，出错警告后，程序将终止运行</span><br><span class="line">errordlg(&#x27;errorstring&#x27;):&quot;errorstring&quot;中为程序出错的提示信息，显示在警告对话框中，出错警告后，单击&quot;ok&quot;按钮，结束弹出式出错提示框，但代码仍会执行完毕</span><br><span class="line">errordlg(&#x27;errorstring&#x27;,&#x27;dlgname&#x27;):弹出警告对话框，&#x27;dlgname&#x27;为对话框中的标题</span><br></pre></td></tr></table></figure><h2 id="第三章-图形处理"><a href="#第三章-图形处理" class="headerlink" title="第三章 图形处理"></a><strong>第三章 图形处理</strong></h2><h3 id="1-基本绘图处理"><a href="#1-基本绘图处理" class="headerlink" title="1.基本绘图处理"></a>1.基本绘图处理</h3><h5 id="1-1-常用函数"><a href="#1-1-常用函数" class="headerlink" title="1.1 常用函数"></a>1.1 常用函数</h5><ul><li><code>plot()</code>函数:二维图形绘制</li><li><code>plotyy()</code>函数:双y轴图形绘制(适用于两组数据的数据范围相差较大但又希望放在同一图形中比较分析)</li><li><code>loglog()</code>函数:对数坐标图形绘制(x,y轴均为对数的坐标系)</li><li><code>semilogx()/semilogy()</code>函数:半对数坐标图形绘制</li><li><code>fplot()</code>函数:符号函数绘制</li></ul><blockquote><p>根据函数的表达式自动调整自变量的范围，无须给函数赋值，直接生成能反映函数变化规律的图形，在函数变化快的区域，采用小的间隔，否则采用大的坐标间，使绘制的图形计算量与时间最小，而又能尽可能精确反映图形的变化。fplot()函数一般在对横坐标取值间隔没有明确要求，仅查看函数的大致变化规律的情况下使用</p></blockquote><ul><li><code>ezplot()</code>函数:符号函数绘制</li></ul><blockquote><p>与fplot函数的功能基本类似，可以方便地绘制表达式或函数的图形。不同的是该函数的表达式显示在图形的上方，同时对坐标轴可不加任何限制做图</p></blockquote><ul><li><code>grid</code>函数:图形栅格控制</li><li><code>hold</code>函数:图形保持控制    <code>ishold</code>函数测试图形的保持状态,返回值“1”表示图形处于叠加状态，“0”表示图形处于覆盖状态</li><li><code>ginput()</code>函数:读点函数(交互式的从MATLAB绘制的图形中读取点坐标)</li><li><code>zoom</code>函数:图形缩放</li><li><code>saves()</code>函数:按照指定格式保存图形</li><li><code>print()</code>函数:图形打印(打印图形窗口的图形，必须紧跟在<code>plot()</code>函数后使用)</li></ul><h5 id="1-2-MATLAB图形窗口"><a href="#1-2-MATLAB图形窗口" class="headerlink" title="1.2 MATLAB图形窗口"></a>1.2 MATLAB图形窗口</h5><ul><li>图形窗口创建:<code>figure()</code>函数</li><li>图形句柄:<code>h=figure</code>,返回新创建的图形窗口句柄到变量h中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h = gcf:其中变量h返回当前图形窗口的句柄</span><br><span class="line">h = gca:其中变量h返回当前坐标轴对象的句柄</span><br><span class="line">h = gco:其中变量h返回当前对象的句柄</span><br><span class="line">h=findobj:返回根对象与其所有子对象的句柄值</span><br><span class="line"></span><br><span class="line">get(h)函数用于获取指定句柄下的图形对象的属性</span><br><span class="line">set(h)函数用于设置指定句柄下的图形对象的属性</span><br></pre></td></tr></table></figure><ul><li>图形窗口常用操作命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clf:清除当前图形窗口的图形</span><br><span class="line">cla:清除当前图形窗口坐标轴内的图形，保留坐标轴</span><br><span class="line">delete()函数用于删除文件或图形对象，将永久性地删除文件，文件不进入回收站</span><br><span class="line">close()函数用于关闭指定的图形窗口</span><br><span class="line">reset()函数用于重置图形窗口的属性，使其恢复为默认值</span><br></pre></td></tr></table></figure><h5 id="1-3-坐标控制"><a href="#1-3-坐标控制" class="headerlink" title="1.3 坐标控制"></a>1.3 坐标控制</h5><ul><li>坐标轴范围设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axis([Xmin,Xmax,Ymin,Ymax]):设置坐标轴的范围，指定当前坐标轴x轴和y轴的范围，其中Xmin为x轴范围下限，Xmax为x轴范围上限，Ymin为y轴范围下限，Ymax为y轴范围上限</span><br><span class="line">axis([xmin xmax ymin ymax zmin zmax cmin cmax]):设置坐标轴x轴、y轴和z轴的范围，以及坐标轴的颜色显示范围</span><br><span class="line">xlim([xmin xmax]):仅设置x轴范围</span><br><span class="line">ylim([ymin ymax]):仅设置y轴范围</span><br><span class="line">zlim([zmin zmax]):仅设置z轴范围</span><br><span class="line">axis tight:按紧凑方式显示坐标轴范围，即坐标轴范围为绘图数据范围</span><br></pre></td></tr></table></figure><ul><li>坐标轴刻度设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(gca,&#x27;XTick&#x27;,[XTickmin:XTickstep:XTickmax]):设置数字刻度的显示范围和精度，与图形做图数据范围相对应</span><br><span class="line">set(gca,&#x27;XTickLabel&#x27;,[XTickLabelmin:XTickLabelstep:XTickLabelmax]):设置坐标轴刻度线下的数值显示，默认状态下为做图数据相应坐标轴数据范围和刻度</span><br><span class="line">set(gca,&#x27;XTickLabel&#x27;,string):设置文本坐标轴刻度。坐标系横纵坐标轴刻度的比例往往是根据数据自动设置的，比例有时可能不一样，通过执行语句axis equal可以获得等比例的坐标轴刻度</span><br></pre></td></tr></table></figure><ul><li>坐标轴字体设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FontName属性:字体的类型属性，包括常用的字体类型</span><br><span class="line">FontSize属性:字体的大小属性</span><br><span class="line">FontUnits属性:字体的单位属性</span><br><span class="line">FontWeight属性:字体样式属性，包括normal(正常)、bold(加粗)、light(倾斜)、demi(黑体)</span><br></pre></td></tr></table></figure><ul><li>坐标轴边框设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XDir属性:控制X轴方向属性，默认状态下属性值为&quot;normal(正常)&quot;，可选属性值有&quot;reverse(逆转)&quot;</span><br><span class="line">XColor属性:设置X轴边框的颜色属性</span><br><span class="line">LineStyleOrder属性:设置坐标轴边框的线条类型属性</span><br><span class="line">LineWidth属性:设置坐标轴边框的线条颜色属性</span><br></pre></td></tr></table></figure><ul><li>坐标轴显示控制</li></ul><blockquote><p>axis on和axis off控制，默认状态下开启</p></blockquote><h5 id="1-4-图形标注"><a href="#1-4-图形标注" class="headerlink" title="1.4 图形标注"></a>1.4 图形标注</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title()函数用于给当前图形坐标轴的正上方添加标题</span><br><span class="line">xlabel()/ylabel()函数给x轴和y轴坐标轴设置</span><br><span class="line">text()函数用于文本标注gtext()函数用于交互式文本标注</span><br><span class="line">legend()函数用于添加图例标注</span><br></pre></td></tr></table></figure><h5 id="1-5-窗口分割"><a href="#1-5-窗口分割" class="headerlink" title="1.5 窗口分割"></a>1.5 窗口分割</h5><blockquote><p>subplot()函数用于图形窗口的分割，即在同一个图形窗口可以同时显示多个坐标轴的图形。此函数可以用于设置多图形的同时显示，便于观察比对。</p><p>subplot()函数的使用原理为首先把图形窗口分为多个区域，然后依次在各区域绘制图形，其调用格式如下。</p><p>subplot(m,n,p):函数把图形窗口分为m×n个绘图子区，在第p个绘图子区绘制图形，绘图子区的编号按行方向编号。</p></blockquote><h3 id="2-特殊二维图形"><a href="#2-特殊二维图形" class="headerlink" title="2.特殊二维图形"></a>2.特殊二维图形</h3><blockquote><p>MATLAB为用户提供的特殊二维图形包括条形图、面积图、饼图、散点图、柱状图、罗盘图、羽毛图、矢量图、杆型图、阶梯图、极坐标图、等势图等</p></blockquote><h5 id="2-1-条形图"><a href="#2-1-条形图" class="headerlink" title="2.1 条形图"></a>2.1 条形图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar()函数:绘制垂直条形图</span><br><span class="line">barh()函数:绘制水平条形图</span><br></pre></td></tr></table></figure><h5 id="2-2-直方图"><a href="#2-2-直方图" class="headerlink" title="2.2 直方图"></a>2.2 直方图</h5><blockquote><p>直方图和条形图区别：</p><p>（1）直方图是用矩阵的面积表示各组数据的多少，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，其高度与宽度均有实际意义。条形图是用条形的长度表示各数据的多少，其宽度则是固定的，可任意设置，无实际意义；</p><p>（2）直方图的各矩形由于分组数据的连续性，一般情况下是连续排列的，而条形图在条形没有设置过大的情况下是分开排列的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hist()函数:绘制直方图</span><br><span class="line">rose()函数:在极坐标内绘制直方图</span><br></pre></td></tr></table></figure><h5 id="2-3-面积图"><a href="#2-3-面积图" class="headerlink" title="2.3 面积图"></a>2.3 面积图</h5><blockquote><p>面积图将数据点显示为一组由线连接的点，并填充线下方的所有区域</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area()函数:绘制面积图</span><br></pre></td></tr></table></figure><h5 id="2-4-饼图"><a href="#2-4-饼图" class="headerlink" title="2.4 饼图"></a>2.4 饼图</h5><blockquote><p>饼图是一个被划分为多个扇区的圆形图表，每个扇区代表一个数据项，描述各数据项占数据总和的比例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pie()函数:绘制二维饼图</span><br><span class="line">pie3()函数:绘制三维饼图</span><br></pre></td></tr></table></figure><h5 id="2-5-散点图"><a href="#2-5-散点图" class="headerlink" title="2.5 散点图"></a>2.5 散点图</h5><blockquote><p>散点图将数据序列显示为一组点。在回归分析中较为常用，反映了因变量随自变量而变化的趋势，便于观察两者关系</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scatter()函数:绘制散点图</span><br></pre></td></tr></table></figure><h5 id="2-6-排列图"><a href="#2-6-排列图" class="headerlink" title="2.6 排列图"></a>2.6 排列图</h5><blockquote><p>排列图又称累托（Pareto）图，用于寻找主要问题或主要原因所使用的图。它是由两个纵坐标、一个横坐标、几个按高低顺序依次排列的条形和一条累计百分比的折线组成。其中，左纵坐标表示频数，右纵坐标表示频率，横坐标表示各因素，按各因素高低从左到右显示，折线表示累积的频率。通过排列图可以较好的分析各因素的重要性</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pareto()函数:绘制排列图</span><br></pre></td></tr></table></figure><h5 id="2-7-罗盘图"><a href="#2-7-罗盘图" class="headerlink" title="2.7 罗盘图"></a>2.7 罗盘图</h5><blockquote><p>罗盘图绘制于一个圆盘中，从原点出发的箭头，箭头在圆盘中的角度用于表示数据的角度，箭头的长短用于表示数据的大小</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compass()函数:绘制罗盘图</span><br></pre></td></tr></table></figure><h5 id="2-8-羽毛图"><a href="#2-8-羽毛图" class="headerlink" title="2.8 羽毛图"></a>2.8 羽毛图</h5><blockquote><p>羽毛图是以箭头的形式绘制矢量数据，与罗盘图不同的是数据绘制于直角坐标系中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feather()函数:绘制羽毛图</span><br></pre></td></tr></table></figure><h5 id="2-9-矢量图"><a href="#2-9-矢量图" class="headerlink" title="2.9 矢量图"></a>2.9 矢量图</h5><blockquote><p>矢量图通常和其他图形一起使用，用于显示数据的方向</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiver()函数:绘制矢量图</span><br></pre></td></tr></table></figure><h5 id="2-10-杆型图"><a href="#2-10-杆型图" class="headerlink" title="2.10 杆型图"></a>2.10 杆型图</h5><blockquote><p>杆型图主要用来表示离散数据的变化规律，以离散的圆点表示每个数据点，并用线段把数据点和坐标轴连接起来，形如杆型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stem()函数:绘制杆型图</span><br></pre></td></tr></table></figure><h5 id="2-11-阶梯图"><a href="#2-11-阶梯图" class="headerlink" title="2.11 阶梯图"></a>2.11 阶梯图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stairs()函数:绘制阶梯图</span><br></pre></td></tr></table></figure><h5 id="2-12-极坐标图"><a href="#2-12-极坐标图" class="headerlink" title="2.12 极坐标图"></a>2.12 极坐标图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polar()函数:绘制极坐标图,在笛卡儿坐标系平面上绘制该函数，且画出极坐标形式的栅格</span><br></pre></td></tr></table></figure><h5 id="2-13-等值线图"><a href="#2-13-等值线图" class="headerlink" title="2.13 等值线图"></a>2.13 等值线图</h5><blockquote><p>等值线图可用于绘制地理数据中的等高图、气象数据中的等势图等。等值线图在二维图形中把第三维中相同大小的数据连接为等值线，一定程度上可以表示第三维的信息，同时，等值线图相比三维图更容易观察数据之间的关系，被广泛地应用于各个领域</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contour()函数:绘制二维等值线图</span><br><span class="line">contourf()函数:绘制带填充的二维等值线图</span><br><span class="line">clabel()函数:在等值线图上添加数据标签</span><br></pre></td></tr></table></figure><h5 id="2-14-曲线误差添加"><a href="#2-14-曲线误差添加" class="headerlink" title="2.14 曲线误差添加"></a>2.14 曲线误差添加</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errorbar()函数:绘制曲线误差</span><br></pre></td></tr></table></figure><h3 id="3-三维图形"><a href="#3-三维图形" class="headerlink" title="3.三维图形"></a>3.三维图形</h3><h5 id="3-1-三维图形绘制"><a href="#3-1-三维图形绘制" class="headerlink" title="3.1 三维图形绘制"></a>3.1 三维图形绘制</h5><blockquote><p>三维网格图形是指在三维空间内连接相邻数据点，形成网格。在MATLAB中绘制三维网格图的函数主要有mesh()、meshc()和meshz()，另外函数ezmesh()、ezmeshc()、ezmeshz()可根据函数表达式直接绘制相应的三维网格图</p><p>由于网格线是不透明的，绘制的三维网格图有时只能显示前面的图形部分，而后面的部分可能被网格线遮住了，没有显示出来。MATLAB中提供了命令hidden用于观察图形后面隐藏的网格</p><p>三维表面图也可以用来表示三维空间内数据的变化规律，与之前讲述的三维网格图的不同之处在于对网格的区域填充了不同的色彩。在MATLAB中绘制三维表面图的函数主要有surf()、surfc()和surfl()</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plot3()函数:绘制三维曲线</span><br><span class="line">meshgrid()函数:生成网格数据</span><br><span class="line">mesh()函数:绘制三维网格图</span><br><span class="line">meshc()函数:绘制带有等值线的三维网格图,不支持对图形网格线或等高线指定属性设置</span><br><span class="line">meshz()函数:绘制带有图形底边的三维网格图,不支持对图形网格线指定属性的设置</span><br><span class="line">contour3()函数:绘制三维等值线图,即在三维栅格图形上进一步添加等值线(类似于二维等值线图绘制函数contour())</span><br><span class="line">slice()函数:绘制三维切片图,三维切片图可形象地称为“四维图”，可以在三维空间内表达第四维的信息，用颜色来标识第四维数据的大小</span><br><span class="line">waterfall()函数:瀑布图</span><br><span class="line">cylinder()函数:生成关于z轴旋转对称的柱面体,结合surf()或mesh()生成柱面体的三维曲面图</span><br><span class="line">sphere()函数:在直角坐标系内绘制球形图</span><br><span class="line">ellipsoid()函数:生成绘制椭圆球体图的坐标数据,结合surf()或mesh()绘制三维椭球体图</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据可视化笔记</title>
      <link href="/2022/07/11/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/11/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>图表基本组成</li></ul><p>画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等</p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220711162907853.png"></p><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><blockquote><p>用于数据可视化、绘制各种图表</p></blockquote><ul><li><code>matplotlib</code>三步法绘制图表</li></ul><blockquote><ul><li>引入<code>matplotlib</code>模块</li><li>使用其提供的<code>plot</code>等方法绘制图表</li><li>运行程序</li></ul></blockquote><h3 id="图表常用设置"><a href="#图表常用设置" class="headerlink" title="图表常用设置"></a>图表常用设置</h3><ul><li>基本绘图函数</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.plot(x,y,format_string,**kwargs)</span><br></pre></td></tr></table></figure><blockquote><ul><li>x&#x2F;y：x&#x2F;y轴数据</li><li>format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式</li><li>kwargs：键值参数，相当于一个字典</li></ul></blockquote></blockquote><ul><li>线条颜色设置</li></ul><blockquote><p><code>color</code>参数设置线条颜色</p><blockquote><ul><li>通用颜色</li><li>其他颜色</li></ul></blockquote></blockquote><table><thead><tr><th align="center">设置值</th><th align="center">说明</th><th align="center">设置值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">蓝色</td><td align="center">y</td><td align="center">黄色</td></tr><tr><td align="center">g</td><td align="center">绿色</td><td align="center">k</td><td align="center">黑色</td></tr><tr><td align="center">r</td><td align="center">红色</td><td align="center">w</td><td align="center">白色</td></tr><tr><td align="center">c</td><td align="center">蓝绿色</td><td align="center">#FF00FF</td><td align="center">紫色</td></tr><tr><td align="center">m</td><td align="center">洋红色</td><td align="center">0.5</td><td align="center">灰度值字符串</td></tr></tbody></table><ul><li>线条样式设置</li></ul><blockquote><p><code>linestyle</code>参数设置线条样式</p><blockquote><ul><li>线条样式<ul><li>实线：’-‘</li><li>双划线：’–’</li><li>点划线：’-.’</li><li>虚线：’:’</li></ul></li><li>标记样式<ul><li><code>marker</code>参数设置</li><li><code>markerfacecolor</code>可以修改标记的颜色，简写为<code>mfc</code></li></ul></li></ul></blockquote></blockquote><table><thead><tr><th align="center">设置值</th><th align="center">说明</th><th align="center">设置值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">点标记</td><td align="center">1</td><td align="center">下花三角标记</td></tr><tr><td align="center">,</td><td align="center">像素标记</td><td align="center">2</td><td align="center">上花三角标记</td></tr><tr><td align="center">o</td><td align="center">实心圆标记</td><td align="center">3</td><td align="center">左花三角标记</td></tr><tr><td align="center">v</td><td align="center">倒三角标记</td><td align="center">4</td><td align="center">右花三角标记</td></tr><tr><td align="center">^</td><td align="center">上三角标记</td><td align="center">s</td><td align="center">实心正方形标记</td></tr><tr><td align="center">&gt;</td><td align="center">右三角标记</td><td align="center">p</td><td align="center">实心五角形标记</td></tr><tr><td align="center">&lt;</td><td align="center">左三角标记</td><td align="center">*</td><td align="center">星形标记</td></tr></tbody></table><ul><li>画布设置</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.figure(num=None,figure=None,dpi=None,facecolor=None,edgecolor=None,frameon=True)</span><br></pre></td></tr></table></figure><blockquote><ul><li>num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布</li><li>figsize：指定画布的宽和高，单位为英寸</li><li>dpi：指定绘图对象的分辩率，即每英寸包含多少个像素，默认值为80。像素越大，画布越<br>  大</li><li>facecolor：背景颜色</li><li>edgecolor：边框颜色</li><li>frameon：是否显示边框，默认值为True，绘制边框，如果为False，则不绘制边框</li></ul></blockquote></blockquote><ul><li>坐标轴设置</li></ul><blockquote><ul><li>设置坐标轴标题：xlabel&#x2F;ylabel函数</li><li>设置坐标轴刻度：xticks&#x2F;yticks函数</li><li>设置坐标轴范围：xlim&#x2F;ylim函数</li><li>设置网格线：grid()函数 参数与plot函数相差不大</li></ul><blockquote><p>处理中文显示：matplotlib.pyplot.rcParams[‘font.sans-serif’]&#x3D;[‘SimHei’]</p></blockquote></blockquote><ul><li>标签&#x2F;标题&#x2F;图例设置</li></ul><blockquote><ul><li>添加文本标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.text(x,y,s,**kwargs)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">通用绘图参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">fontsize</td><td align="center">字体大小</td></tr><tr><td align="center">ha</td><td align="center">水平对齐方式</td></tr><tr><td align="center">va</td><td align="center">垂直对齐方式</td></tr></tbody></table><ul><li>设置标题和图例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.title()</span><br><span class="line">matplotlib.pyplot.legend(loc=&#x27;best&#x27;)</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th align="center">位置</th><th align="center">描述</th><th align="center">位置</th><th align="center">描述</th><th align="center">位置</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">best</td><td align="center">自适应</td><td align="center">upper right</td><td align="center">右上方</td><td align="center">upper left</td><td align="center">左上方</td></tr><tr><td align="center">lower right</td><td align="center">右下方</td><td align="center">lower left</td><td align="center">左下方</td><td align="center">right</td><td align="center">右侧</td></tr><tr><td align="center">center left</td><td align="center">左中间</td><td align="center">center right</td><td align="center">右中间</td><td align="center">upper center</td><td align="center">上中间</td></tr><tr><td align="center">center</td><td align="center">正中央</td><td align="center">lower center</td><td align="center">下中间</td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>直接使用plt.legend(‘图例示例’)会显示不全，这时需修改为plt.legend((‘图例示例’,))</p></blockquote><ul><li>文本注释设置</li></ul><blockquote><ul><li>添加注释：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.annotate(s,xy,xytext,xycoords,arrowprops)</span><br></pre></td></tr></table></figure><ul><li>调整图表与画布边缘间距</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotli  b.pyplot.subplots_adjust(left,right,top,bottom)</span><br></pre></td></tr></table></figure><ul><li>坐标轴刻度线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.tick_params(bottom,left,right,top)</span><br><span class="line">matplotlib.pyplot.rcParams[&#x27;xtick.direction&#x27;]=&#x27;in&#x27;</span><br><span class="line">matplotlib.pyplot.rcParams[&#x27;ytick.direction&#x27;]=&#x27;out&#x27;</span><br></pre></td></tr></table></figure></blockquote><h3 id="常用图表绘制"><a href="#常用图表绘制" class="headerlink" title="常用图表绘制"></a>常用图表绘制</h3><ul><li>柱状图</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.bar(x,height,width,*,align=&#x27;center&#x27;,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><blockquote><ul><li>x：x轴数据</li><li>height&#x2F;width：高度&#x2F;宽度</li><li>align：对齐方式</li><li>kwargs：关键字参数</li></ul></blockquote></blockquote><ul><li>直方图</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.hist(x,bins)</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><blockquote><ul><li>x：数据集，最终直方图将对数据集进行统计</li><li>bins：统计数据的区间分布</li></ul></blockquote></blockquote><ul><li>饼形图</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.pie(x,labels,colors,labeldistance,autopct,startangle,radius,center,textprops)</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><blockquote><ul><li>x：每一块饼形图的比例</li><li>labels：每一块饼形图外侧显示的说明文字</li><li>colors：</li><li>labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1</li><li>autopct：设置饼图百分比，可以使用格式化字符串或format函数</li><li>startangle：起始绘制角度，默认是x轴正方向逆时针</li><li>radius：饼图半径，默认值为1</li><li>center：浮点类型的列表，可选参数，默认值为(0,0)表示图表中心位置</li><li>textprops：设置标签和比例文字的格式，字典类型</li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu云服务器搭建内网穿透服务</title>
      <link href="/2022/07/09/Ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/07/09/Ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是在Ubuntu 18.04云服务器上搭建FRP服务端，在windows上搭建客户端进行内网穿透。</p></blockquote><ul><li><code>FRP</code>的<code>GitHub</code>下载链接：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></li></ul><blockquote><p>根据需要下载对应的<code>FRP</code>压缩包</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220709102047128.png"></p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><ul><li>下载对应版本的<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>删除<code>frpc.ini</code>和<code>frpc</code>两个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> frp_0.43.0_linux_amd64</span><br><span class="line">$ sudo <span class="built_in">rm</span> frpc.ini</span><br><span class="line">$ sudo <span class="built_in">rm</span> frpc</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<code>frps.ini</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim frps.ini</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000# 监听端口</span><br><span class="line">dashboard_port=7500# 后台端口</span><br><span class="line">dashboard_user=root# 登录账户</span><br><span class="line">dashboard_pwd=root# 登录密码</span><br><span class="line">token = 1234354sdhfgksa1435hn56k546# 与客户端一致(鉴权)</span><br></pre></td></tr></table></figure><ul><li>设置开机自启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> frps.service</span><br></pre></td></tr></table></figure><ul><li>启动&#x2F;重启&#x2F;停止<code>frps</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start/restart/stop frps.service</span><br></pre></td></tr></table></figure><ul><li>打开浏览器输入<code>ip:7500</code>，输入账号密码，能进入<code>frp</code>后台则服务器端配置成功</li></ul><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>浏览器直接下载对应的<code>FRP</code>压缩包</li><li>解压<code>FRP</code>压缩包</li><li>删除<code>frps.ini</code>和<code>frps</code></li><li>修改配置文件<code>frpc.ini</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x# 服务器ip地址</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 1234354sdhfgksa1435hn56k546</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.test.lyj.com</span><br></pre></td></tr></table></figure><ul><li>命令行运行<code>frpc.exe</code></li></ul><blockquote><p>直接双击运行frpc.exe会提示如下内容：</p><p>This is a command line tool.</p><p>You need to open cmd.exe and run it from there.</p></blockquote><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>下载对应版本的<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压<code>FRP</code>压缩包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf frp_0.43.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>删除<code>frps.ini</code>和<code>frps</code>两个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> frp_0.43.0_linux_amd64</span><br><span class="line">$ sudo <span class="built_in">rm</span> frps.ini</span><br><span class="line">$ sudo <span class="built_in">rm</span> frps</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<code>frpc.ini</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim frpc.ini</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x# 服务器ip地址</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 1234354sdhfgksa1435hn56k546</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.test.lyj.com</span><br></pre></td></tr></table></figure><ul><li>设置开机自启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> frpc.service</span><br></pre></td></tr></table></figure><ul><li>启动&#x2F;重启&#x2F;停止<code>frps</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start/restart/stop frpc.service</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.freesion.com/article/4194977840/">UBUNTU18.04安装FRP的配置说明</a></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx和FTP搭建文件服务器</title>
      <link href="/2022/07/09/nginx%E5%92%8CFTP%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/07/09/nginx%E5%92%8CFTP%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install nginx</span><br></pre></td></tr></table></figure><ul><li>开机自启</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure><ul><li>启动&#x2F;重启&#x2F;停止&#x2F;查看状态 <code>nginx</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start/restart/stop/status nginx.service</span><br></pre></td></tr></table></figure><ul><li>查看<code>nginx</code>版本</li></ul><blockquote><p>下面的三种方法均可查看<code>nginx</code>的版本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -v<span class="comment"># 显示简要信息</span></span><br><span class="line">$ nginx -V<span class="comment"># 显示详细信息</span></span><br><span class="line">$ curl -i localhost</span><br></pre></td></tr></table></figure><ul><li>启动<code>nginx</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><ul><li>直接<code>ip</code>访问确定<code>nginx</code>是否正常启动</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220709141626253.png"></p><blockquote><p>出现上图字样表示<code>nginx</code>正常运行</p></blockquote><h1 id="nginx代理FTP服务器"><a href="#nginx代理FTP服务器" class="headerlink" title="nginx代理FTP服务器"></a>nginx代理FTP服务器</h1><ul><li>配置<code>FTP</code>访问服务</li></ul><blockquote><p>参照之前这篇文章：</p><p><a href="https://thee24lyj.github.io/2022/07/08/ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E7%8E%AF%E5%A2%83/">ubuntu云服务器搭建FTP环境</a></p></blockquote><ul><li>修改<code>nginx</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>的<code>http</code>块中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">                listen 8080;# 监听端口,一定要在防火墙开放该端口</span><br><span class="line">                server_name localhost;# 映射名称,ip访</span><br><span class="line"></span><br><span class="line">                location / &#123;</span><br><span class="line">                        alias  /home/ftp/lyj/;  # FTP服务器文件夹</span><br><span class="line">                        autoindex on;   # 打开文件目录列表</span><br><span class="line">                        index lyj;      # 设置欢迎页</span><br><span class="line">                        autoindex_exact_size on;# 显示文件大小，单位字节</span><br><span class="line">                        autoindex_localtime on; # 显示时间</span><br><span class="line">                        charset utf-8,gbk;      # 设置编码格式防止中文乱码</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>重启<code>nginx</code>服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><ul><li>浏览器访问<code>ip:8080</code>即可访问<code>FTP</code>服务的文件夹</li></ul><p>参考：</p><p><a href="https://blog.csdn.net/weixin_42337937/article/details/88903999?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-88903999-blog-89414679.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-88903999-blog-89414679.pc_relevant_aa&utm_relevant_index=1">Nginx代理FTP服务器</a></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu云服务器搭建FTP环境</title>
      <link href="/2022/07/08/ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/07/08/ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：这里采用<code>vsftpd</code>在<code>Ubuntu 18.04</code>云服务器上搭建<code>FTP</code>服务，支持匿名用户、本地用户和虚拟用户三种类型。</p></blockquote><h1 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install vsftpd</span><br></pre></td></tr></table></figure><ul><li>使用<code>ps -ef | grep ftp</code>命令查看是否开启了<code>FTP</code>服务进程，有如下进程表示开启成功。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220705142920121.png"></p><ul><li>设置开机自启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> vsftpd</span><br></pre></td></tr></table></figure><ul><li>查看<code>FTP</code>服务状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status vsftpd.service</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220705143933305.png"></p><ul><li>启动&#x2F;重启&#x2F;停止<code>FTP</code>服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start/restart/stop vsftpd.service</span><br></pre></td></tr></table></figure><h1 id="匿名用户访问配置"><a href="#匿名用户访问配置" class="headerlink" title="匿名用户访问配置"></a>匿名用户访问配置</h1><ul><li>创建FTP存放目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /home/ftp</span><br><span class="line">$ <span class="built_in">cd</span> /home/ftp</span><br><span class="line">$ <span class="built_in">mkdir</span> anonymous<span class="comment"># 匿名访问目录</span></span><br></pre></td></tr></table></figure><ul><li>备份<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/vsftpd.conf /etc/vsftpd.conf.bak</span><br></pre></td></tr></table></figure><ul><li>修改<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>需要修改内容如下(配置匿名用户只有读权限)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Allow anonymous FTP? (Disabled by default).</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">anon_root=/home/ftp/anonymous</span><br><span class="line">no_anon_password=YES</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><h1 id="本地用户访问配置"><a href="#本地用户访问配置" class="headerlink" title="本地用户访问配置"></a>本地用户访问配置</h1><ul><li>添加<code>FTP</code>用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> /home/ftp/lyj<span class="comment"># 创建FTP用户家目录</span></span><br><span class="line">$ sudo useradd -d /home/ftp/lyj -s /bin/bash ftpuser<span class="comment"># 添加FTP用户ftpuser</span></span><br><span class="line">$ sudo passwd ftpuser<span class="comment"># 添加密码</span></span><br><span class="line">$ sudo <span class="built_in">chown</span> ftpuser:ftpuser -R /home/ftp/lyj/<span class="comment"># 修改目录权限</span></span><br></pre></td></tr></table></figure><blockquote><p>查看<code>FTP</code>本地用户：<code>cat /etc/passwd | grep ftp</code></p><p>删除<code>FTP</code>用户：<code>sudo deluser --remove-home username</code></p></blockquote><ul><li>将新添加的<code>ftpuser</code>用户添加到<code>vsftpd.chroot_list</code>文件</li></ul><blockquote><p>这里是使<code>ftpuser</code>不被限制到主目录中，可以切换并访问其他目录的文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.chroot_list</span><br><span class="line"><span class="comment"># 直接添加ftpuser保存即可</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>需要修改内容如下(配置本地用户有读写权限)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Allow anonymous FTP? (Disabled by default).</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">anon_root=/home/ftp/anonymous</span><br><span class="line">no_anon_password=YES</span><br><span class="line">#</span><br><span class="line"># Uncomment this to allow local users to log in.</span><br><span class="line">local_enable=YES</span><br><span class="line">local_root=/home/ftp/lyj</span><br><span class="line">#</span><br><span class="line"># Uncomment this to enable any form of FTP write command.</span><br><span class="line">write_enable=YES</span><br><span class="line"></span><br><span class="line"># You may restrict local users to their home directories.  See the FAQ for</span><br><span class="line"># the possible risks in this before using chroot_local_user or</span><br><span class="line"># chroot_list_enable below.</span><br><span class="line"># 是否将所有用户限制在登录根目录内</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"># 是否锁定用户的chroot功能</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"># (default follows)</span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><h1 id="本地虚拟用户访问配置"><a href="#本地虚拟用户访问配置" class="headerlink" title="本地虚拟用户访问配置"></a>本地虚拟用户访问配置</h1><ul><li>创建本地无法登录的用户及其登录目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sueradd guest -d /var/ftp -s /bin/nologin</span><br><span class="line">sudo <span class="built_in">mkdir</span> /var/ftp/guest</span><br><span class="line">sudo <span class="built_in">chown</span> guest:guest -R /var/ftp</span><br></pre></td></tr></table></figure><ul><li>创建虚拟用户的文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /var/ftp/anonymous /var/ftp/admin /var/ftp/test</span><br></pre></td></tr></table></figure><ul><li>创建虚拟用户统一存放配置文件的文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /etc/vsftpd</span><br></pre></td></tr></table></figure><ul><li>创建用户数据库<code>ftpguests</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ftpguests</span><br><span class="line"><span class="comment"># 以下为添加内容,用户名及其密码独占一行</span></span><br><span class="line">admin</span><br><span class="line">admin_passwd</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">test_passwd</span><br></pre></td></tr></table></figure><ul><li>生成用户数据库<code>ftpguests.db</code></li></ul><blockquote><p>用到的工具为<code>db_load</code>，若没安装则执行<code>sudo apt install db-util</code>安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo db_load -T -t <span class="built_in">hash</span> -f ftpguests /etc/vsftpd/ftpguests.db</span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /etc/vsftpd/ftpguests.db</span><br></pre></td></tr></table></figure><ul><li>修改<code>pam</code>认证文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/pam.d/vsftpd /etc/pam.d/vsftpd.bak</span><br><span class="line">sudo vim /etc/pam.d/vsftpd</span><br></pre></td></tr></table></figure><p>在<strong>第一行</strong>添加如下内容：</p><blockquote><p>auth sufficient pam_userdb.so db&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;ftpguests<br>account sufficient pam_userdb.so db&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;ftpguests</p></blockquote><p>其中<code>sufficient</code>表示同时支持虚拟用户和本地用户</p><ul><li>建立虚拟用户的配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/admin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_root=/var/ftp</span><br><span class="line"># 具有读权限,查看文件夹/文件</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line"># 具有写权限,新建文件夹/文件</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line"># 具有修改权限,修改文件夹/文件</span><br><span class="line">anon_other_write_enable=YES</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_root=/var/ftp/test</span><br><span class="line"># 具有读权限,查看文件夹/文件</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line"># 具有写权限,新建文件夹/文件</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line"># 没有修改权限,不能修改文件夹/文件</span><br><span class="line">anon_other_write_enable=NO</span><br></pre></td></tr></table></figure><ul><li>修改配置文件<code>/etc/vsftpd.conf</code></li></ul><blockquote><p>在上面本地用户访问配置基础上添加如下内容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启虚拟用户访问</span><br><span class="line">guest_enable=YES</span><br><span class="line"># 把虚拟用户映射到本地用户guest</span><br><span class="line">guest_usernaem=guest</span><br><span class="line"># 指定虚拟用户配置文件所在目录</span><br><span class="line">user_config_dir=/etc/vsftpd</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h3 id="1-使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题"><a href="#1-使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题" class="headerlink" title="1.使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题"></a>1.使用FileZilla软件连接报错：服务器发回了不可路由的地址。使用服务器地址代替的问题</h3><ul><li>修改<code>vsftpd</code>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br><span class="line"></span><br><span class="line">#开启被动模式</span><br><span class="line">pasv_enable=YES</span><br><span class="line">#被动模式端口范围</span><br><span class="line">pasv_min_port=6000</span><br><span class="line">pasv_max_port=6010</span><br><span class="line">#需要加入外部ip，否则被动模式会失败</span><br><span class="line">pasv_address=云服务器外部ip地址</span><br><span class="line">pasv_addr_resolve=YES</span><br></pre></td></tr></table></figure><ul><li>重启<code>FTP</code>服务</li></ul><blockquote><p>记得开放云服务器上对应的被动端口，否则无法访问。</p></blockquote><h3 id="2-限制本地用户在主目录后仍然能访问其他目录"><a href="#2-限制本地用户在主目录后仍然能访问其他目录" class="headerlink" title="2.限制本地用户在主目录后仍然能访问其他目录"></a>2.限制本地用户在主目录后仍然能访问其他目录</h3><blockquote><p>这里首先介绍一下<code>/etc/vsftpd.conf</code>配置文件中的三个相关参数，然后根据需要可以</p></blockquote><ul><li><code>chroot_local_user</code></li></ul><p>作用：是否将所有用户限制在主目录中，默认为NO表示不做限制，否则表示启用限制</p><ul><li><code>chroot_list_enable</code></li></ul><p>作用：是否启用限制用户的名单，默认为NO表示禁用，否则表示启用</p><ul><li><code>chroot_list_file</code></li></ul><p>作用：是否限制在主目录下用户名称的文件，对该文件中的用户是否限制则根据<code>chroot_local_user</code>和<code>chroot_list_enable</code>确定</p><table><thead><tr><th align="center">chroot_local_user&#x3D;YES chroot_list_enable&#x3D;YES</th><th align="center">所有用户均被限制在其主目录，chroot_list_file中的用户不受限制</th></tr></thead><tbody><tr><td align="center"><strong>chroot_local_user&#x3D;YES chroot_list_enable&#x3D;NO</strong></td><td align="center"><strong>所有用户均被限制在其主目录下</strong></td></tr><tr><td align="center"><strong>chroot_local_user&#x3D;NO chroot_list_enable&#x3D;YES</strong></td><td align="center"><strong>所有用户均不被限制， chroot_list_file中的用户受到限制</strong></td></tr><tr><td align="center"><strong>chroot_local_user&#x3D;NO chroot_list_enable&#x3D;NO</strong></td><td align="center"><strong>所有用户均不被限制在其主目录下</strong></td></tr></tbody></table><h3 id="3-报错500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot"><a href="#3-报错500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot" class="headerlink" title="3.报错500 OOPS: vsftpd: refusing to run with writable root inside chroot()"></a>3.报错500 OOPS: vsftpd: refusing to run with writable root inside chroot()</h3><ul><li>这是由于<code>vsftpd</code>从<code>2.3.5</code>之后增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限，如果检查发现还有写权限，就会报该错误。</li><li>网上有两种方法分别是：（1）<code>sudo chmod a-w /home/ftp/anonymous</code>(用户主目录) （2）在配置文件中添加<code>allow_writeable_choot=YES</code> ，但是我这里只有第一种方法可行，第二种没有效果，大家若遇到可以两种方法都尝试一下</li></ul><h3 id="4-其他错误"><a href="#4-其他错误" class="headerlink" title="4.其他错误"></a>4.其他错误</h3><ul><li><code>FileZilla</code>软件报错如下：</li></ul><blockquote><p>553 Could not create file.</p><p>错误:严重文件传输错误</p></blockquote><p>一般可能是权限不够的问题，也有可能是磁盘空间已满的原因。</p><p>可以尝试修改文件权限(<code>777</code>)，或者修改文件所属用户</p><blockquote><p>550 Failed to change directory.</p><p>错误:读取目录列表失败</p></blockquote><p>可能是权限问题，也可能是<code>SElinux</code>的<code>FTP</code>传输审核功能禁止切换目录，还可能是限制了用户对主目录的访问。</p><p>参考文章：</p><p><a href="https://www.toobug.cn/post/3629.html">Ubuntu下同时搭建支持匿名、本地、虚拟用户的ftp服务器</a></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX数学公式学习笔记</title>
      <link href="/2022/02/15/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/15/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：这篇文章是我学习<code>LaTeX</code>数学公式时根据<a href="https://www.bilibili.com/video/BV1no4y1U7At">数学公式怎么敲？LaTeX保姆级教程</a>讲解边看边写而成的学习笔记，留下作为记录.</p><blockquote><p>注意：这里由于网页不方便渲染<code>LaTeX</code>，因此我将<code>typora</code>中的<code>LaTeX</code>渲染效果变为图片，其下代码即该<code>LaTeX</code>代码.</p></blockquote></blockquote><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223637.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\delta</span>,<span class="keyword">\lambda</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Delta</span>,<span class="keyword">\Lambda</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\alpha</span>,<span class="keyword">\beta</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Alpha</span>,<span class="keyword">\Beta</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\phi</span>,,<span class="keyword">\varphi</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\epsilon</span>,<span class="keyword">\varepsilon</span><span class="keyword">\\</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220213162358.png"></p><h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><p><strong>英文字母只有在表示变量(或单一字符的函数名称)才使用斜体,其余情况使用罗马体(直立体)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223715.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a<span class="built_in">^</span>2,a<span class="built_in">_</span>1<span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;y+z&#125;,P<span class="built_in">_</span>&#123;ij&#125;<span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>i,x<span class="built_in">_</span>&#123;<span class="keyword">\rm</span> i&#125;,x<span class="built_in">_</span>&#123;<span class="keyword">\text</span> i&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\text</span>&#123;A B&#125;,<span class="keyword">\rm</span>&#123;A B&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\text</span> A B,<span class="keyword">\rm</span> A B<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\rm</span> A&#125; B<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\text</span>&#123;e&#125;,<span class="keyword">\text</span>&#123;i&#125;<span class="keyword">\\</span></span><br><span class="line">e,i</span><br></pre></td></tr></table></figure><blockquote><p>e:自然对数底数，为常数</p><p>i,j:叙述单位，常量</p></blockquote><h1 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223756.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125;,<span class="keyword">\frac</span> 1 2<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> 1&#123;x + y&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> &#123;<span class="keyword">\frac</span> 1 x + 1&#125;&#123;y + 1&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> &#123;<span class="keyword">\dfrac</span> 1 x + 1&#125;&#123;y + 1&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223822.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span> 2,<span class="keyword">\sqrt</span> &#123;x+y&#125;,<span class="keyword">\sqrt</span>[3] x</span><br></pre></td></tr></table></figure><blockquote><p>\frac (fraction,分数) \dfrac (display-style)</p><p>\sqrt (square root,平方根)</p></blockquote><h1 id="普通运算符"><a href="#普通运算符" class="headerlink" title="普通运算符"></a>普通运算符</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223848.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ -<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\times</span>,<span class="keyword">\cdot</span>,<span class="keyword">\div</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\pm</span>,<span class="keyword">\mp</span><span class="keyword">\\</span></span><br><span class="line">&gt;&lt;,<span class="keyword">\ge</span>,<span class="keyword">\le</span>,<span class="keyword">\gg</span>,<span class="keyword">\ll</span>,<span class="keyword">\ne</span>,<span class="keyword">\approx</span>,<span class="keyword">\equiv</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cap</span>,<span class="keyword">\cup</span>,<span class="keyword">\in</span>,<span class="keyword">\notin</span>,<span class="keyword">\subseteq</span>,<span class="keyword">\subsetneq</span>,<span class="keyword">\subsetneqq</span>,<span class="keyword">\varnothing</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\forall</span>,<span class="keyword">\exists</span>,<span class="keyword">\nexists</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\because</span>,<span class="keyword">\therefore</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathbb</span> R,<span class="keyword">\R</span>,<span class="keyword">\Q</span>,<span class="keyword">\N</span>,<span class="keyword">\Z</span><span class="built_in">_</span>+<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathcal</span> f,<span class="keyword">\mathscr</span> f<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathcal</span> F,<span class="keyword">\mathscr</span> F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214223954.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\cdot</span>,<span class="keyword">\cdots</span>,<span class="keyword">\vdots</span>,<span class="keyword">\ddots</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\infty</span>,<span class="keyword">\partial</span>,<span class="keyword">\nabla</span>,<span class="keyword">\propto</span>,<span class="keyword">\degree</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224012.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sin</span> x,<span class="keyword">\sec</span> x,<span class="keyword">\cosh</span> x,<span class="keyword">\tan</span> x<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\log</span><span class="built_in">_</span>2 x,<span class="keyword">\ln</span> x,<span class="keyword">\lg</span> x<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> 0&#125; <span class="keyword">\frac</span> &#123;x&#125;&#123;<span class="keyword">\sin</span> x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> 0&#125; <span class="keyword">\frac</span> &#123;x&#125;&#123;<span class="keyword">\sin</span> x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\max</span> x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224033.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\text</span>&#123;MSE&#125;(x)</span><br></pre></td></tr></table></figure><blockquote><p>运算符名称超过一个字母时应用直立体</p></blockquote><h1 id="大型运算符"><a href="#大型运算符" class="headerlink" title="大型运算符"></a>大型运算符</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224050.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sum</span>,<span class="keyword">\prod</span><span class="keyword">\\</span><span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">\sum</span><span class="built_in">_</span>i,<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>N<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n x<span class="built_in">_</span>i&#125;&#123;<span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n x<span class="built_in">_</span>i&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224106.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\int</span>,<span class="keyword">\iint</span>,<span class="keyword">\iiint</span>,<span class="keyword">\oint</span>,<span class="keyword">\oiint</span>,<span class="keyword">\oiiint</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;-<span class="keyword">\infty</span>&#125;<span class="built_in">^</span>0 f(x)<span class="keyword">\,</span><span class="keyword">\text</span> d x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224121.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a<span class="keyword">\,</span>a<span class="keyword">\\</span></span><br><span class="line">a<span class="keyword">\ </span>a<span class="keyword">\\</span></span><br><span class="line">a<span class="keyword">\quad</span> a<span class="keyword">\\</span></span><br><span class="line">a<span class="keyword">\qquad</span> a</span><br></pre></td></tr></table></figure><h1 id="标注符号"><a href="#标注符号" class="headerlink" title="标注符号"></a>标注符号</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224141.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\vec</span> x,<span class="keyword">\overrightarrow</span> &#123;AB&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span> x,<span class="keyword">\overline</span> &#123;ABC&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220213170348.png"></p><h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224154.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\leftarrow</span>,<span class="keyword">\rightarrow</span>,<span class="keyword">\Rightarrow</span>,<span class="keyword">\Leftarrow</span>,<span class="keyword">\Leftrightarrow</span>,<span class="keyword">\longleftarrow</span>,<span class="keyword">\longrightarrow</span>,<span class="keyword">\Longrightarrow</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220213170617.png"></p><h1 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224214.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">([])<span class="keyword">\&#123;</span> <span class="keyword">\&#125;</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lceil</span>,<span class="keyword">\rceil</span>,<span class="keyword">\lfloor</span>,<span class="keyword">\rfloor</span>,||<span class="keyword">\\</span></span><br><span class="line">(0,<span class="keyword">\frac</span> 1 a)<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\left</span>(0,<span class="keyword">\frac</span> 1 a<span class="keyword">\right</span>)<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\frac</span> &#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> x&#125;|<span class="built_in">_</span>&#123;x=0&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\left</span>.<span class="keyword">\frac</span> &#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> x&#125;<span class="keyword">\right</span>|<span class="built_in">_</span>&#123;x=0&#125;</span><br></pre></td></tr></table></figure><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224232.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line">a=b+c+d<span class="keyword">\\</span></span><br><span class="line">=e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224246.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a<span class="built_in">&amp;</span>=b+c+d<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>=e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line">a<span class="built_in">&amp;</span>=b+c+d<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>=e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure><h1 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224300.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(x)=</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\sin</span> x,<span class="built_in">&amp;</span>-<span class="keyword">\pi</span><span class="keyword">\le</span> x <span class="keyword">\le</span> <span class="keyword">\pi</span><span class="keyword">\\</span><span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>0,<span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;others&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224339.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224354.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224406.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224416.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line"></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> c<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">e <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/20220214224428.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\bf</span> A,<span class="keyword">\bf</span> B<span class="built_in">^</span>&#123;<span class="keyword">\rm</span> T&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\mathbf</span> A,<span class="keyword">\mathbf</span> B<span class="built_in">^</span>&#123;<span class="keyword">\rm</span> T&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bf</span> B<span class="built_in">^</span>&#123;<span class="keyword">\text</span> T&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU配置CUDA和cuDNN</title>
      <link href="/2022/02/09/GPU%E9%85%8D%E7%BD%AECUDA%E5%92%8CcuDNN/"/>
      <url>/2022/02/09/GPU%E9%85%8D%E7%BD%AECUDA%E5%92%8CcuDNN/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：最近需要使用电脑的GPU进行并行计算，由于以前也配置过GPU的深度学习环境，但是并没有自己总结如何配置GPU的CUDA和CUDNN，因此趁着这次写了这篇文章，留作记录。</p></blockquote><h1 id="一、清理NVIDIA的CUDA和CUDNN"><a href="#一、清理NVIDIA的CUDA和CUDNN" class="headerlink" title="一、清理NVIDIA的CUDA和CUDNN"></a>一、清理NVIDIA的CUDA和CUDNN</h1><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164204090.png"></p><ul><li>从未配置过GPU深度学习环境的话直接跳过</li><li>如果以前配置过对应的<code>GPU</code>深度学习环境，需要重新配置的话，计算机中<strong>至多</strong>保留上面的应用程序，卸载完成后记得用火绒等软件清理无用的注册表</li></ul><h1 id="二、安装CUDA-Toolkit"><a href="#二、安装CUDA-Toolkit" class="headerlink" title="二、安装CUDA Toolkit"></a>二、安装CUDA Toolkit</h1><h3 id="1、CUDA版本说明"><a href="#1、CUDA版本说明" class="headerlink" title="1、CUDA版本说明"></a>1、CUDA版本说明</h3><ul><li>使用命令<code>nvidia-smi</code>和<code>nvcc -V</code>均能查看安装的<code>CUDA</code>版本，但不同的是<code>nvidia-smi</code>查看的是显卡驱动程序安装的<code>CUDA</code>版本，<code>nvcc -V</code>是由<code>CUDA Toolkit</code>安装的<code>CUDA</code>版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122175005396.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122175022225.png"></p><blockquote><p>像使用GPU进行深度学习通常是指<code>nvcc -V</code>的<code>CUDA</code>版本</p></blockquote><ul><li>关于CUDA的不同版本可以参考文章<a href="https://blog.csdn.net/jslove1997/article/details/113737934">cuda 的driver API 和 runtime API</a>，个人认为写得比较详细</li></ul><h3 id="2、下载CUDA-Toolkit安装包"><a href="#2、下载CUDA-Toolkit安装包" class="headerlink" title="2、下载CUDA Toolkit安装包"></a>2、下载CUDA Toolkit安装包</h3><ul><li><a href="https://developer.nvidia.com/cuda-downloads">CUDA ToolKit下载官网地址</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164640340.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164925694.png"></p><ul><li>根据需要下载对应版本的<code>CUDA Toolkit</code>安装包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165145110.png"></p><h3 id="3、-安装CUDA-11-0"><a href="#3、-安装CUDA-11-0" class="headerlink" title="3、 安装CUDA 11.0"></a>3、 安装CUDA 11.0</h3><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122164825897.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165309511.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165426651.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165537851.png"></p><blockquote><p>注意：我的电脑上已经安装了最新版本的驱动程序，所以才显示该警告，可不用理会。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165620985.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165638383.png"></p><blockquote><p>注意：精简是安装全部CUDA组件而非最小的组件</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165805807.png"></p><blockquote><p>注意：只选择CUDA组件且不选Visual Studio Integration，其他组件均不选</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165934489.png"></p><blockquote><p>注意：CUDA安装位置可根据需要放于不同位置，这里我直接使用默认位置。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122165958542.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170336236.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170347346.png"></p><h3 id="4、CUDA安装完成"><a href="#4、CUDA安装完成" class="headerlink" title="4、CUDA安装完成"></a>4、CUDA安装完成</h3><ul><li>检查是否安装成功</li></ul><blockquote><ul><li>(1) 命令行运行<code>nvcc -V</code>显示对应的版本号表示安装成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170523191.png"></p><ul><li>(2) 查看环境变量</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170710595.png"></p><ul><li>(3) 运行对应程序，均显示<code>PASS</code>则安装成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122173224113.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122173326384.png"></p></blockquote><h1 id="三、cuDNN安装"><a href="#三、cuDNN安装" class="headerlink" title="三、cuDNN安装"></a>三、cuDNN安装</h1><h3 id="1、下载与CUDA相对应的cuDNN安装包"><a href="#1、下载与CUDA相对应的cuDNN安装包" class="headerlink" title="1、下载与CUDA相对应的cuDNN安装包"></a>1、下载与CUDA相对应的cuDNN安装包</h3><ul><li>新用户需要注册后才能下载</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122170943567.png"></p><ul><li>同意后，点击<code>Archived cuDNN Releases</code>选择适合的<code>cuDNN</code>版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122171028474.png"></p><ul><li>选择适合于<code>CUDA</code>版本和平台的<code>cuDNN</code>下载</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122172212722.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122172808484.png"></p><h3 id="2、cuDNN安装"><a href="#2、cuDNN安装" class="headerlink" title="2、cuDNN安装"></a>2、cuDNN安装</h3><ul><li>将安装包解压后，直接将<code>cuda</code>文件夹下的三个文件夹移入对应的<code>CUDA</code> 安装目录下</li></ul><blockquote><p>我电脑上的CUDA安装目录为<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Thee24LYJ/Pic_Image/images/image-20220122173548567.png"></p><ul><li>到这里GPU深度学习环境就配置好了，可以愉快地开始学习深度学习了~~~</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github搭建个人博客</title>
      <link href="/2021/02/03/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/02/03/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h3><ul><li>新建名为<code>username.github.io</code>的仓库，例如<code>Thee24LYJ.github.io</code></li><li>创建成功后，博客网站访问地址就是<code>https://Thee24LYJ.github.io</code>(不区分大小写)</li></ul><h3 id="2-配置SSH-key"><a href="#2-配置SSH-key" class="headerlink" title="2.配置SSH key"></a>2.配置SSH key</h3><ul><li><p>提交代码需要拥有<code>github</code>权限，但是直接使用用户名和密码不安全，所以我们使用<code>ssh key</code>来解决本地和服务器的连接问题</p></li><li><p>使用<code>git bash</code>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh<span class="comment"># 检查本机已经存在的ssh密匙</span></span><br></pre></td></tr></table></figure><p>如果提示<code>No such file or directory</code>说明是第一次使用<code>git</code></p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span><span class="comment"># 邮件地址为GitHub绑定的邮箱</span></span><br></pre></td></tr></table></figure><p>然后连续三次回车，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开<code>github</code>主页，进入个人设置 -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code>：输入刚才复制的<code>Key</code>，<code>Title</code>随意</p></li><li><p>测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com </span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入<code>yes</code>，然后会看到：</p><p><code>Hi Thee24LYJ! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，说明<code>SSH</code>配置成功。</p></li><li><p>此时还需要配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Thee24LYJ&quot;</span>// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用hexo写博客"><a href="#3-使用hexo写博客" class="headerlink" title="3.使用hexo写博客"></a>3.使用hexo写博客</h3><ul><li><p><code>hexo</code>介绍</p><ul><li><p><code>Hexo</code>是一个简单、快速、强大的基于 <code>Github Pages</code> 的博客发布工具，支持<code>Markdown</code>格式，有众多优秀插件和主题</p></li><li><p>官网： <a href="http://hexo.io/">http://hexo.io</a></p></li><li><p>github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p></li></ul></li><li><p>原理</p><p>由于<code>github pages</code>存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，所以<code>hexo</code>所做的就是将这些<code>md</code>文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到<code>github</code></p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure></li><li><p>初始化</p><p>新建一个文件夹用来存放博客代码，名字任意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /e/hexo/<span class="comment">#文件夹目录</span></span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容</p></li></ul><h3 id="4-上传代码"><a href="#4-上传代码" class="headerlink" title="4.上传代码"></a>4.上传代码</h3><ul><li><p>在上传代码到<code>github</code>之前，一定要记得先把你以前所有代码下载下来（虽然<code>github</code>有版本管理，但备份一下总是好的），因为从<code>hexo</code>提交代码时会把你以前的所有代码都删掉</p></li><li><p>使用命令<code>hexo d</code></p><ul><li><p><code>ssh key</code>要配置好</p></li><li><p><code>_config.yml</code>中<code>deploy</code>要配好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Thee24LYJ/Thee24LYJ.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>执行<code>hexo d</code>报错：<code>Deployer not found: github 或者 Deployer not found: git</code></p><p>原因是还需要安装一个插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul></li><li><p>保留<code>CNAME、README.md</code>文件</p><ul><li><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非<code>md</code>文件可以把他们放到<code>source</code>文件夹下，这里的所有文件都会原样复制（除了<code>md</code>文件）到<code>public</code>目录的：</p></li><li><p>由于<code>hexo</code>默认会把所有<code>md</code>文件都转换成<code>html</code>，包括<code>README.md</code>，所有需要每次生成之后、上传之前，手动将<code>README.md</code>复制到<code>public</code>目录，并删除<code>README.html</code>。</p></li></ul></li><li><p>常用<code>hexo</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-写博客"><a href="#5-写博客" class="headerlink" title="5.写博客"></a>5.写博客</h3><ul><li><p>定位到我们的<code>hexo</code>根目录，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure><p><code>hexo</code>会帮我们在<code>_posts</code>下生成相关<code>md</code>文件，我们只需要打开这个文件就可以开始写博客了</p><p>当然也可以直接自己新建<code>md</code>文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line"><span class="section">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;my-second-blog&quot;</span></span><br></pre></td></tr></table></figure><p>最终部署时生成：<code>hexo\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。</p></li><li><p>让博文内容不完全展示</p><p>  默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上<code>&lt;!--more--&gt;</code>即可设置文章展示的长度。</p></li><li><p>删除某篇文章</p><p>  直接删除<code>_posts</code>文件夹下的<code>.md</code>文章，然后执行<code>hexo g</code>重新生成删除文章后的网页，再执行<code>hexo d</code>上传</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
